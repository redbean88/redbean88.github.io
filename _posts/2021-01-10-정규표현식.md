---
title: 10분 정규 표현식
date : 2021-01-10
categories : regex
---

# 손에 잡히는 10분 정규 표현식

## 1장 정규 표현식 소개
직관 적이지 않지만 간단한 문제를 풀때 코드를 줄일 수 있다.

> 정규 표현식은 어디에 사용하는가?

- 검색
- 치환

---

## 2장 문자 하나 찾기

**문자 그대로 찾기**

문장 자체도 정규식이라고 볼수 있다

> 예문  

hello, my name is Ben. please visit ...
> Regex

Ben
> 결과

hello, my name is  __Ben__. please visit ...

> 추가

자바스크립트에서는 일치된 결과물을 모두 담은 배열을 반환하고자 할때, `g`(Global:전역) 플레그를 사용한다.



__모든 문자 찾기__

마침표(.)는 어떠한 문자나 알파벳, 숫자, 문장 부호로 쓰인 마침표(.)차체와도 일치한다.

> 예문  

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls   

> Regex

sales.
> 결과

__sales1__.xls   
orders3.xls   
__sales3__.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls

> 분석

여기서 사용한 sales.라는 정규 표현식은 sales로 시작하고, sales 바로 뒤에 아무문자가 하나 더 붙는 파일명을 모두 찾는다.

마침표(.)는 어떠한 문자나 알파벳, 숫자, 심지어 문장 부호로 쓰인 마침표(.)자체와도 일치한다.


.a. 다음에 바로 마침표가 따라오는 문자열과 일치시키려면 어떨게 해야할까?

__특수문자 찾기__

마침표(.)는 정규 표현식에서 특별한 의마가 있다. 따라서 여러분이 마침표(.)를 찾으려고 한다면, 정규 표현식에세 특별한 의미의 마침표(.)가 아니라 지짜 마침표(.)를 찾고 싶다고 알려 줘야 한다. 그러려면 마침효(.)앞에 역슬레시(\\)를 문자를 붙이면 된다. 역슬래시(\\)는 __메타 문자__(일반적으로 문자 그대로 사용되지 않고 특별한 의미를 지니는 문자를 칭한다)다. 따라서 마침표(.)는 모든 문자와 일치하디만, \\.는 마침표(/)문자 자체와 일치한다는 의미다.

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls   

> Regex

.a.\\.

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
__na1.__xls   
__na2.__xls   
__na3.__xls  

> 분석

.a.\\.로 해결되었다. 첫 번째 마침표(.)는 n 혹은 s와 일치하였다. 두 번째 마침표(.)는 1 혹은 2와 일치하였으며, \\.는 파일명과 확장자를 구분하는 마침표(.)와 일치하였다.

`역슬레시 자체를 찾고 싶을 경우 \\\이라고 쓴다.`

---

## 3장 문자 집합으로 찾기

문자집합을 사용하면 특정 문자들과 문자 번위를 일치시킬 수 있다.

__여러 문자 중 하나와 일치시키기__

마침표(.)는 어떤 문자든지 문자 하나와 일치한다. 하지만 만약 이전 예제에서 `cal1.xls` 를 제외한 ,
`na`와 `sa` 만을 찾고 싶을 때는 어떨게 할 것인가?

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls
ca3.xls   

> Regex

[ns]a.\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
__na1.xls__   
__na2.xls__   
__na3.xls__   
ca3.xls  

> 분석

정규 표혁인시 [ns] 로 시작한다. 이 패턴은 ns이나 s 중 한 문자와 일치하며, c나 다른 문자와는 일치하지 않는다. 대괄호([])는 집합을 의미하므로 대괄호 자체는 어떤 문자와도 일치하지 않는다. 문자 a는  a와 일치하고 마침표(.)는 모든 문자와 일치한다.

문자 집합은 흔희 대소문자를 구별하지 않고 검색하거나 검색할 부분의 특정 영역만 대소문자를 구별하지 않을 때 사용한다.

> 예문

The parase "regulas expression" is often  
abbreviated as Regex or regex

> Regex

[Rr]eg[Ee]x

> 결과

The parase "regulas expression" is often  
abbreviated as __Regex__ or __regex__

> 분석

여기서 사용한 패턴에는 문자 집합이 두 개 있가. [Tr]은 R이나 r과 일치하고, [Ee]는 E나 e와 일치한다. 이런 식으로 `Regex`와 `regex` 둘 다 일치시킬 수 있다. 하디만 REGEX와는 일치하지 않는다.

__문자 집합 범위 사용하기__

마지막으로 사용한 패턴 [ns]a.\\.xls 에는 또 다른 문제가 있다. 만약 `sam.xls` 라는 파일이 있다면, 어떻게 할 것인가?
문자 집합을 사용해 이 문제를 해결할 수 있다.

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls
ca3.xls  

> Regex

[ns]a[0123456789]\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
sam.xml   
__na1.xls__   
__na2.xls__   
__na3.xls__  
ca3.xls  

> 분석

이번에 수정한 정규 표현식에서는 첫 글자가 n이나 s와 일치하고, 두 번째 글자는 a, 세 번째 글자는 숫자([0123456789]에 소한 숫자)와 일치한다. sam.xls는 일치하지 않았다는 점을 확인하자.
아래는 하이픈을 통한 범위를 설정하여, 같은 결과를 표현한다.


> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls  
sam.xml     
na1.xls   
na2.xls   
na3.xls
ca3.xls  

> Regex

[ns]a[0-9]\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
sam.xml   
__na1.xls__   
__na2.xls__   
__na3.xls__  
ca3.xls  

> 분석

범위를 단지 숫자에만 쓸 수 있는 것은 아니다. 다음과 같은 범위에서도 모두 사용할 수 있다.

- A-Z는 A부터 Z사이에 있는 모든 대문자와 일치한다
- a-z는 a부터 z사이에 있는 모든 소문자와 일치한다
- A-z는 아스키 문자 A와 아스키 문자 z 사이에 있는 모든 문자와 일치한다.(이 패턴은 비추천한다. Z와 a 사이에는 대괄호나([) 캐럿(^)도 포함되기 때문이다.)

아래의 예는 RGB 값을 찾는 방법이다

> 예문

body{  
    background-color : #fefbd8;  
}  
h1{  
    background-color : #fefbd8;  
}  

> Regex

\#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]

> 결과


body{  
    background-color : __#fefbd8__;  
}  
h1{  
    background-color : __#fefbd8__;  
}  

> 분석

여기서 사용한 패턴에서는 샵(#) 문자가 문자 그대로 일치하고, [0-9A-Fa-f] 문자 집합이 여섯 번 반복된다.
이 패턴은 숫자나 A와 F사이의 문자이며, 대소문자를 구별하지 않는다.

__'제외하고' 찾기__

멸 개만 빼고 대부분의 문자를 포함해야 할 경우에는 패턴이 너무 실어지므로 원하는 문자를 모두 나열하기보다는 캐럿(^) 문자를 써 제외할 문자 집합을 지정한다.

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls  
sam.xml     
na1.xls   
na2.xls   
na3.xls
ca3.xls  

> Regex

[ns]a[^0-9]\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls  
__sam.xml__     
na1.xls   
na2.xls   
na3.xls
ca3.xls  

> 분석

[0-9]는 모든 숫자와 일치한다 [^0-9]는 정해징 범위 내에 있는 수자와 일치하지 않는다.   
즉, [ns]a[^0-9]\\.xls는 na1.xls, na2.xls, na3.xls 와는 일치하지 않고, sam.xls와 일치한다.

---
## 4장 메타 문자 사용하기

__이스케이프 다시 살펴보기__

메타 문자는 정규 표션식 안에서 특별한 의미가 있다. 마침표(.)는 메타 문자로, 어떤 문자든 문자 하나와 일치한다. 이와 유사하게, 여는 대괄호([)도 집합의 시작을 나타내는 메타 문자다

메타 문자들은 정규 표현식에서 특별한 의미가 있으므로 자기 자신을 문자 그대로 표현할 수 없다. 여는 대괄호([)가 여는 대괄호([))와 일치하지 않는다는 의미다.

다음 예제를 보자. 이 정규 표현식에서는 여는 대괄호([)와 단는 대괄호(])를 포함하는 자바스크립트 배열을 찾으려 한다.

> 예문

var myArray = new Array();  
...  
if(myArray[0] == 0){}  
...  

> Regex

myArray\\[0\\]

> 결과

var myArray = new Array();  
...  
if(__myArray[0]__ == 0){}  
...  

> 분석

이 예제에서 쓴 정규 표현식은 다소 불필요해 보인다. 단순한 텍스트 검색만으로도 충분희 만족스러운 결과를 더 쉽게 얻을 수 있다. 하지만 단순히 myArray[0]뿐만 아니라 myArray[1] 과 같은 배열도 찾으려면 어떻게 해야 할지 상상해 보자. 이때는 정규 표현식을 사용하는 편이 더 유용하다. 여는 대괄호([)와 닫는 대괄호(])는 이스케이프 하고 두 문자 사이에 원하는 문자들이 일치하도록 조건을 정하면 된다. 만약 배열 요소를 0부터 9까지 일치시키고 싶다면 다음과 같이 정규 표현식을 작성할 수도 있다.

myArray\\[[0-9]\\]

역슬레시(\\)는 메타 문자들을 이스케이프 하는 데 사용된디. 이 말은 열슬레시(\\)도 메타 문자이며, 다른 메타 문자들을 이스케이프 하는데 사용된다는 뜻이다.
 다음에 나온 간단한 예제에선 윈도우에서 볼 수 있는 역슬래시(\\)를 이용한 파일 경로다. 이 경로를 리눅스에서 사용한다는 가정하에 모든 역슬래시를 찾아 슬래시로 변경해 보자

> 예문

\home\ben\sales\

> Regex

\\\

> 결과

__\\__ home __\\__ ben __\\__ sales __\\__

> 분석

정규 표현식에 역슬래시(\\)만을 사용했다면, 아마 에러가 발생했을 것이다. 정규 표현식 분석기가 정규표현식을 다 작성하지 않았다고 판단하기 때문이다. 그러니 정규 표현식에서는 역슬래시(\\)위에 반드시 다른 문자를 함께 써넣어야 한다.

__공백 문자 찾기__

메타 문자는 일반적으로 두 가지 범주로 나뉜다. 마침표(.)처럼 텍스트와 와 일치하는 문자와 여는 대괄호([)나 닫는 대괄호(])처럼 정규 표현식문법의 일부로 쓰는 문자다. 이제 공백 문자를 살펴보면서 두 가지 유형의 메타 문자들을 더 많이 접할 것이다. 우선 공백 메타 문자부터 시작 해 보자.

 정규 표현식 검색을 수행할 때, 여러분은 눈에 보이지 않지만 텍스트에 포함되는 공백 문자를 찾아야 할 때가 있을 것이다. 꼼수를 이용하지 않고 이런 문자를 정슈 표현식에 직접 써넣기는 어려우므로 아래ㅠㅛ와 같은 특수한 메타 문자들을 사용할 수 있다.

 |메타 문자 | 설명|
 |:--|:--|
 |\[\\b\]|백 스페이스|
 |\\f|페이지 넘김(form feed)|
 |\\n|줄바꿈|
 |\\r|캐리지 리턴|
 |\\t|텝|
 |\\v|수직 텝|

 다음 예제를 보자. 여기에 나오는 예문에는 콤마로 구분된(일반적으로 CSV라고 부른다) 레코드가 담겨 있다. 여러분은 게디어터에 있는 빈 줄을 모두 제거한 다음, 이 레코드를 처리해야한다.

 > 예문

"101","Ben","forta"  
"102","Jim","James"  

"103","Robert","Bet"  

> Regex

\\r\\n\\r\\n

> 결과

"101","Ben","forta"  
"102","Jim","James"  

"103","Robert","Bet"  

> 분석

\\r\\n은 줄바꿈과 캐리지 리턴의 조합과 일치한다. 윈도우에서 이 조합은 줄의 끝을 나타내는 데 사용된다.
따라서 \\r\\n\\r\\n을 검색하면, 줄 씉이 연속해서 두 번 나오는 부분과 일치하는데, 이때 줄의 끝이 두번 나온다는 것은 바로 두 레코드 사이에 빈 줄이 있음을 의미한다.

__특정한 문자 형태와 일치시키기__

자주 쓰는 문자 집합들은 특수한 메타 문자로 대신하기도 한다. 이런 메타 문자들을 __문자 클래스__ 라고 부른다. 직접 찾고 싶은 문자들을 열거하거나 범위를 사용하면 되기 때문에, 실제로 클래스 메타 문자를 써야만 하는 경우는 결코 없지만, 일단 사용해 보면 너무나도 유용함을 알게 된다.

__숫자와 숫자가 아닌 문자 찾기__

|메타 문자| 설명|
|:--|:--|
|\\d| 숫자 하나([0-9])와 같다|
|\\D| 숫자를 제외한 문자 하나([^0-9])와 같다.|

앞선 예문를 수정하여 이 메타문자를 어떻게 쓰는지 확인해보자

> 예문

var myArray = new Array();  
...  
if(myArray[0] == 0){}  
...  

> Regex

myArray\\[\\d\\]

> 결과

var myArray = new Array();  
...  
if(__myArray[0]__ == 0){}  
...  

> 분석

이 정규 표현직은 myArray[1] 과는 일치하지만  myArray[10] 과는 일치하지 않는다.

__영숫자 문자와 영숫자가 아닌 문자 찾기__

자주 사용하는 문자 집합이 또 있다. 영숫자 무자로, 대소문자와 소문자를 포함한 알파벳 A부터 Z, 숫자, 밑줄(대개 파일이나 디렉터리 이름, 애플리케리션 변수명, 데이터베이스 객체 이름 등에 사용한다.)을 포함한다.

|메타 문자| 설명|
|:--|:--|
|\\w|대소문자와 밑줄을 포함하는 모든 영숫자[a-zA-Z0-9]와 같다.|
|\\W|대소문자와 밑줄을 아닌 모든 영숫자[^a-zA-Z0-9]와 같다.|

> 예문

12313  
A1C2E3  
480787  
48907  
H1B4F2  
908700  
H1H2H3  

> Regex

\w\d\w\d\w\d

> 결과

12313  
__A1C2E3__  
480787  
48907  
__H1B4F2__  
908700  
__H1H2H3__  

> 분석

여기서는 메타 문자 \\w와 \\d를 조합한 패턴을 사용했는데, 캐나다 우편번호만을 찾아낸다

__공백 문자와 공백이 아닌 문자 찾기

마지막으로 살펴볼 분류는 공백 클래스다.

|메타 문자| 설명|
|:--|:--|
|\\s|모든 공백 문자([\\f\\n\\r\\t\\v])와 같다.|
|\\S|공백 문자가 아닌 모든 문자([^\\f\\n\\r\\t\\v])와 같다.|

__16진수 사용하기__

16진수 같은 앞에 \\x를 붙여 표시한다. 즉, \\x0A는 줄바꿈 문자가 되며 \\n과 기능이 같다.

__8진수 사용하기__

8진수 같은 두 자리나 세 자리 정수 앞에 \\0을 붙여 표시한다. 즉, \\011은 탭 문자이며, \\t와 기능이 같다

__포직스 문자 클래스 사용하기__

포직스 문자 클래스는 줄여 쓰기를 나타내는 또 다른 형태인데, 전부는 아니지만 많은 정규 표현식 구현에서 지원한다.

_자바스크립트는 정규 표현식에서 포직스 문자 클래스를 지원하지 않는다._

[정규표현식](https://www.nextree.co.kr/p4327/)

## 5장 반복찾기

이 장에서는 여러 번 반복해 나타나는 문자나 문자 집합을 어떻게 맞는지 알아본다.

__몇 번 일치하는가?__

이메일 주소와 일치하는 정규 표현직을 작성한다고 생각해 보자. 이메일 주소의 기본 형식은 다음과 같다.

text@text.text

4장에서 배운 메타 문자를 사용해 다음과 같은 정규 표현식을 만들 수 있다.

\\w@\\w\\.\\w

\\w 문자는 모든 영숫자 문자와 일치한다. 더불어 밑줄도 함께 찾는데, 밑줄 역시 이메일 주소에서 사용하는 문자다. 앳(@)은 이스케이프 하지 않아도 되지만, 마침표(.)는 이스케이프 해야한다.

이 패턴은 문법에 완벽하게 맞는 정규 표현식이긴 하지만 쓸모 없다. 이 패턴으로는  a@b.v 같은 이메일 주소만 찾을 수 있다. 문법은 맞지만, 분명히 유효한 메일 주소는 아니다. 문제는 \\w는 문자 하나하고만 일치하는데, 얼마나 많은 문자를 검사해야 할지 모른다는 점이다. 다음 이메일 주소들은 모두 유효하지만, @ 문자 앞에 나온 문자 수는 서로 다르다.  

b@forta.com  
ben@forta.com  
bfort@forta.com  

__하나 이상의 문자 찾기__

문자나 집합에 속한 요소를 하나 이상 찾으려면 간단리 문자 뒤에 더하기(+) 문자를 붙이면 된다. 더하기(+) 문자는 문자가 하나 이상일때 일치한다(최소한 하나와 일치하고, 없을 때는 일치하지 않는다). a가 a를 찾는 데 반해, a+는 하나 이상 연속된 a를 찾는다. 비슷하게 [0-9]는 자릿수가 하나인 숫자를 찾는 데 반해, [0-9]+는 한자리 이상 연속된 숫자를 찾는다.  

이번에는 더하기(+)를 사용해 하나 이상의 문자와 일치시키자.  

> 예문

Send personal email to ben@forta.com For questions  
about a book use support@forta.com Feel free to send
....

> Regex

\\w+@\\w+\\.\\w+

> 결과

Send personal email to __ben@forta.com__ For questions  
about a book use __support@forta.com__ Feel free to send
....

다하기(+)는 문자 집합이 하나 이상인 경우에도 사용한다. 다음 예제로 실험해 보자. 정규 표현식은 같지만 예문이 조금 다르다.

> 예문

Send poersonal email to ben@forta.com or  
ben.forta@forta.com. For questions about a   
book use support@forta.com. If your message  
is urgent try ben@urgent.forta.com. Feel  
....

> Regex

\\w+@\\w+\\.\\w+

> 결과

Send poersonal email to __ben@forta.com__ or  
ben.__forta@forta.com__. For questions about a   
book use __support@forta.com__. If your message  
is urgent try __ben@urgent.forta__.com. Feel  
....

> 분석

정규 표현식으로 주소를 네가지 찾았지만, 그중 두 개(ben.forta@forta.com, ben@urgent.forta.com)는 제대로 검색되지 않았다.  
\\w+@\\w+\\.\\w+는 앳(@) 앞에 나오는 마침표(.)를 일치시키지 못하고, 앳(@) 귀에 문자열을 둘로 나누는 마침표(.)는 하나만 검색되도록 설정되었기 때문이다. \\w는 영숫자와 일치하지만, 문자열 중간에 있는 마침표(.)와는 일치하지 않기 때문에 ben.forta@forta.com리 올바른 이메일 주소라 해도, 이 정규 표현식은 ben.forta 대신 forta만 찾는 것이다.  

이제 \\w나 마침표(.) 와 일치하도록, 정규 표현식 규칙에 따라 [\\w.] 집합을 정의해야 한다.   

> 예문

Send poersonal email to ben@forta.com or  
ben.forta@forta.com. For questions about a   
book use support@forta.com. If your message  
is urgent try ben@urgent.forta.com. Feel  
....

> Regex

[\\w.]+@[\\w.]+\\.\\w+

> 결과

Send poersonal email to __ben@forta.com__ or  
__ben.forta@forta.com__. For questions about a   
book use __support@forta.com__. If your message  
is urgent try __ben@urgent.forta.com__. Feel  
....

> 분석

[\\w.]+를 쓰니 문자, 밑줄, 마침표(.)가 하나 이상 일치해 ben.forta를 제대로 찾아 냈다.
 [\\w.]+는 앳(@) 뒤에서 더 깊은 단계의 도메인 주소를 찾기도 했다.  

 _이 패턴을 보고 집합 안에서는 마침표(.)를 이스케이프 하지 않아도 마침표(.)와 일치한다는 사실을 알았을 것이다. 일반적으로 마침표(.)나 더하기(+) 같은 메타 문자들이 집합의 구성원일 때는 문자 그대로 취급되므로 굳이 이스케이프 할 필요가 없다. 그러나 이스케이프 한다고 문제가 생기지는 않는다. [\\w.]과 [\\w\\.]은 기능이 같다._  

__문자가 없거나 하나 이상 연속하는 문자 찾기__

더하기(+)는 하나 이상 연속된 문자를 찾는다. 문자가 없는 경우는 아예 찾지 못하고, 최소한 하나는 일치해야 한다. 하지만 있을 수도 있고 없을 수도 있는 문자와 일치시키려면 어떻게 해야 할까?  그럴 때는 메타문자인 별표(\*)를 사용하면 된다. 별표(\*)는 더하기(+)와 거의 비슷하게 사용하는데, 문자나 집합 바로 뒤에 두면 찾고자 하는 문자나 집합이 없는 경우 또는 하나 이상 연속하는 경우에 일치한다. 따라서 B.* Forta  패턴은 B Forta, B. Forta, BenForta 같은 조합과도 일치한다.  
앞서 나온 이메일 예제를 수정해 별표(\*)의 사용법을 살펴보자.  

> 얘문

Hello .ben@forta.com is my email address.

> Regex

[\\w.]+@[\\w.]+\\.\\w+

> 결과

Hello .__ben@forta.com__ is my email address.

> 분석

패턴이 더 복잡해 진 것 같지만 실재로는 그렇지 않다. \\w\|는 마침표를 제외한 영숫자 문자와 모두 일치한다.(즉, 이메일 주소의 시작으로 유효한 문자를 말한다.) 우선 첫 문자가 유효하면, 그 다음에는 마침표(.)가 하나 나오거나 문자가 더 나올 수도 있다. 사실 이런 이멤일 주소는 없을지도 모른다. [\\w.]*는 문자가 없는 연우를 포함해 여러 개의 영숫자 혹은 마침표(.)와 일치하는데, 이것이 우리가 찾고자 한 텍스트다.

__문자가 없거나 하나인 문자 찾기__

매우 유용한 메타 문자로 물음표(?)가 있다. 별표(\*)처럼 물음표(?)는 문자가 있는 경우 일치하고 문자가 없어도 일치하지만, 별표(\*)와 달리 문자나 집합이 없거나 하나만 있는 경우에만 일치하며, 하나 이상은 일치하지 않는다. 즉, 물음표(?)는 문자 묶음 안에서 있는지 없는지 확실하지 않은 특정한 문자를 하나만 찾을 때 매우 유용하다.

> 예문

The URL is http://www.forta.com/, to connect  
securely user https:///www.forta.com/ instead.

> Regex

http:\\/\\/[\\w.\\/]+

> 결과

The URL is __http://www.forta.com/__, to connect  
securely user https:///www.forta.com/ instead.

> 분석

이 패턴은 URL을 일치시키고자 http:\\/\\/를 썼고, 문자 그대로 찾기 때문에 오직 해당 문자와만 일치한다. 이어서 [\\w.\\/]+가 영숫자 문자, 마침표(.), 슬러시(/)로 이루어진 집합의 구성 요소 가운데 하나 이상과 일치한다. 이 패턴은 처음에 있는 http:// 로 시작하는 URL과는 일치하지만 두 번째에 있는 https:// 로 시작하는 URL과는 일치하지 않는다. 그렇다고 s가 없더나 하나 이상 연속될 대 일치하는 s*가 적합하지도 않다. httpssssss:// 도 일치하기 때문이다.  

해결방법은 다음 예제처럼 s?를 쓰는 것이다.  


> 예문

The URL is http://www.forta.com/, to connect  
securely user https:///www.forta.com/ instead.

> Regex

https?:\\/\\/[\\w.\\/]+

> 결과

The URL is __http://www.forta.com/__, to connect  
securely user __https:///www.forta.com/__ instead.

> 분석

이 패턴은 https?:\\/\\/로 시작한다. 물음표(?)는 자기 앞에 있는 문자가 없거나 그 문자가 하나만 있는 경우 일치한다. 여기서는 s인데, https?:// 는 http:// 나 https:// 와는 일치하지만, 그 외에는 일치하지 않는다.  

덧붙여 물음표(?)를 쓰면 4장에서 언듭한 문제도 해결된다. 우리는 \\r\\n 으로 줄의 끝을 일치시키는 예제를 살펴봤는데, 유닉스나 리눅스 환경에서는 \\r 은 제외하고 \\n 만 사용한다고 언급했다. 이때 \\n 앞에 \\r이 있을 경우에만 일치시키는 것이 이상적인 해결책일 것이라고도 했다. 정규표현식을 약간 수정했다.  

> 예문

"101","Ben","forta"  
"102","Jim","James"  

"103","Robert","Bet"  

> Regex

[\\r]?\\n[\\r]?\\n

> 결과

"101","Ben","forta"  
"102","Jim","James"  

"103","Robert","Bet"  

> 분석

[\\r]?\\n은 \\r이 있을 경우에는 \\r과 일치하고, \\n과는 반드시 일치한다.

__구간 지정하기__

더하기(+), 별표(*), 물음표(?)는 정규 표현식을 쓰면서 발생하는 많은 문제를 해결해 주지만, 충분하지 않은 때도 있다. 다음과 같은 상황을 생각해 보자.  

- 더하기(+)와 별표(*)는 일치하는 문자 수에 제한이 없다. 문자가 최대 몇 개까지 일치하는지는 정할 수 없다.  
- 더하기(+), 별표(*), 물음표(?)가 일치하는 무자 수의 최솟값은 0이나 1이다. 일치하는 문자 숫의 최솟값을 명시적으로 정의할 수 없다.  
- 정확히 원하는 만큼만 일치하도록 문자 수를 정의할 수 없다.  

이런 문제들을 해결하고, 연혹하는 문자를 찾을 때 검색 조건을 더 구체적으로 지정하고자 정규 표현식에서는 __구간__ 을 사용한다. 구산은 중괄호({}) 안에 표시한다.  

__정확한 구간 찾기__

문자가 일치하는 수를 정확히 정하려면 여는 중괄호({)와 닫는 중괄호(}) 사이에 숫자를 넣는다. 즉, {3}은 바로 앞에 있는 문자나 문자 집합이 세 번 연속해서 일치하는지 확인한다. 만약 요소가 두 개만 있다면, 패턴이 일치하지 않는다.  

 3장과 4장에서 활용한 RGB예제를 수정해 어떻게 작동하는지 알아보자. 여러분은 RGB값이 두 개씩 ㅅ짝지어진 16진수 숫자 집합 세개로 이루어짐을 기억할 것이다. 처음에는 RGB 값을 찾을 때 다음과 같은 패턴을 사용했다.  

\#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]

이 예제에 구간 찾기를 사용해 보겠다

> 예문

body{  
    background-color : #fefbd8;  
}  
h1{  
    background-color : #fefbd8;  
}  

> Regex

\#[0-9A-Fa-f]{6}

> 결과


body{  
    background-color : __#fefbd8__;  
}  
h1{  
    background-color : __#fefbd8__;  
}  

> 분석

[0-9A-Fa-f]는 하나의 16진수 문자와 일치함을, {6}은 이를 여섯번 반복함을 뜻한다.

__범위 구간 찾기__

값(일치 횟수)의 범위, 다시 말해 일치시키려는 요소(instance) 수의 최솟값과 최댓값을 나타낼 때도 구간을 사용한다. 범위는 {2,4}처럼 표현한다. 최소 두 번에서 최대 네 번까지 일치시킨다는 의미다. 날짜 형식을 찾는 정규 표현식이 범위 구간 찾기를 보여주는 예로 적정하다.

> 예문

4/8/17  
10-6-2020  
2/2/2  
01-01-01  

> Regex

\\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{2,4}

> 결과

__4/8/17__  
__10-6-2020__  
2/2/2  
__01-01-01__  

> 분석

여기에는 사용자가 입력창에 써넣었을 만한 값이 나열되었다. 이 값들은 날짜 형식에 맞게 입력되어야 한다. \\d{1,2}는 한 자리 혹은 두 자리 숫자와 일치해 날짜와 월을 검사하고 \\d{2,4}는 연도와 일치하며, [-\\/]는 날짜 구분선인 하이픈(-)이나 슬러시(/)와 일치한다. 결과적으로 연도가 너무 짧아서 일치하지 않은 2/2/를 제외하고 날짜가 세개 일치했다.  

중요한 것은 이 패턴으로는 날짜가 옳은지 검사하지는 못한다는 점이다. 54/67/9999 처럼 값이 틀려도 검사를 통과한다. 이 패턴은 날짜형식에 맞는지만 검사할 뿐이다. 그래서 이 단계는 주로 날짜 자체가 유효한지 검사하기 전에 이루어진다.  

__'최소' 구간 찾기__

마지막으로 구간 검색은 최댓값 없이 찾고자 하는 요소의 최솟값을 지정할 수도 있다. 이 패턴에서 쓴 구간 문법은 범위와 비슷하지만, 최댓값이 없다는 점만 다르다. 예를 등러 {3,}은 최소한 요소가 세번 일치함을 의미한다. 다시 말해, 요소가 세 번 이상 일치한다는 것이다. 다음 예제에서는 이 장에서 배운 것들을 조합해 보았다. 이 예제에는 주문 금액이 100달러 이상인 주문을 모두 찾는 정규 표현식을 썼다.  

> 얘문

1001: $496.80  
1002: $1290.80  
1003: $26.80  
1004: $613.80  
1005: $7.80  
1006: $414.80  
1007: $25.80  

> Regex

\\d+:\\$\\d{3,}\\.\\d{2}

> 결과

__1001: $496.80__  
__1002: $1290.80__  
1003: $26.80  
__1004: $613.80__  
1005: $7.80  
__1006: $414.80__  
1007: $25.80  

> 분석

예문은 주문 번호와 주문 금액을 보여 주는 보고서다. 이 정규 표현식은 처음에 \\d+:를 써 주문 번호를 찾는다. 주문 번호를 포함한 전체 행이 아니라, 단순히 금액만 찾고 싶다면 이 패턴을 빼도 무방하다.  

\\$\\d{3,}\\.\\d{2} 는 금액과 일치하는 패턴이다. \\$는 달러기호($). \\d{3,}은 최소한 세 자리 숫자(즉, 최소 100달러), \\.은 마침표(.), 마지막으로 \d{2}는 소수점 이하 두 자리 숫자와 일치한다. 이 패턴은 일곱 개 주문 중 네 개와 일치한다.  

__과하게 일치하는 상황 방지하기__

물음표(?)는 제한된 범위만큼 일치시키고(없거나 하나만 있는 경우와 일치한다.), 구간을 쓰면 정확히 지정한 만큼 일치하거나 지정한 범위 안에서만 검색을 수행한다. 하지만 이 장에서 소개한 패턴들은 일차하는 횟수에 제한이 없기 때문에 때로는 너무 많이 일치하기도 한다.  

 그래서 지금까지 나온 예제는 모두 일치하지 않아도 되는 텍스트까지 과도하게 일치하는 상황이 없도록 주의 깊게 선택했지만, 다음 예제를 생각해 보자. 다음 예문은 웹 페이지의 일부고 HTML 테그인 \<b\> 가 포함되었다. 정규 표현식으로 \<b\> 태그로 둘러싸인 텍스트(형식을 바꾸려고 하는지도 모든다)를 일치시켜야 한다.  

 > 예문

This offer is not available to customers  
living in \<b\>AK\</b\> and \<b\>HI\</b\>.  

> Regex

\<[Bb]\>.*\<\\/[Bb]\>

> 결과

This offer is not available to customers  
living in __\<b\>AK\</b\> and \<b\>HI\</b\>__.

> 분석

\<[Bb]\>는 \<b\> 시작 태그와 일치하고, <\\/[Bb]\> 는 \</b\> 종료 태그와 일치한다. 두 경우 모두 대소문자를 구별하지 않는다. 하지만 두 번이 아니라 오직 한 번만 일치했다. .* 는 처음 나온 \<b\>부터 마지막에 나온 \</b\> 사이에 있는 모든 텍스트와 일치하므로 __AK\</b\> and \<b\>HI__ 가 일치한 것이다. 우리가 원하는 텍스트를 포함하긴 하지만, 찾으려 하지 않은 텍스트도 포함했다.  

바로 별표(*)와 더하기(+) 같은 메타 문자가 __탐욕적(Greedy)__ 이므로 이는 가능한 가장 큰 덩어리를 찾으려 한다는 뜻이다. 이런 메타 문자는 찾으려는 텍스트를 앞에서부터 찾는 게 아니라, 텍스트 마지막에서 시작해 거꾸로 찾는다. 의도적으로 수량자를 탐욕적으로 설계했기 때문이다.  

 하지만 만약 우리가 탐욕적 일치를 원하지 않는다면 어떻게 해야 할까? 탐욕적 수량자를 __게으른(Lazy)__ 수량자로 바꿔 이 문제를 해결한다.  
 '게으른'이라고 부르는 이유는 문자가 최소로 일치하기 때문이다. 게으른 수량자는 기존 수량자 뒤에 물음표(?)를 붙여서 표현한다. 아래 표는 탐욕적 수량자에 대응되는 게으른 수량자 이다.   

|탐욕적 수량자|게으른 수량자|
|:--|:--|
|*|*?|
|+|+?|
|{n,}|{n,}?|

*?는 별표(\*)의 게으른 수량자인데, 이 문자를 이용해 앞서 나온 예제를 수정해 보자

 > 예문

This offer is not available to customers  
living in \<b\>AK\</b\> and \<b\>HI\</b\>.

> Regex

\<[Bb]\>.*?\<\\/[Bb]\>

> 결과

This offer is not available to customers  
living in __\<b\>AK\</b\>__ and __\<b\>HI\</b\>__.

> 분석

게으른 수량자인 *?를 사용해서, 두 부분을 따로 일치시켰다.

## 6장 위치 찾기

이따금 텍스트 영역 내에 있는 특정 위치에서 텍스트를 찾아야 할 때도 있다. 그러려면 위치 찾기가 필요하며, 이 장에서는 바로 위치 찾기를 배울 것이다.

__경계 지정하기__

위치 찾기는 텍스트 문자열 안에서 만드시 일치해야 하는 위치를 지정할 때 사용한다. 위치 찾기가 왜 필요한지 이해하기 위해 다음 예제를 살펴보자

> 예문

The cat scattered his food all over the room.

> Regex

cat

> 결과

The __cat__ s __cat__ tered his food all over the room.

> 분석

cat 패턴은 cat이 있는 부분과 모두 일치한다. 심지어  scattered라는 단어 사이에 있는 cat 과도 일치한다. 사실 이런 결과를 바랐을 수도 있다. 하지만 그렇지 않을 가능성이 더 크다. 만약 우리가 cat을 모두 dog로 치환화려고 검색했다면 다음과 같은 말도 안되는 결과를 얻게 된다.

The dog sdogtered his food all over the room.

이렇 때 __경계__ 를 사용하거나 패턴 앞이나 뒤에 특정한 위치 혹은 경계를 나타내는 메타 문자를 사용하면 된다.

__단어 경계 지정하기__

처음으로 알아볼 경계는 가장 흔하게 쓰는 방법인데,  \\b로 표시하는 단어 경계다. 단어 경계라는 이름에서 유추해 볼 수 있듯이, \\b는 단어의 시작이나 마지막을 일치시킬 때 사용한다.  

\\b를 어떻게 쓰는지 알아보고자 앞서 본 예제를 다시 사용할 텐데, 이번에는 경계를 지정하겠다.

> 예문

The cat scattered his food all over the room.

> Regex

\\bcat\\b

> 결과

The __cat__ scattered his food all over the room.

> 분석

cat이라는 단어 앞뒤는 빈칸인데 여기서 빈칸은 단어와 단어를 구분하는 문자들 가운데 하나이므로,  \\bcat\\b와 일치한다. 하지만 scattered라는 단어 사이에 있는 cat은 앞에는 s, 뒤에는 t가 이어서 나와 둥 가 \\b와 일치하지 않으므로 일치하지 않는다.  

중요한 것은 완전한 단어 하나를 일치시키고자 한다면, 일치시키고자 하는 단어 앞뒤에 모두 \\b를 붙여야 한다는 점이다. 다음 예제를 살펴보자.  

> 예문

The captain wore this cap and cape proudly as  
he sat listening to the recap of how his  
crew saved the men from a capsized vessel.

> Regex

\\bcap

> 결과

The __cap__ tain wore this __cap__ and __cap__ e proudly as  
he sat listening to the recap of how his  
crew saved the men from a __cap__ sized vessel.

> 분석

\\bcap 패턴은 cap으로 시작하는 모든 단어와 일치한다. 따라서 단어가 총 네 새 일치했지만, 그중 세 단어는 cap이 포함된 다른 단어다.

다음은 같은 예제지만, \\b를 뒤에만 붙인 것이다.


> 예문

The captain wore this cap and cape proudly as  
he sat listening to the recap of how his  
crew saved the men from a capsized vessel.

> Regex

cap\\b

> 결과

The captain wore this __cap__ and cape proudly as  
he sat listening to the re __cap__ of how his  
crew saved the men from a capsized vessel.

> 분석

cap\\b는 cap으로 끝나는 단어와 모두 일치한다. 따라서 단어가 총 두 개 일치했지만, 그중 하나는 cap을 포함하는 다른 단어다. 만약 cap만으로 구성된 단어만 일치시키려 한다면, 패턴을 \\bcap\\b로 작성해야 한다.  

특별히 단어 결계외 일치시키고 싶지 않을 땐, \\B를 사용한다. 다음 예제에서는 \\B 메타 문자를 활용해 잘못 쓰인 빈칸으로 둘어싸인 하이픈을 찾는다.  

> 얘문

Please enter the nine-digit id ad it  
appears on your color - coded pass-key.

> 정규 표현식

\\B-\\B

> 결과

Please enter the nine-digit id ad it  
appears on your color __-__ coded pass-key.

> 분석

\\B-\\B는 단어 구분 문자로 둘어싸인 하이픈과 일치한다. 그러므로
nine-digit , pass-key는 일치하지 않지만, color - coded는 일치한다.

__문자열 경계 정의하기__

단어 경계는 단어의 위치(단어의 시작, 단어의 마지막, 단어 전체 등)를 기반으로 위치를 찾는다. 문자열 경계는 단어 경계와 기능은 비슷하지만, 전체 문자열의 시작이나 마지막 부분과 패턴을 일치시키고자 할 때 사용한다. 문자열 경계는 메타 문자 가운데 캐럿(^)으로 문자열의 시작을, 달러 기호($)로 문자열의 마지막을 나타낸다.

문자열 경계를 사용하는 방법을 다음 예제를 통해 알아보자. 올바른 XML 문서는 <\?xml>로 시작하고, 주로 부가 속성(<\?xml version="1.0"\?>)처럼 버전 번호일 수 있다)을 포함한다. 다음은 주어진 텍스트가 XML 문서인지 아닌지 간단하게 검사하는 에제다.

> 예문

<\?xml version="1.0" encoding="UTF-8" \?>
...

> Regex

<\\?xml.*\\?>

> 결과

__<\?xml version="1.0" encoding="UTF-8" \?>__
...

> 분석

제대로 동작하는 것처럼 보인다. <\\?xml 은 <\?xml 과 일치하고, \\?>는 마지막 \?>와 일치하며, .*은 텍스트가 없는 경우도 포함하여 둘 사이에 있는 모든 텍스트와 일치한다.

하지만 이 검사는 부정확하다. 다음 예제를 보자. 같은 패턴을 적용했지만, XML 파일이 시작하기 전에 관계없는 텍스트가 포함되었다.

> 예문

This is bad, real bad!
<\?xml version="1.0" encoding="UTF-8" \?>
...

> 정규 표현식

<\\?xml.*\\?>

> 결과

This is bad, real bad!
__<\?xml version="1.0" encoding="UTF-8" \?>__
...

> 분석

<\\?xml.*\\?> 패턴은 예문에서 두 번째 줄과 일치한다. 그리고 실제로 예문 두 번째 줄에 XML을 여는 태그가 있긴 하지만, 결코 유요한 예문은 아니다.(xml관련 선언문은 반드시 첫줄에 표현이 있어야 한다.) 게다가 이 예문으로 XML를 처리하려다가는 여러 문제가 발생할 수 있다.

우리는 XML을 여는 태그가 문자열 안에 있는 실제 택스트에서 첫 번째중에 위치한다는 사실을 확인해야 한다. 이 작업을 하기에는 다음에 나올 캐럿(^) 메타 문자가 제격이다.

> 예문

<\?xml version="1.0" encoding="UTF-8" \?>
...

> Regex

^\\s<\\?xml.*\\?>

> 결과

__<\?xml version="1.0" encoding="UTF-8" \?>__
...

> 분석

앞에 있는 캐럿(^) 문자는 문자열의 시작과 일치하므로, ^\\s\*는 문자열 시작이면서 바로 뒤에 공백 문자가 없거나, 하나 이상 있는 경우와 일치한다. 즉, XML 문서가 시작하기 전에 나올 수 있는 빈칸, 탭, 줄바꿈들은 처리한다. 전체
^\\s<\\?xml.*\\?> 는 어떤 속성을 지닌 XML이든 여는 태그와 일치하며, 공백도 정확하게 처리한다.

달러 기호($)도 캐럿(^) 문자와 매우 유사한 방법으로 사용한다. 다음 패턴은 웹 페이지에서 닫는 <\/html> 태그 뒤에 아무 문자도 나오지 않는지 확인하는 데 쓴다.

> 정규 표현식

</[Hh][Tt][Mm][Ll]>\\s*$

> 분석

문자 집합은 대소문자를 어떨게 조합해도 일치할 수 있도록 H,T,M,L 문자를 하나씩 찾고, \\s*$는 공백 문자와 그 뒤에 오는 문자열 마지막을 찾는다.

__다중행 모드 사용하기__

대개 캐럿(^)은 문자열의 시작과 일치하고, 달러 기호($)는 문자열의 마지막과 일치한다. 예외적으로 두 메타 문자의 동작을 바꾸는 방법이 있다.  
 많은 정규 표현식 구현은 아른 메타 문자의 동작을 변경하는 특수한 메타 문자를 지원하는데, 그중 하나 (\?m)으로, 다중행을 지원한다. 다중행 모드로 변경하면 정규 표현식 엔진이 줄바꿈 문자를 문자열 구분자로 강제로 인식한다. 캐럿(^)은 문자열의 시작이나 줄바꿈 다음(새로운 행)에 나오는 문자열의 시작과 일치하고, 달러 기호($)는 문자열의 마지막이나 줄바꿈 다음에 나오는 문자열의 마지막과 일치한다.  
 (\?m)은 항상 패턴 제일 앞에 두어야 한다. 다음은 정규 표현식을 사용하여 코드 블록 내의 모든 자바스크립트 주석을 찾는 예제다.

 > 예문

 \<script\>  
function doSpellCheck(form, field){  
  //Make sure not empty  
  if(field.value == ''){  
    return false;  
  }  
  // Init  
  ...  

  // Done  

  ...  
}  
\</script\>

> Regex

(\?m)^\\s*\\/\\/.*$

> 결과

 \<script\>  
function doSpellCheck(form, field){  
  __//Make sure not empty__  
  if(field.value == ''){  
    return false;  
  }  
  __// Init__  
  ...  

  __// Done__  

  ...  
}  
\</script\>

> 분석

^\\s*\\/\\/.*$는 문자열 시작 부분과 바로 뒤에 나오는 공백들, 그리고 다시 //)자바스크립트 주석을 정의하는 데 쓴다.), 그다음으로 모든 텍스트, 마지막으로 문자열의 끝과 일치한다. 하지만 이 패턴은 오직 첫 번째 주석과만 일치한다(그것도 해당 주석이 그 페이지에서 유일할 때만 그렇다.) (\?m)^\\s*\\/\\/.*$ 에서 (\?m) 변경자를 써 이 패턴에서 줄바꿈을 문자열 구분자로 인식하게 했더니 모든 주석이 일치했다.

_(\?m) 은 자바스크립트를 포함한 대부분의 정규 표현식 구현에서는 지원하지 않는다._

## 7장 하위 표현식 사용하기

__하위 표현식 이해하기__

5장 "반복 찾기" 에서는 단어 한나가 여러 번 일치하는 경우를 살펴보았다. 거기서 설명한 대로, \\d+_는 하나 이상 연속된 숫자와 일치하고, https?:\\/\\/는 http:// 나 https:// 와 일치한다. 이 두 예에서 (사실 모든 경우에) 물음표(?), 별표(*), {2} 같은 반복 메타 문자는 자기 바로 샆에 있는 문자나 메타 문자에 적용한다. 예를 들어 HTML 개발자는 단어 사이에 공백을 확실히 유지할 목적으로 주로 강제 공백을 단어 사이에 넣는다. 이제 이런 강제공백을 다른 것으로 대체하고자, HTML에서 반복해 나오는 강제 공백을 모두 찾아야 한다고 가정해 보자. 다음 예제를 보자.

> 예문

Hello, my name is Ben\&nbsp;Forta, I am  
the author of multiple books on SQL (including  
MySQL, Oracle PL/SQL, and SQL Server T-SQL),  
Regular\&nbsp;\&nbsp;Expressions, and other subjects.

> Regex

\&nbsp;{2,}

> 결과

Hello, my name is Ben\&nbsp;Forta, I am  
the author of multiple books on SQL (including  
MySQL, Oracle PL/SQL, and SQL Server T-SQL),  
Regular\&nbsp;\&nbsp;Expressions, and other subjects.

> 분석

\&nbsp;는 HTML 강제 공백을 나타내는 참조 항목이다. \&nbsp;{2,} 패턴은 \&nbsp;와 두개 이상 일치해야 한다. 하지만 일치하지 않았다. 왜일까> {2,}는 바로 앞에 있는 문자가 연속해서 반복된 횟수만을 표현한다. 이 경우에 앞에 놓인 문자가 세미콜론이므로, \&nbsp;;;;;는 일치할 테지만 \&nbsp;\&nbsp;는 일치하지 않는다.

__하위 표현식으로 묶기__

위의 문제를 해결하는 데 하위 표현식이 필요하다. 하위 표현식은 큰 표현식 안에 속한 일부 표현식을 한 항목으로 다루도록 한데 묶은 것이다.  
하위 표현식은 괄호 사이에 사용한다.

_괄호는 메타문자다. 실제 여는 괄호(()와 닫는 괄호())를 찾으려면 각각 \\(와 \\)로 이스케이프 해야 한다._

앞서 나온 예제를 수정해 하위 표현식을 사용하는 방법을 익혀 보자.

> 예문

Hello, my name is Ben\&nbsp\;Forta, I am  
the author of multiple books on SQL (including  
MySQL, Oracle PL/SQL, and SQL Server T-SQL),  
Regular\&nbsp\;\&nbsp\;Expressions, and other subjects.

> Regex

(\&nbsp;){2,}

> 결과

Hello, my name is Ben\&nbsp\;Forta, I am  
the author of multiple books on SQL (including  
MySQL, Oracle PL/SQL, and SQL Server T-SQL),  
Regular __\&nbsp\;\&nbsp\;__ Expressions, and other subjects.

> 분석

(\&nbsp;)는 하위 표현식이며 한 항목으로 취급한다. 따라서 {2,}는 세미콜론이 아니라 이 하위 표현식 전체가 반복하는 횟수를 나타낸다.

다른 예제를 살펴보자. 이번에는 정규 표현식으로 IP 주소를 찾는다. IP주소는 숫자 네 묶음을 마침표로 구분해 이루어지며 12.123.23.200 같은 형식이다. 각 묶음에는 숫자가 한 자리 숫자부터 세 자리 숫자까지 들어갈 수 있으므로 이 숫자 묶음과 일치시키려면 패턴을 \\d{1,3}으로 표현한다.

> 예문

Pinging hog.forta.com [12.159.26.200]  
with 32 bytes of data:

> Regex  

\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}

> 결과

Pinging hog.forta.com [__12.159.26.200__]  
with 32 bytes of data:

> 분석

각 \\d{1,3}은 IP 주소 숫자들 가운데 한 묶음과 일치한다. 숫자 네 묶음은 마침표(.)로 구분하므로 \\.로 이스케이프 했다.

최대 세 자리 정수 뒤에 마침표가 오는 \\d{1,3}\\. 패턴 자체도 세 번 반복되므로 반복표현으로 사용할 수 있다.

> 예문

Pinging hog.forta.com [12.159.26.200]  
with 32 bytes of data:

> Regex  

(\\d{1,3}\\.){3}\\d{1,3}

> 결과

Pinging hog.forta.com [__12.159.26.200__]  
with 32 bytes of data:

> 분석

이 패턴도 앞서 본 예제와 마찬가지로 잘 동작하지만, 문법은 다르다. \\d{1,3}\\.을 하위 표현식으로 만들고자 괄호로 감쌌다. (\\d{1,3}\\.){3}은 이 하위 표현식을 세 번 반복하고(IP 주소의 앞에서부터 세 묶음과 일치), \\d{1,3}은 마지막 숫자 묶음과 일치한다.

하위 표현식으로 묶는 방식은 굉장히 중요하다. 그래서 한 가지 예제를 더 추가했다. 이 예제에서는 하위 표현식의 반복을 사용하지 않았다. 이 예제에서는 사용자 기록에서 연도를 일치시키려 한다.

> 예문

ID : 042  
SEX : M  
DOB : 1957-08-17  
Status : Active  

> Regex

19\|20\\d{2}

> 결과

ID : 042  
SEX : M  
DOB : __19__ 57-08-17  
Status : Active  

> 분석

이 예제에서는 패턴을 써 네 자리 숫자로 이루어진 연도를 일치시켜야 했다. 더 정확한 결과를 얻고자 앞 두 자리 숫자는 명확아세 19와 20으로 정했다. \|는 OR 연산자를 의미한다. 그러므로 19\|20은 19 혹은 20과 일치하고, 따라서 19\|20\\d{2}는 19나 20으로 시작하는 네 자리 숫자와 일치해야 한다. 그런데 분명 의도한 대로 일치 하지 않았다. 왜일까? OR(\|) 연산자는 자신의 왼편과 오픈현에 각각 무엇이 있는지 살펴보는데, 19\|20\\d{2}를 19 혹은 20\\d{2}, 즉 \\d{2} 역시 20으로 시작하는 표현 일부로 여겼기 때문이다. 그래서 19와 일치하든지 20으로 시작하는 네 자리 연도와 일치할 텐데, 여기서는 19와 일치했다.

해결법은 19\|20을 하위표현식으로 묶는 것이다.

> 예문

ID : 042  
SEX : M  
DOB : 1957-08-17  
Status : Active  

> Regex

(19\|20)\\d{2}

> 결과

ID : 042  
SEX : M  
DOB : __1957__ -08-17  
Status : Active  

> 분석

선택 사항이 모두 하위 표현식 안에 있으므로 OR(\|) 연산자는 우리가 묶음 안에 있는 숫자 가운데 하나를 일치시키려 한다는 사실을 안다. 그래서 (19\|20)\\d{2}는 정확하게 1957과 일치하고, 19 혹은 20 으로 시작하는 다른 네 자리 숫자와도 일치할것이다. 지금으로부터 대략 백 년쯤 시간이 흐른 후에는, 21로 시작하는 연도와도 일치하도록 약간 수정할 필요가 있을 텐데, 이때는 패턴을 (19\|20\|21)\\d{2}로 바꾸면 된다.

__중첩된 하위 표현식__

하위 표현식을 중첩해(nest) 쓰기도 한다. 사실 하위 표현식은 다른 하위 표현식을 중첩하고 그 하위 표현식은 또 다른 하위 표현식을 중첩하기도 한다.  
어떤 모습인지 알겠는가? 중첩되는 능력 적분에 하위 표현식을 매우 강력한 표현도 만들 수 있다. 하지만 반대로 표현식을 뒤엉키게 해 읽거나 분석하기 어렵고, 그 복잡한 모습에 겂을 먹게 만들기도 한다. 하지만 사실 복잡해 보이도록 중첩된 하위 표현식은 거의 사용되지 않는다.  
중첩된 하위 표현식을 어떻게 사용하는지 알아보고자 IP 주소 예제를 다시 살펴볼 것이다. 다음은 앞서 사용했던 패턴인데, 하위 표현식이 세번 반복된 다음 마지막 숫자가 나타난다.

> Regex

(\\d{1.3\\.}){3}\\d{1,3}

> 분석

이 패턴은 뭐가 잘못되었을까? 문법은 잘못되지 않았다. IP 주소는 실제로 숫자 네 묶음으로 구성되었고, 각 묶음은 한 자리에서 세 자리 숫자이며 마침표로 구분한다. 형식도 맞고, 올바른 IP 주소도 찾아낸다는 점이 문제다.  
IP 주소는 4바이트로 구성되고, 12.123.46.200 으로 나타나는 IP 수조는 바로 이 4바이트를 표현한 것이다. 따라서 IP 주소에서 숫자 네 묶음은 각각 한 바이트 값을 나타내고, 이 값의 범위는 0부터 255 사이에 속한다. 이는 IP 주소에 255보다 큰 숫자는 들어갈 수 없음을 의미한다. 하지만 앞서 본 패턴을 사용하면 356, 700, 999 같이 IP 숫자로 바르지 않은 숫자와도 일치한다.  
유효한 값의 범위를 지정할 수 있으면 매우 좋겠지만, 정규 표현식은 문자를 일치시킬 뿐이지 문자가 의미하는 바에 대해서는 아무런 지식이 없다. 또 수학적 연산을 사용할 수도 없다. 우리가 할 수 있는 일이 있을까? 아마 있을 것이다. 정규 표현식을 만들려면 일치해야 할 것과 일치해서는 안 되는 것을 명확하게 정의해야 한다. 다음은 IP 주소를 구성하는 각 숫자 묶음을 유효한 조합으로 정의하는 규칙히다.

- 모든 한 자리 혹은 두 자리 숫자
- 1로 시작하는 모든 세 자리 숫자
- 2로 시작하면서 두 번째 자리 숫자가 0부터 4 사이인 모든 세 자리 숫자
- 25로 시작하면서 세 번째자리 숫자가 0부터 5 사이인 모든 세 자리 숫자

위와 같이 순서대로 표현하면 실재로 패턴이 명확하게 작동한다. 다음 예제를 살펴보자.

> 예문

Pinging hog.forta.com [12.159.26.200]  
with 32 bytes of data:

> Regex  

(((25[0-5])\|(2[0-4]\\d)\|(1\\d{2})\|(\\d{1,2}))\\.){3}(((25[0-5])\|(2[0-4]\\d)\|(1\\d{2})\|(\d{1,2})))

> 결과

Pinging hog.forta.com [__12.159.26.200__]  
with 32 bytes of data:

> 분석

이 패턴은 제대로 동작하지만, 설명이 약간 필요하다. 이 패턴이 제대로 동작하는 이유는 하위 표현식이 연속해서 중첩되었기 때문이다. 하위 표현식 네 개가 중첩된 (((25[0-5]\|(2[0-4]\\d)\|(1\\d{2})\|(\\d{1,2}))\\.)로 시작한다.  
(\\d{1,2})는 한 자리 혹은 두 자리 숫자, 즉 0부터 99 사이의 숫자와 일치한다. (1\\d{2})는 1로 시작하는 모든 세 자리 숫자(1 뒤에는 두 자리 숫자가 온다), 즉 100부터 199 사이의 숫자와 일치한다. (2[0-4]\\d)는 200 부터 249 사이의 숫자와 일치한다. (25[0-5])는 250부터 255 사이의 숫자와 일치한다. 여기에 나온 하위 표현식은 더 큰 하위 표현식으로 묶이고 이렇게 묶인 하위 표현식 사이에는 OR(\|) 연산자가 위치한다. OR(\|)연산자를 통해 전부가 아니라 네 가지 하위 표현식 가운데 하나와만 일치한다. 숫자의 범위가 나온 다음에는 \\/가 마침표(.)와 일치하고 이렇게 설정된 모든 숫자 범위와 \\. 를 또 다른 하위 표현식으로 묶어 {3}으로 세 번 반복한다. 마지막으로 IP 주소의 마지막 숫자와 일치하는 숫자 범위를 반복한다(이번에는 마지막에 \\.가 없다). 데 묶음의 범위를 각각 0에서 255 사이로 제한하여 이 패턴은 실제로 올바른 IP 주소와는 일치하고 바르지 않은 주소는 거부한다.

앞에서 설명한 것처럼, 네 가지 표현식에 대해 논리적인 순서는 의미가 없다. 다음을 확인해 보자

> 예문

Pinging hog.forta.com [12.159.26.200]  
with 32 bytes of data:

> Regex  

(((\\d{1,2})\|(1\\d{2})\|(2[0-4]\\d)\|(25[0-5]))\\.){3}((\\d{1,2})\|(1\\d{2})\|(2[0-4]\\d)\|(25[0-5]))

> 결과

Pinging hog.forta.com [__12.159.26.20__ 0]  
with 32 bytes of data:

> 분석

이번에는 마지막 0이 일치하지 않았다. 왜 그럴까? 패턴이 왼쪽에서 오른쪽으로 평가 되므로, 일치하는 식이 네 개 있다면, 첫 번째 식을 시도하고, 두 번째 식을 시도하는 식으로 일치한다. 만약 패턴이 일치하면 다른 선택 사항은 시도되지 않는다. 이 예제에서 (\\d{1,2})는 마지막 200의 20에 일치해서, 다른 옵션(여기에 필요한 마지막(25[0-5]) 패턴을 포함해서)은 평가되지 않았다.

## 8장 역참조 사용하기

__역참조 이해하기__

역참조가 언제 필요한지 이해하는 가장 좋은 방법은 예제를 보는 것이다. HTML 개발자는 웹 페이지에서 해더 텍스트를 정의하고 만들고자, 해더 테그를 사용한다. 해더 태그는 \<h1\>부터 \<h6\>까지 있으며, 이에 대응하는 종료 태그를 함께 사용한다. 단계에 상관없이 헤더를 모두 찾아야 한다고 생각해 보자. 다음 예제를 보자.

> 예문

\<body\>  
  \<h1\>Welcome to my Homepage\</h1\>  
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
\</body\>  

> 정규 표현식

<[hH]1>.*<\\/[hH]1>

> 결과

\<body\>  
  __\<h1\>Welcome to my Homepage\</h1\>__  
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
\</body\>  

> 분석

<[hH]1>.*<\\/[hH]1> 패턴은 첫 번째 헤더(\<h1\>부터 \</h1\>까지)와 일치하고, HTML은 대소문자를 가리지 않으므로 \>h1\>과도 일치할 것이다. 하지만 여섯 개 수준의 헤더를 모두 썼을지도 모르는데, 여기 쓰인 헤더를 모두 찾으려면 어떤 패턴을 써야 할까?

> 예문

\<body\>  
  \<h1\>Welcome to my Homepage\</h1\>  
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
\</body\>  

> 정규 표현식

<[hH][1-6]>.*?<\\/[hH][1-6]>

> 결과

\<body\>  
  __\<h1\>Welcome to my Homepage\</h1\>__  
  __\<h2\>SQL\</h2\>__  
  Information about SQL.  
  __\<h2>Regex\</h2\>__  
  Information about Regular Expressions.  
\</body\>  

> 분석

<[hH][1-6]>은 모든 헤더의 시작 태그(예제에서는 \<h1\>과 \<h2\>)와 일치하고, <\\/[hH][1-6]>은 모든 헤더의 종료 태그와 일치하여 제대로 동작하는 것처럼 보인다.

여기서 탐욕적 수량자가 아니라 게으른 수량자를 사용했음에 유의하자.

성공했을까? 아니다. 다음 예제를 살펴보자

> 예문

\<body\>  
  \<h1\>Welcome to my Homepage\</h1\>  
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
  \<h2>This is not valid HTML</h3\>  
\</body\>  

> 정규 표현식

<[hH][1-6]>.*?<\\/[hH][1-6]>

> 결과

\<body\>  
  __\<h1\>Welcome to my Homepage\</h1\>__  
  __\<h2\>SQL\</h2\>__  
  Information about SQL.  
  __\<h2>Regex\</h2\>__  
  Information about Regular Expressions.  
  __\<h2>This is not valid HTML</h3\>__  
\</body\>  

> 분석

해더 태그가 \<h2\> 로 시작해 \<h3\>으로 끝나 올바른 형식이 아니지만, 패턴과 일치한다.

문제는 두 번째 태그(종료 태그)가 일치할 때 첫 번째 태그(시작 태그)가 어떤 텍스트인지 알 수 있는 정보가 없다는 점이다. 이런 경우에 역참조가 매우 유용해 진다.

__역참조로 찾기__

해더 문제는 잠시 후에 다시 다루기로 하다. 지금은 더 간단하지만, 역참조를 사용하지 않고는 절대 풀 수 없는 예제를 살펴볼 것이다.  
한 문장이 있고, 이 문장 안에 반복해 나오는 문자, 바로 실수로 같은 단어를 두 번 입력한 오자를 모두 찾고 싶다고 가정해 보자. 두 단어가 일치하는지 알려면 먼저 나온 단어가 무엇인지 반드시 알고 있어야 한다. 역참조는 정규 표현식 패턴으로, 앞서 일치한 부분을 다시 가리킨다(이 경우에는 먼저 일치한 단어를 말한다.)  
가장 좋은 방법은 직접 사용해 보면서 이해하는 것이다. 다음 예제에는 반복해 나오는 단어가 세 가지 있고, 이 세 단어를 모두 찾아야 한다.

> 예문

This is a block of of text,  
serveral words here are are  
repreted, and and they  
should no be.

> Regex

[ ]+(\\w+)[ ]+\\1

> 결과

This is a block __of of__ text,  
serveral words here __are are__  
repreted, __and and__ they  
should no be.

> 분석

패턴이 재대로 동작하는 것 같다. 하지만 어떻게 동작하는 것인까? [ ]+는 공백이 하나 이상 연속되는 경우 일치하고, \\w= 영숫자 문자가 하나 이상 연속되는 경우 일치하며, [ ]+는 그 뒤에 공백이 있을 때 일치한다. 여기서 \\w+를 괄호로 감싸 하위 표현식으로 만들었음에 주목하자. 반복해 일치시키려고 하위 표현식을 사용한 것이 아니다. 반복해서 일치하는 부분도 없다. 여기서는 나중에 일치한 부분을 사용할 수 있도록 표시하여 구별하고자 하위 표현식을 사용했다. 이 패턴에서 마지막 부분인 \\1은 앞서 일치한 하위 표현식을 참조함을 의미하고, 따라서 (\\w+)와 일치한 문자는 \\1과도 일치한다.

\\1은 정확히 무엇을 뜻할까? \=\1은 패턴에서 처음 사용한 하위 표현식과 일치한다는 뜻이다. \\2는 두 번째, 그리고 \\3은 세 번째 사용한 하위 표현식과 일치하는 식이다. 따라서
[ ]+(\\w+)[ ]+\\1 은 앞서 나온 예제에서 보듯이 어떤 단어가 일치하고, 그다음에는 같은 단어가 반복해 나와야만 일치한다.

이제 역참조를 어ㅏ떻게 사용하난지 살펴보았으니, HTML 헤더 예제를 다시 보자. 역참조를 사용해서 짝이 맞지 않는 헤드 태그는 무시하고 시작 태그와 일치하는 종료 태그를 일치하는 패턴을 만들 수 있다.

> 예문

\<body\>  
  \<h1\>Welcome to my Homepage\</h1\>  
  Content is divided into two sections:\<br\>
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
  \<h2>This is not valid HTML</h3\>  
\</body\>  

> Regex

\<\[hH\](\[1-6\])\>.\*?<\\/[hH]\\1>

> 결과

\<body\>  
  __\<h1\>Welcome to my Homepage\</h1\>__  
  Content is divided into two sections:\<br\>
  __\<h2\>SQL\</h2\>__  
  Information about SQL.  
  __\<h2>Regex\</h2\>__  
  Information about Regular Expressions.  
  \<h2>This is not valid HTML</h3\>  
\</body\>  

> 분석

다시 일치하는 부분을 세 개 찾았다. 바로 \<h1\> 한 쌍과 \<h2\> 두 쌍이다.  
\<\[hH\](\[1-6\])\>이 모든 헤더 시작 태그와 일치한다는 점은 같고, 대신 \[1-6\]을 하위 표현식으로 만들었다. 이렇게 하면 헤더의 종료 태그 패턴인 <\\/[hH]\\1> 안에서 \\1로 하위 표현식을 참조할 수 있다. (\[1-6\])은 하위 표현식이며, 숫자 1부터 6까지 일치한다. \\1은 오직 하위 표현식에서 일치한 숫자와 일치하므로 \<h2>This is not valid HTML</h3\>는 일치하지 않는다.

_역참조는 참조하는 표현싱이 하위 표현식일 때(그리고 하위 표현식을 괄호로 감쌌을 때)만 동작할 것이다._

_일치하는 부분을 참조하는 숫자는 주로 1로 시작한다. 많은 구현에서 0번째 참조라고 하면 표현식 전체를 가리킨다._

__치환 작업 수행하기__

정규식 표현식은 검색만 할 수 있는 것이 아니다. 정규 펴현식으러 강력한 치환 작업도 수행할 수 있다.  
단순한 텍스트를 치환하는 데 정규 표현식은 필요 없다. 예를 등러 CA라는 요소를 모두 California로 치환하거나, MI를 Michigan으로 치환하는 일은 단영코 정규 펴현식을 쓸 정도로 대단한 일이 아니다. 물론 그런 간단한 정규 표현식 작업이 가능하긴 하지만, 겅규 표현식을 사용할 가치가 없는 데다가, 사실 우리가 사용할 수 있는 일반적인 문자열 처리 기능 가운데 아무거나 사용하는 편이 더 간단하다.  
정규 표현식을 써 치환하는 작업은 역참조와 함께 사용했을 때 진가를 발휘한다.

> 예문

Hello ben@forta.com is my email address.

> Regex

\\w+\[\\w\\.\]\*@\[\\w\\.\]+\\.\\w+

> 결과

Hello __ben@forta.com__ is my email address.

> 분석

이 패턴은 텍스트 구역 안에서 이메일 주소를 분별해 낸다.(5장)

하지만 만약 텍스트에 포함된 이메일 주소에 링크를 걸고 싶다면 어떻게 해야 할까?  
HTML에서는  `<a href="mailto:user@address.com">user@address.com</a>`를 써 클릭할 수 있는 이메일 주소를 만든다. 정규 표현식으로 이와 같은 이메일 주소를 클릭 가능한 주소 형식으로 바꿀 수 있을까? 물론 가능하다. 그것도 매우 간단하게 바꿀 수 있다. 역참조만 사용한다면 말이다.

> 예문

Hello ben@forta.com is my email address.

> Regex

(\\w+\[\\w\\.\]\*@\[\\w\\.\]+\\.\\w+)

> 치환

`<a href="mailto:$1">$1</a>`

> 결과

Hello __\<a href="mailto:ben@forta.com">ben@forta.com\<\/a\>__ is my email address.

> 분석

치환 작업을 할 때는 정규 표현식이 두 개 필요하다. 하나는 원하는 부분을 일치시키는 패턴이고 다른 하나는 일치한 부분을 치환하는 데 사용할 패턴이다. 역참조는 서로 가은 패턴에서도 사용할 수 있르므로, 첫 패턴에서 일치한 하위 표현식을 두 번째 패턴에서도 썼다. (\\w+\[\\w\\.\]\*@\[\\w\\.\]+\\.\\w+)은 앞서 본 예제와 같은 패턴인데, 이번에는 이메일 주소를 찾아내여, 하위 표현식으로 만들었다. 이렇게 하면 일치한 텍스트를 치환패텅에 사용할 수 있다.  
`<a href="mailto:$1">$1</a>`에서 일치하는 하위 표현식을 두 번 사용하는데, 한 번은 href 속성 값인 mailto:를 정의할 때, 다른 한 번은 클릭할 수 있는 텍스트에 넣을 때 사용했다. 따라서 ben@forta.com이 \<a href="mailto:ben@forta.com">ben@forta.com\<\/a\>가 되어 원하던 결과가 나왔다

예제를 하나 더 살펴보자 사용자 정보를 저장하는 데이터베이스에 전화번호가 313-555-1234 형식으로 저장되어 있다. 하지만 이 정화번호를 (313) 555-1323 같은 형식으로 변환해야 한다.

> 예문

333-555-1234  
248-555-9999  
810-555-9000

> Regex

(\\d{3})(-)(\\d{3})(-)(\\d{4})

> 치환

($1) $3-$5

> 결과

(333) 555-1234  
(248) 555-9999  
(810) 555-9000

> 분석

여기서 다시 정규 표현식을 두 개 사용했다. 첫 번째 표현식이 훨씬 복잡해 보이니 한번 찬찬히 분해해 보자. (\\d{3})(-)(\\d{3})(-)(\\d{4})는 전화번호화 일치하는데, 각 부분을 독립적으로 만들고자 전화번호를 다섯 부분으로 쪼갰다. (\\d{3})은 첫 번 하위 표현식으로 처음 세 자리 숫자와 일치하고, (-)는 두 번째 하위 표현식으로 -와 일치하는 식이다. 결론은 전화번호를 다섯 부분으로 나눴고, 각 부분은 하윈 표현식이라는 것인데, 이 하위 표현식들은 지역번호, 하이픈, 처음 세 자리 숫자, 다시 하이픈, 마지막 네 자리 숫자를 가리킨다. 다섯 부분은 필요에 따라 개별적으로 사용할 수 있으므로 ($1) $3-$5는 하위 표현식을 세 개만 쓰고 두 개는 무시해 간단하게 숫자 형식을 바꾼다. 결과적으로 333-555-1234는 (333) 555-1234가 되었다.

__대소문자 변환하기__

몇몇 정규 표현식 구현에서는 아래 표에 나열된 메타 문자를 써서 텍스트를 변환하도록 지원한다.

|메타문자|설명|
|:--|:--|
|\\E|\\L 혹은 \\U 변환의 끝을 나타낸다|
|\\l| 다음에 오는 글자를 소문자로 변환한다|
|\\L|\\E를 만날 때까지 모든 문자를 소문자로 변환한다|
|\\u\\다음에 오는 글자를 대문자로 변환한다|
|\\U|\\E를 만날 때까지 모든 문자를 대문자로 변환한다|

\\l과 \\u는 바꾸고 싶은 글자 앞에 두어 각각 그 글자를 소문자와 대문자로 바꾼다. \\L과 \\u는 \\E를 만날 때까지 모든 문자를 각각 소문자와 대문자로 변환한다.  
다음은 \<h1\>태그로 감싸인 텍스트를 대문자로 변환한다.

> 예문

\<body\>  
  \<h1\>Welcome to my Homepage\</h1\>  
  Content is divided into two sections:\<br\>
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
  \<h2>This is not valid HTML</h3\>  
\</body\>  

> Regex

(\<[Hh]1\>)(\.\*?)(\<\\/\[Hh\]1\>)

> 치환

$1\\U$2\\E$3

> 결과

\<body\>  
  \<h1\>WELCOME TO MY HOMEPAGE\</h1\>  
  Content is divided into two sections:\<br\>
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
  \<h2>This is not valid HTML</h3\>  
\</body\>  

> 분석

(\<[Hh]1\>)(\.\*?)(\<\\/\[Hh\]1\>) 패턴은 헤더를 세 부분, 즉 시작 채그, 텍스트, 종료 태그로 나눈다. 두 번째 패턴은 이 텍스트들을 다시 합치는데, $1은 시작 태그와 일치하고,
\\U$2\\E는 헤더 텍스트인 두 번째 하위 표현식과 일치한 다음 이 텍스트를 대문자로 변환하며, $3은 종료 태그와 일치한다.

## 9장 전방탐색과 후방탐색

__전후방탐색 살펴보기__

웹 페이지에서 제목을 추출해야 한다고 가정하자. HTML 페이지 제목은 HTML 코드에서 \<head\> 구역 내의 \<title\>과 \</title\> 태그 사시에 있다.

> 예문

\<head\>  
  \<title\>Ben Forta's Homapage\</title\>  
\</head\>  

> Regex

\<[Tt][Ii][Tt][Ll][Ee]\>.\*\</[Tt][Ii][Tt][Ll][Ee]\>

> 결과

\<head\>  
  __\<title\>Ben Forta's Homapage\</title\>__  
\</head\>

> 분석

\<[Tt][Ii][Tt][Ll][Ee]\>.\*\</[Tt][Ii][Tt][Ll][Ee]\>
는 시작 태그 \<title\>, 종료 태그 \</title\>, 또 그 사이에 있는 텍스트는 어느 것이나 일치하며, 태그는 대소문자를 구별하지 않고, 둘 다 섞여 있어도 상관없다.
그러나 필요한 건 제목 텟그트뿐이었지만, 실제로는 시작 태그 \<title\>와 종료 태그\</title\>도 들어 있었다. 제목 텍스트만 얻을 수는 없을까?  
한 방법으로 하위 표현식(7장 참조)을 쓸 수도 있다. 이 방법을 써서 우리는 패턴을 시작 태그, 텍스트, 종료 채그, 이렇게 세 부분으로 나누어 결롸를 얻을 수 있다. 이렇게 여러 조작으로 나누어 원하는 부분을 얻기는 어렵지 않다.  
하지만 이 방법을 사용하면, 원하지 않는 결과까지 얻게 되고, 이 부분은 수동으로 없애야 한다는 점이 설린다. 반화하지 않는 일치를 포함하는 패턴을 구성하는 것, 즉 저확한 일치 지점을 찾는 데는 사용되지만 진짜 일치의 일부로는 사용되지 않는 어떤 것이 필요하다. 다시 말해 __전후방탐색(Lookaround)__ 이 필요하다

__전방탐색(앞으로 찾기)__

전방탐색(Lookahead) 패턴은 일치 영역을 발견해도 그 값을 반환하지 않는 패턴을 말한다. 전방탐색은 실제로는 하위 표현식이며, 하위 표현식과 같은 형식으로 작성한다. 전방탐색 패턴의 구문은 ?=로 시작하고 등호(=) 다음에 일치할 텍스트가 오는 하위 표현식이다.

_일부 정규 표현식 문서에서는 일치하는 영역을 반환하는 동작을 표현할 때 '소비한다(consume)'라는 용어를 쓴다. 이럴 경우 전방탐색은 '소비하지않는다.(no consume)'라고 한다_

다음 예제를 보자. 본문에는 URL 목록이 있고, 우리는 각 URL에서 프로토콜의 위치를 추출해야 한다

> 예문

http://www.forta.com/  
https://mail.forta.com/  
ftp://ftp.forta.com/

> Regex

.+(?=:)

> 결과

__http__ ://www.forta.com/  
__https__://mail.forta.com/  
__ftp__://ftp.forta.com/

> 분석

여기에 나열한 URL들에서 프로토콜은 콜론(:)을 기준으로 호스트 이름과 분리되어 있다. .+ 패턴은 모든 텍스트(첫 번째로 일치하는 텍스트는 http다)와 일치하고, 하위 표현식 (?=:)는 콜론(:)과 일치한다. 그런데 여기서 콜론(:)은 일치하지 않는 것으로 나타남을 눈여겨 봐야 한다. ?=는 정규 표현식 엔진에게 콜론(:)을 찾되 콜론(:) 앞에 있는 문자를 탐색하라고(그리고 콜론(:을 소비하지는 말라고) 지시한다.

?=가 어떻게 동작하는지 더 잘 이해하고 같은 예제에서 전방탐색 메타 문자를 뺐다.

> 예문

http://www.forta.com/  
https://mail.forta.com/  
ftp://ftp.forta.com/

> Regex

.+(:)

> 결과

__http:__//www.forta.com/  
__https:__//mail.forta.com/  
__ftp:__//ftp.forta.com/

> 분석

하위 표현식 (:)은 정확하게 콜론(:)과 일치했지만, 일치한 텍스트를 소비했다.

두 예제에서 처음 패턴은 콜론(:)을 찾고자 (?=:)를 썼고ㅡ, 다음 패턴은 (:)을 썼다는 차이가 있다. 두 패턴 모두 프로토콜 다음에 나오는 콜론을 찾지만, 일치한 콜론(:)을 검색 결과에 포함시키는지 아닌지가 다르다. 전방탐색을 사용하면 정규 표현식 분석기는 콜론(:)고 일치하는 지점 앞쪽에서 분석을 진행하지만 콜론(:)까지 포함해 텍스트를 찾는다. .+(?=:)도 콜론(:)까지 찾긴 하지만, 콜론(:)을 결과에 포함하지 않는다.

_전방탐색(후방탐색) 일치는 실제로 결과를 반환하지만, 반환된 문자의 길이가 항상 0이다. 따라서 전방탐색을 흔히 '제로폭(zeor-width)'이라 부르기도 한다_

__후방탐색(뒤로찾기)__

앞서 본 것처럼 ?=는 앞으로 탐색한다. 일치하는 텍스트 다음에 무엇이 오는지 찾고, 발견한 텍스트 자체는 소비하지(consume) 않는다. 따라서 ?=는 __전방탐색__ 연산자라고 부른다. 많은 정규 표현식 구현에서 전방탐색과 더불어 후방탐색(lookbehind)기능도 지원한다. 텍스트를 반환하기 전에 탐색하는 작업은 뒤쪽을 탐색하기도 포함한다. __후방탐색__ 연산자는 ?<=이다

?<=는 ?=와 사용방법이 같다,. 즉, 하위 표현식 안에서 사용하고, 일치할 텍스트 앞에 온다. 다음 예제는 데이터베이스의 제품 목록에서 가격만 필요할 경우다.

> 예문
ABC01: $23.45  
HGG42: $5.45  
CFX01: $889.45  
GMD05: $69.95  
Total items found : 4

> Regex

\\$[0-9.]+

> 결과

ABC01: __$23.45__  
HGG42: __$5.45__  
CFX01: __$889.45__  
GMD05: __$69.95__  
Total items found : 4

> 분석

\\$는 달러 기호($)와 일치하고, [0-9.]+는 가격과 일치한다.

잘 작동한다. 하지만 달러 기호($)가 필요 없다면 어떻게 해야 했을까?  
이럴때 후방 탐색을 이용한다.

> 예문
ABC01: $23.45  
HGG42: $5.45  
CFX01: $889.45  
GMD05: $69.95  
Total items found : 4

> Regex

(?<=\\$)[0-9.]+

> 결과

ABC01: $__23.45__  
HGG42: $__5.45__  
CFX01: $__889.45__  
GMD05: $__69.95__  
Total items found : 4

> 분석

(?<=$)는 달러 기호($)와 일치하지만 소비하지는 않고, 단지 앞에 달러 기호($)가 없는 가격만 반환한다.

예제에서 첫 번째와 마지막 표현식을 비교해 보자. \\$[0-9.]+는 달러 기호($)와 이어 나오는 금액이 함께 일치한다. (?<=\\$)[0-9.]+ 역시 달러 기호($)와 금액이 함께 일치한다. 검색을 수행하는 동안 어디에 위치하는가가 다른 게 아니라 결과 속에 무엇을 포함하는지가 다르다. 첫 번째 표현식은 달러 기호($)를 찾아서 결과에 포함시키지만, 마지막 표현식은 달러 기호($)를 찾아서 결과에 포함시키지만, 마지막 표현식은 달러 기호($)를 찾아 정확하게 금액을 얻고, 결과에는 달러 기호($)를 포함시키지 않는다.

_전방탐색 패턴은 마침표(.)와 더라기를 포함하여 텍스트의 길이를 다양하게 일치시킬 수 있으며, 매우 동적이다. 반대로 후방탐색 패턴은 보통 이치시킬 텍스트의 길이를 고정해야 한다. 거의 모든 정규 표현식 구현에는 이런 제약이 있다_


__전방탐색와 후방탐색 함께 사용하기__

전방탐색과 후방탐색 명령을 함께 사용할 수 있다.

> 예문

\<head\>  
  \<title\>Ben Forta's Homapage\</title\>  
\</head\>  

> Regex

(?<=\\<[Tt][Ii][Tt][Ll][Ee]\>).\*(?=\\</[Tt][Ii][Tt][Ll][Ee]\>)

> 결과

\<head\>  
  \<title\>__Ben Forta's Homapage__\</title\>  
\</head\>

> 분석

?<=\<[Tt][Ii][Tt][Ll][Ee]\>)는 후방탐색 작업으로 \<title\>과 일치하며, 소비하지는 않는다.  (?=\</[Tt][Ii][Tt][Ll][Ee]\>)도 같은 방식으로 \</title\>과 일치하며, 역시 소비하지는 않는다, 오직 제목 텍스트만 반환한다.

_혼란을 방지하고자 <문자를 이스케이프 하는것도 좋은 방법이다 ( ?<=< 대신 ?<=\\< 사용)_

__부정형 전후방탐색__

지금까지 살펴본 전,후방탐색은 __긍정형 전,후방탐색__ 이라고 한다. __긍정(positive)__ 이라고 하는 이유는 실제로 일치하는 텍스트를 찾기 때문이다.  
전후방탐색 중 __부정형(negative)__ 전후방탐색은 비교적 덜 쓰는 방법이다. 부정형 전방탐색은 앞쪽에서 지정한 패턴과 일치하지 않는 텍스트를 찾고, 부정형 후방탐색도 이와 비슷하게, 뒤쪽에서 지정한 패턴과 일치하지 않는 텍스트를 찾는다.  
혹시라고 제외를 나타내는 데 캐럿(^)을 사용하리라 기대했다면 틀렸다. 문법이 약간 다르다. 전후방탐색 명령에서 부정형을 나타낼 때는 등호(=) 대신 느낌표(!)를 사용한다.

|종류|설명|
|:--|:--|
|(?=)|긍정형 전방탐색|
|(?!)|부정형 전방탐색|
|(?<=)|긍정형 후방탐색|
|(?<!)|부정형 후방탐색|

다음은 긍정형 후방탐색과 부정형 후방탐색 사이ㅏ에는 어떤 차이가 있는지 알아보는 예제다. 예제 본문에는 가격과 수량을 나타내는 숫자들이 있다. 우선 간단하게 가격만 얻을 것이다.

> 예문

I paid $30 for 100 apples,  
50 oranges, and 60 pears.  
I saved $5 on this order.

> Regex

(?<=\\$)\\d+

> 결과

I paid __$30__ for 100 apples,  
50 oranges, and 60 pears.  
I saved __$5__ on this order.

> 분석

앞서 본 예제와 매우 비슷하다, \\d+는 하아 이상 연속된 숫자와 일치하고, (?<=\\$)는 후방탐색이며, \\$로 이스케이프 한 달러 기호($)를 찾는다. 하지만 소비하지는 않는다. 따라서 수량을 제외한 가격 두개가 일치했다.

이번엔 반대로 수량을 찾아보자.

> 예문

I paid $30 for 100 apples,  
50 oranges, and 60 pears.  
I saved $5 on this order.

> Regex

\\b(?<!\\$)\\d+\\b

> 결과

I paid $30 for __100__ apples,  
__50__ oranges, and __60__ pears.  
I saved $5 on this order.

> 분석

첫 번째 예와 같이, \\d+는 숫자와 일치하지만, 이번에는 가격이 아닌 수량만 일치했다. 표현식 (?<!\\$)는 부정형 후방 탐색으로, 앞에 달러 기호($)가 없는 숫자만 일치한다. 등호(=)를 느낌표(!)로 바꾸어 부정형 후방탐색 패턴을 긍정에서 부정으로 바꿨다.

여러분 가운데 부정형 후방탐색 예제에서 \\b르 써 왜 단어 경계를 지정 했는지 궁금한 사람이 있을지 모르겠다. 같은 예제에서 경계를 빼고 그 이유를 알아보자


> 예문

I paid $30 for 100 apples,  
50 oranges, and 60 pears.  
I saved $5 on this order.

> Regex

(?<!\\$)\\d+

> 결과

I paid $3 __0__ for __100__ apples,  
__50__ oranges, and __60__ pears.  
I saved $5 on this order.

> 분석

단어 경계가 없으면, $30에 있는 0도 일치한다. 왜 그럴까? 숫자 0 앞에 달러 기호($)가 없기 때문이다. 전체 패턴을 단어 경계로 감싸 이 문제를 해결 했다.

## 10장 조건 달기

정규 표현식은 표현식 내에 조건 처리를 포함시킬 수 있다.

__왜 조건을 다는가?__

(123)123-1234와 123-123-1234는 모두 올바른 미국 전화번호 형식이다.
1231231234,(123)-123-1234,(123-123-1234는 숫자의 수는 맞지만, 형식이 바르지 않다. 정규 표현식을 어떻게 작성해야 올바른 형식만 찾을 수 있을까? 간단한 문제는 아니다.

> 예문

123-456-7890  
(123)456-7890  
(123)-456-7890  
(123-456-7890  
12345657890  
123 456 7890  

> Regex

\\(?\\d{3})?-?\\d{3}-\\d{4}

> 결과

__123-456-7890__  
__(123)456-7890__  
__(123)-456-7890__  
__(123-456-7890__  
12345657890  
123 456 7890  

> 분석

\\(?는 여는 괄호가 없거나 하나인 경우에 일치한다. 이때 여는 괄호(()를 이스케이프 해야 함을 주목하다. \\d{3}은 처음에 나오는 세 자리 숫자와 일치하며, \\)?는 닫는 괄호가 없거나 하나인 경우에 일치한다. 그리고 -?는 하이픈이 없거나 하나인 경우에 일치하며, \\d{3}-\\d{4}는 하이픈으로 구분된 나머지 일곱 숫자와 일치한다. 이 패턴은 확실히 마지막 두 행과는 일치하지 않는다. 세 번째와 네 번째 행과는 일치하는데, 두 행 모두 바른 형식이 아니다. 세 번째 전화번호에는 닫는 괄호())와 하이픈(-)이 둘 다 있고, 네 번째는 괄호의 짝이 맞지 않는다.

\\?-?를 [\\)-]?로 바꾸면, 오직 닫는 괄호())나 하이픈(-) 가운데 하나만 일치하여 세 번째 줄을 제거할 수 있지만, 네 번째 줄은 제거할 수 없다. 이 패턴은 여는 괄호(()가 있을 때문 닫는 괄호())와 일치해야 한다. 괄호 한 쌍이 없다면, 하이픈(-)을 찾아야 하는데, 이런 패턴은 조건 처리를 쓰지 않고는 구현할 수 없다.

__조건 사용하기__

정규 표현식 조건은 물픔요(?)를 사용해 정의한다. 사실 우리는 이미 몇가지 특정 조건을 알고 있다.

- 물음표(?)는 바로 앞에 문자나 표현식이 존재한다면, 그 문자 또는 표현식과 일치한다.
- ?=와 ?<=는 만약 존재한다면 앞(전방탐색)이나 뒤(후방탐색)의 텍스트와 일치한다.

조건을 다는 구문 또한 물음표(?)를 사용하는데, 넣을 수 있는 조건이란 것이 방금 나열된 것과 동일하다는 점을 고려하면 놀라운 일이 아니다.

- 역참조를 사용하는 조건 처리
- 전후방탐색을 사용하는 조건처리

__역참조 조건__

역참조 조건은 이전 하위 표현식이 검색에 성공했을 경우에만 다시 그 표현식을 검사한다. 무슨 얘기인지 모르겠다면, 다음 예제를 생각해보자. 본문 안에 있는 \<img\> 태그를 모두 찾아야 하고, 링크 태그 \<a>와 \</a>로 감싸져 있을 때는 이 링크 태그까지 일치시켜야 한다.  
이런 조건을 표현하는 구문은 다음과 같다.  

(?(backreference)true)  

물음표(?)로 조건을 시작하고 괄호 안에 역참조를 지정한 다음, 역참조가 존재하는 경우에만 평가될 표현식이 바로 뒤에 나온다. 다음 예제를 보자

> 예문

\<div>  
  \<a href="/home">\<img src="/images/home.gif"></a>  
  \<img src="/images/spacer.gif">  
  \<a href="/search">\<img src="/images/search.gif"></a>  
  \<img src="/images/spacer.gif">  
  \<a href="/help">\<img src="/images/help.gif"></a>  
\</div>  

> Regex

(<[Aa]\\s[^>]+>\\s\*)?<[Ii][Mm][Gg]\\s+[^>]+>(?(1)\\s\*</[Aa]>)

> 결과

\<div>  
  __\<a href="/home">\<img src="/images/home.gif"></a>__  
  __\<img src="/images/spacer.gif">__  
  __\<a href="/search">\<img src="/images/search.gif"></a>__  
  __\<img src="/images/spacer.gif">__  
  __\<a href="/help">\<img src="/images/help.gif"></a>__  
\</div>  

> 분석

(<[Aa]\\s[^>]+>\\s\*)?는 \<A>나 \<a> 사작 태그가 일치한다. 이때 속성이 있다면 속성도 함께 일치하며, 여기서 마지막에 있는 물음표는 이 패턴이 없어도 되고, 있다면 일치함을 의미헌다. 그러고 나서 <[Ii][Mm][Gg]\\s+[^>]+>는 \<img> 태그를 대소문자 구별 없이, <img> 태그에 속한 속성도 모두 포함해 일치한다. (?(1)\\s\*</[Aa]>)는 조건으로 시작하는데, ?(1)은 역참조1(\<A> 시작 태그)이 있을 때만 수행하라는 말이다. 다른 말로, 태그 \<A>와 일치한다면 그 뒤의 종료 태그도 일치시키라는 뜻이다. 만약 (1)이 있다면, \\s\*</[Aa]>는 \</A>가 나오기 전까지 모든 문자를 일치 영역에 넣어 준다.

앞서 서용한 (?(1)\\s\*</[Aa]>) 패턴으 조건이 충족되었을 때만 수행된다. 조건은 else 표현식을 써서 나타낼 수도 있는데, else 표현식은 역참조가 존재하지 않을 경우에만 수행되는 표현식을 말한다. 이 조건을 나타내는 문법은 다음과 같다  

(?(backreference)true\|false)  

이 문법은 조건을 만족하는지 아닌지를 판단해 표현식을 수행한다.  
이 문법을 써서 앞서 나온 전화번호와 관련된 문제를 다음과 같이 해결할 수 있다.

> 예문

123-456-7890  
(123)456-7890  
(123)-456-7890  
(123-456-7890  
12345657890  
123 456 7890  

> Regex

(\\()?\\d{3}(?(1)\\)\|-)\\d{3}-\\d{4}

> 결과

__123-456-7890__  
__(123)456-7890__  
(123)-456-7890  
(__123-456-7890__  
12345657890  
123 456 7890

> 분석

(\()?는 여는 괄호가 있는지 검사하지만, 이번에는 괄호로 감싸 그 결과를 하위 표현식으로 만들었다. \\d{3}은 숫자 세개로 이루어진 지역번호와 일치한다. (?(1)\\)\|-)는 조건을 만족하는지에 따라 닫는 괄호()) 혹은 하이픈(-)과 일치한다. 만약 (1)이 있다면 (다시 말해 여는 괄호가 있다면), \\)와 일치하고, 없다면 하이픈(-)과 일치한다. 이런 식으로 괄호는 항상 짝을 이워야 하고, 지역번호화 숫자를 구분하는 하이픈은 괄호가 없을 때만 일치한다. 그럼 네 번째 줄은 왜 일치 했을까? 여는 괄호(()와 일치하는 쌍이 없으므로 관련 없는 텍스트로 간주되어 무시되었기 때문이다.

__전후방탐색 조건__

전후방탐색 조건은 전방탐색과 후방탐색 명령이 성공했는지에 따라 표현식을 수행할지 결정한다. 전후방탐색 조건 문법은 역참조(괄호 안에 넣는 숫자)가 완전히 전후방탐색 표현식으로 대체되었다는 점만 빼고는 역참조 조건과 동일하다.

미국 우편번호를 예로 들어 보자. 12345 처럼 표현된 다섯 자리 ZIP이서나 12345-6789 처럼 표현되 ZIP+4 코드다. 하이픈은 오직 뒤에 숫자 네 개가 더 있을 때문 사용한다.

> 예문

11111  
22222  
33333-  
44444-4444

> Regex

\\d{5}(-\\d{4})?

> 결과

__11111__  
__22222__  
__33333__-  
__44444-4444__

> 분석

\\d{5}는 첫 다섯 자리 숫자와 일치하고 (-\\d{4})?는 하이픈과 네 자리 숫자로 이루어진 문자열리 있다면 일치한다.

하지만 형식이 잘못된 우편번호는 제외하고 찾으려 한다면 어떻게 해야할까? 결과에서 세 번째 줄을 보면 없어야 할 하이픈이 붙어 있다. 앞의 패턴은 하이픈을 제외하고 숫자와 일치하였지만, 잘못된 형식이라서 전체 ZIP 코드와 일치하지 않게 하려면 어떻게 해야 할까?  
이번 예제는 조금 억지스럽지만, 전후방탐색 조건을 설명하기에는 좋다.

 예문

11111  
22222  
33333-  
44444-4444

> Regex

\\d{5}(?(?=-)-\\d{4})

> 결과

__11111__  
__22222__  
33333-  
__44444-4444__

> 분석

\\d{5}는 앞부분에 있는 다섯 자리 숫자와 일치한다. 그러고 나서 (?(?=-)-\\d{4}) 같은 형태의 한 조건이 나타난다. 이 조건은 전방탐색 ?=-를 써 하이픈을 찾아내지만, 소비하지는 않는다. 그리고 하이픈이 있다는 조건을 만족하면, -=\\d{4}는 그 하이픈과 이어 나오는 숫자 네 개와 일치하낟. 이 방법을 쓰면 33333-은 일치하지 않는다. 하이픈이 ㅇㅆ어서 조건은 만족하지만, 뒤에 숫자 네 개가 이어지지 않기 때문이다.

전방탐색과 후방탐색(긍정형과 부정형)은 조건으로 사용할 수도 있고, else 표현식(앞에서 봤던 '\| 표현식' 과 동일한 구문을 사용하여)으로도 사용할 수 있다.

## 11장 정규 표현식으로 해결하는 일반적인 문제들
## 부록 많이 쓰는 애플리케이션과 언어에서 활용하는 정규 표현식
