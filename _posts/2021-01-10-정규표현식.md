---
title: 10분 정규 표현식
date : 2021-01-10
categories : review
---

# 손에 잡히는 10분 정규 표현식

## 1장 정규 표현식 소개
직관 적이지 않지만 간단한 문제를 풀때 코드를 줄일 수 있다.

> 정규 표현식은 어디에 사용하는가?
- 검색
- 치환

---

## 2장 문자 하나 찾기

**1.문자 그대로 찾기**

문장 자체도 정규식이라고 볼수 있다

> 예문  

hello, my name is Ben. please visit ...
> Regex

Ben
> 결과

hello, my name is  __Ben__. please visit ...

> 추가

자바스크립트에서는 일치된 결과물을 모두 담은 배열을 반환하고자 할때, `g`(Global:전역) 플레그를 사용한다.



__2.모든 문자 찾기__

마침표(.)는 어떠한 문자나 알파벳, 숫자, 문장 부호로 쓰인 마침표(.)차체와도 일치한다.

> 예문  
 
saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls   

> Regex

sales.
> 결과

__sales1__.xls   
orders3.xls   
__sales3__.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls

>분석

여기서 사용한 sales.라는 정규 표현식은 sales로 시작하고, sales 바로 뒤에 아무문자가 하나 더 붙는 파일명을 모두 찾는다.

마침표(.)는 어떠한 문자나 알파벳, 숫자, 심지어 문장 부호로 쓰인 마침표(.)자체와도 일치한다.


.a. 다음에 바로 마침표가 따라오는 문자열과 일치시키려면 어떨게 해야할까?

__특수문자 찾기__

마침표(.)는 정규 표현식에서 특별한 의마가 있다. 따라서 여러분이 마침표(.)를 찾으려고 한다면, 정규 표현식에세 특별한 의미의 마침표(.)가 아니라 지짜 마침표(.)를 찾고 싶다고 알려 줘야 한다. 그러려면 마침효(.)앞에 역슬레시(\\)를 문자를 붙이면 된다. 역슬래시(\\)는 __메타 문자__(일반적으로 문자 그대로 사용되지 않고 특별한 의미를 지니는 문자를 칭한다)다. 따라서 마침표(.)는 모든 문자와 일치하디만, \\.는 마침표(/)문자 자체와 일치한다는 의미다.

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls   

> Regex

.a.\\.

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
__na1.__xls   
__na2.__xls   
__na3.__xls  

> 분석

.a.\\.로 해결되었다. 첫 번째 마침표(.)는 n 혹은 s와 일치하였다. 두 번째 마침표(.)는 1 혹은 2와 일치하였으며, \\.는 파일명과 확장자를 구분하는 마침표(.)와 일치하였다.

`역슬레시 자체를 찾고 싶을 경우 \\\이라고 쓴다.`

---

## 3장 문자 집합으로 찾기

문자집합을 사용하면 특정 문자들과 문자 번위를 일치시킬 수 있다.

__여러 문자 중 하나와 일치시키기__

마침표(.)는 어떤 문자든지 문자 하나와 일치한다. 하지만 만약 이전 예제에서 `cal1.xls` 를 제외한 , 
`na`와 `sa` 만을 찾고 싶을 때는 어떨게 할 것인가?

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls 
ca3.xls   

> Regex

[ns]a.\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
__na1.xls__   
__na2.xls__   
__na3.xls__   
ca3.xls  

> 분석

정규 표혁인시 [ns] 로 시작한다. 이 패턴은 ns이나 s 중 한 문자와 일치하며, c나 다른 문자와는 일치하지 않는다. 대괄호([])는 집합을 의미하므로 대괄호 자체는 어떤 문자와도 일치하지 않는다. 문자 a는  a와 일치하고 마침표(.)는 모든 문자와 일치한다.

문자 집합은 흔희 대소문자를 구별하지 않고 검색하거나 검색할 부분의 특정 영역만 대소문자를 구별하지 않을 때 사용한다.

> 예문

The parase "regulas expression" is often  
abbreviated as Regex or regex

> Regex

[Rr]eg[Ee]x

> 결과

The parase "regulas expression" is often  
abbreviated as __Regex__ or __regex__

> 분석

여기서 사용한 패턴에는 문자 집합이 두 개 있가. [Tr]은 R이나 r과 일치하고, [Ee]는 E나 e와 일치한다. 이런 식으로 `Regex`와 `regex` 둘 다 일치시킬 수 있다. 하디만 REGEX와는 일치하지 않는다.

__문자 집합 범위 사용하기__

마지막으로 사용한 패턴 [ns]a.\\.xls 에는 또 다른 문제가 있다. 만약 `sam.xls` 라는 파일이 있다면, 어떻게 할 것인가?
문자 집합을 사용해 이 문제를 해결할 수 있다.

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls 
ca3.xls  

> Regex

[ns]a[0123456789]\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
sam.xml   
__na1.xls__   
__na2.xls__   
__na3.xls__  
ca3.xls  

> 분석

이번에 수정한 정규 표현식에서는 첫 글자가 n이나 s와 일치하고, 두 번째 글자는 a, 세 번째 글자는 숫자([0123456789]에 소한 숫자)와 일치한다. sam.xls는 일치하지 않았다는 점을 확인하자.
아래는 하이픈을 통한 범위를 설정하여, 같은 결과를 표현한다.


> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls  
sam.xml     
na1.xls   
na2.xls   
na3.xls 
ca3.xls  

> Regex

[ns]a[0-9]\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
sam.xml   
__na1.xls__   
__na2.xls__   
__na3.xls__  
ca3.xls  

> 분석

범위를 단지 숫자에만 쓸 수 있는 것은 아니다. 다음과 같은 범위에서도 모두 사용할 수 있다.

- A-Z는 A부터 Z사이에 있는 모든 대문자와 일치한다
- a-z는 a부터 z사이에 있는 모든 소문자와 일치한다
- A-z는 아스키 문자 A와 아스키 문자 z 사이에 있는 모든 문자와 일치한다.(이 패턴은 비추천한다. Z와 a 사이에는 대괄호나([) 캐럿(^)도 포함되기 때문이다.)

아래의 예는 RGB 값을 찾는 방법이다

> 예문

body{  
    background-color : #fefbd8;  
}  
h1{  
    background-color : #fefbd8;  
}  

> Regex

\#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]

> 결과


body{  
    background-color : __#fefbd8__;  
}  
h1{  
    background-color : __#fefbd8__;  
}  

> 분석

여기서 사용한 패턴에서는 샵(#) 문자가 문자 그대로 일치하고, [0-9A-Fa-f] 문자 집합이 여섯 번 반복된다.
이 패턴은 숫자나 A와 F사이의 문자이며, 대소문자를 구별하지 않는다.

__'제외하고' 찾기__

멸 개만 빼고 대부분의 문자를 포함해야 할 경우에는 패턴이 너무 실어지므로 원하는 문자를 모두 나열하기보다는 캐럿(^) 문자를 써 제외할 문자 집합을 지정한다.

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls  
sam.xml     
na1.xls   
na2.xls   
na3.xls 
ca3.xls  

> Regex

[ns]a[^0-9]\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls  
__sam.xml__     
na1.xls   
na2.xls   
na3.xls 
ca3.xls  

> 분석

[0-9]는 모든 숫자와 일치한다 [^0-9]는 정해징 범위 내에 있는 수자와 일치하지 않는다.   
즉, [ns]a[^0-9]\\.xls는 na1.xls, na2.xls, na3.xls 와는 일치하지 않고, sam.xls와 일치한다.

---
## 4장 메타 문자 사용하기

__이스케이프 다시 살펴보기__

메타 문자는 정규 표션식 안에서 특별한 의미가 있다. 마침표(.)는 메타 문자로, 어떤 문자든 문자 하나와 일치한다. 이와 유사하게, 여는 대괄호([)도 집합의 시작을 나타내는 메타 문자다

메타 문자들은 정규 표현식에서 특별한 의미가 있으므로 자기 자신을 문자 그대로 표현할 수 없다. 여는 대괄호([)가 여는 대괄호([))와 일치하지 않는다는 의미다.

다음 예제를 보자. 이 정규 표현식에서는 여는 대괄호([)와 단는 대괄호(])를 포함하는 자바스크립트 배열을 찾으려 한다.

> 예문

var myArray = new Array();  
...  
if(myArray[0] == 0){}  
...  

> Regex

myArray\\[0\\]

> 결과

var myArray = new Array();  
...  
if(__myArray[0]__ == 0){}  
...  

> 분석

이 예제에서 쓴 정규 표현식은 다소 불필요해 보인다. 단순한 텍스트 검색만으로도 충분희 만족스러운 결과를 더 쉽게 얻을 수 있다. 하지만 단순히 myArray[0]뿐만 아니라 myArray[1] 과 같은 배열도 찾으려면 어떻게 해야 할지 상상해 보자. 이때는 정규 표현식을 사용하는 편이 더 유용하다. 여는 대괄호([)와 닫는 대괄호(])는 이스케이프 하고 두 문자 사이에 원하는 문자들이 일치하도록 조건을 정하면 된다. 만약 배열 요소를 0부터 9까지 일치시키고 싶다면 다음과 같이 정규 표현식을 작성할 수도 있다.

myArray\\[[0-9]\\]

역슬레시(\\)는 메타 문자들을 이스케이프 하는 데 사용된디. 이 말은 열슬레시(\\)도 메타 문자이며, 다른 메타 문자들을 이스케이프 하는데 사용된다는 뜻이다. 
 다음에 나온 간단한 예제에선 윈도우에서 볼 수 있는 역슬래시(\\)를 이용한 파일 경로다. 이 경로를 리눅스에서 사용한다는 가정하에 모든 역슬래시를 찾아 슬래시로 변경해 보자

> 예문

\home\ben\sales\

> Regex

\\\

> 결과

__\\__ home __\\__ ben __\\__ sales __\\__

> 분석

정규 표현식에 역슬래시(\\)만을 사용했다면, 아마 에러가 발생했을 것이다. 정규 표현식 분석기가 정규표현식을 다 작성하지 않았다고 판단하기 때문이다. 그러니 정규 표현식에서는 역슬래시(\\)위에 반드시 다른 문자를 함께 써넣어야 한다.

__공백 문자 찾기__

메타 문자는 일반적으로 두 가지 범주로 나뉜다. 마침표(.)처럼 텍스트와 와 일치하는 문자와 여는 대괄호([)나 닫는 대괄호(])처럼 정규 표현식문법의 일부로 쓰는 문자다. 이제 공백 문자를 살펴보면서 두 가지 유형의 메타 문자들을 더 많이 접할 것이다. 우선 공백 메타 문자부터 시작 해 보자.

 정규 표현식 검색을 수행할 때, 여러분은 눈에 보이지 않지만 텍스트에 포함되는 공백 문자를 찾아야 할 때가 있을 것이다. 꼼수를 이용하지 않고 이런 문자를 정슈 표현식에 직접 써넣기는 어려우므로 아래ㅠㅛ와 같은 특수한 메타 문자들을 사용할 수 있다.

 |메타 문자 | 설명|
 |:--|:--|
 |\[\\b\]|백 스페이스|
 |\\f|페이지 넘김(form feed)|
 |\\n|줄바꿈|
 |\\r|캐리지 리턴|
 |\\t|텝|
 |\\v|수직 텝|

 다음 예제를 보자. 여기에 나오는 예문에는 콤마로 구분된(일반적으로 CSV라고 부른다) 레코드가 담겨 있다. 여러분은 게디어터에 있는 빈 줄을 모두 제거한 다음, 이 레코드를 처리해야한다.

 > 예문

"101","Ben","forta"  
"102","Jim","James"  

"103","Robert","Bet"  

> Regex

\\r\\n\\r\\n

> 결과

"101","Ben","forta"  
"102","Jim","James"  
 
"103","Robert","Bet"  

> 분석

\\r\\n은 줄바꿈과 캐리지 리턴의 조합과 일치한다. 윈도우에서 이 조합은 줄의 끝을 나타내는 데 사용된다.
따라서 \\r\\n\\r\\n을 검색하면, 줄 씉이 연속해서 두 번 나오는 부분과 일치하는데, 이때 줄의 끝이 두번 나온다는 것은 바로 두 레코드 사이에 빈 줄이 있음을 의미한다.

__특정한 문자 형태와 일치시키기__

자주 쓰는 문자 집합들은 특수한 메타 문자로 대신하기도 한다. 이런 메타 문자들을 __문자 클래스__ 라고 부른다. 직접 찾고 싶은 문자들을 열거하거나 범위를 사용하면 되기 때문에, 실제로 클래스 메타 문자를 써야만 하는 경우는 결코 없지만, 일단 사용해 보면 너무나도 유용함을 알게 된다.

__숫자와 숫자가 아닌 문자 찾기__

|메타 문자| 설명|
|:--|:--|
|\\d| 숫자 하나([0-9])와 같다|
|\\D| 숫자를 제외한 문자 하나([^0-9])와 같다.|
 
앞선 예문를 수정하여 이 메타문자를 어떻게 쓰는지 확인해보자

> 예문

var myArray = new Array();  
...  
if(myArray[0] == 0){}  
...  

> Regex

myArray\\[\\d\\]

> 결과

var myArray = new Array();  
...  
if(__myArray[0]__ == 0){}  
...  

> 분석

이 정규 표현직은 myArray[1] 과는 일치하지만  myArray[10] 과는 일치하지 않는다.

__영숫자 문자와 영숫자가 아닌 문자 찾기__

자주 사용하는 문자 집합이 또 있다. 영숫자 무자로, 대소문자와 소문자를 포함한 알파벳 A부터 Z, 숫자, 밑줄(대개 파일이나 디렉터리 이름, 애플리케리션 변수명, 데이터베이스 객체 이름 등에 사용한다.)을 포함한다.

|메타 문자| 설명|
|:--|:--|
|\\w|대소문자와 밑줄을 포함하는 모든 영숫자[a-zA-Z0-9]와 같다.|
|\\W|대소문자와 밑줄을 아닌 모든 영숫자[^a-zA-Z0-9]와 같다.|

> 예문

12313  
A1C2E3  
480787  
48907  
H1B4F2  
908700  
H1H2H3  

> Regex

\w\d\w\d\w\d

> 결과

12313  
__A1C2E3__  
480787  
48907  
__H1B4F2__  
908700  
__H1H2H3__  

> 분석 

여기서는 메타 문자 \\w와 \\d를 조합한 패턴을 사용했는데, 캐나다 우편번호만을 찾아낸다

__공백 문자와 공백이 아닌 문자 찾기

마지막으로 살펴볼 분류는 공백 클래스다.

|메타 문자| 설명|
|:--|:--|
|\\s|모든 공백 문자([\\f\\n\\r\\t\\v])와 같다.|
|\\S|공백 문자가 아닌 모든 문자([^\\f\\n\\r\\t\\v])와 같다.|

__16진수나 8진수 표현하기__

__16진수 사용하기__

16진수 같은 앞에 \\x를 붙여 표시한다. 즉, \\x0A는 줄바꿈 문자가 되며 \\n과 기능이 같다.

__8진수 사용하기__

8진수 같은 두 자리나 세 자리 정수 앞에 \\0을 붙여 표시한다. 즉, \\011은 탭 문자이며, \\t와 기능이 같다

__포직스 문자 클래스 사용하기__

포직스 문자 클래스는 줄여 쓰기를 나타내는 또 다른 형태인데, 전부는 아니지만 많은 정규 표현식 구현에서 지원한다.

_자바스크립트는 정규 표현식에서 포직스 문자 클래스를 지원하지 않는다._

[정규표현식](https://www.nextree.co.kr/p4327/)

## 5장 반복찾기

이 장에서는 여러 번 반복해 나타나는 문자나 문자 집합을 어떨게 팢는지 알아본다.

__몇 번 일치하는가?__

이메일 주소와 일치하는 정규 표현직을 작성한다고 생각해 보자. 이메일 주소의 기본 형식은 다음과 같다.

text@text.text

4장에서 배운 메타 문자를 사용해 다음롸 같은 정규 표현식을 만들 수 있다.

\\w@\\w\\.\\w

\\w 문자는 모든 영숫자 문자와 일치한다. 더불어 밑줄도 함께 찾는데, 밑줄 역시 이메일 주소에서 사용하는 문자다. 앳(@)은 이스케이프 하지 않아도 되지만, 마침표(.)는 이스케이프 해야한다.

이 패턴은 문법에 완벽하게 맞는 정규 표현식이긴 하지만 쓸모 없다. 이 패턴으로는  a@b.v 같은 이메일 주소만 찾을 수 있다. 문법은 맞지만, 분명히 유효한 메일 주소는 아니다. 문제는 \\w는 문자 하나하고만 일치하는데, 얼마나 많은 문자를 검사해야 할지 모른다는 점이다. 다음 이메일 주소들은 모두 유효하지만, @ 문자 앞에 나온 문자 수는 서로 다르다.

b@forta.com  
ben@forta.com  
bfort@forta.com  

__하나 이상의 문자 찾기__

문자나 집합에 속한 요소를 하나 이상 찾으려면 간단리 문자 뒤에 더하기(+) 문자를 붙이면 된다. 더하기(+) 문자는 문자가 하나 이상일때 일치한다(최소한 하나와 일치하고, 없을 때는 일치하지 않는다). a가 a를 찾는 데 반해, a+는 하나 이상 연속된 a를 찾는다. 비슷하게 [0-9]는 자릿수가 하나인 숫자를 찾는 데 반해, [0-9]+는 한자리 이상 연속된 숫자를 찾는다.

이번에는 더하기(+)를 사용해 하나 이상의 문자와 일치시키자.

> 예문

Send personal email to ben@forta.com For questions  
about a book use support@forta.com Feel free to send
....

> Regex

\\w+@\\w+\\.\\w+

> 결과

Send personal email to __ben@forta.com__ For questions  
about a book use __support@forta.com__ Feel free to send
....

다하기(+)는 문자 집합이 하나 이상인 경우에도 사용한다. 다음 예제로 실험해 보자. 정규 표현식은 같지만 예문이 조금 다르다.

> 예문

Send poersonal email to ben@forta.com or  
ben.forta@forta.com. For questions about a   
book use support@forta.com. If your message  
is urgent try ben@urgent.forta.com. Feel  
....

> Regex

\\w+@\\w+\\.\\w+

> 결과

Send poersonal email to __ben@forta.com__ or  
ben.__forta@forta.com__. For questions about a   
book use __support@forta.com__. If your message  
is urgent try __ben@urgent.forta__.com. Feel  
....

> 분석

정규 표현식으로 주소를 네가지 찾았지만, 그중 두 개는 제대로 검색되지 않았다.  
\\w+@\\w+\\.\\w+는 앳(@) 앞에 나오는 마침표(.)를 일치시키지 못하고, 앳(@) 귀에 문자열을 둘로 나누는 마침표(.)는 하나만 검색되도록 설정되었기 때문이다. \\w는 영숫자와 일치하지만, 문자열 중간에 있는 마침표(.)와는 일치하지 않기 때문에 ben.forta@forta.com리 올바른 이메일 주소라 해도, 이 정규 표현식은 ben.forta 대신 forta만 찾는 것이다.

이제 \\w나 마침표(.) 와 일치하도록, 정규 표현식 규칙에 따라 [\\w.] 집합을 정의해야 한다. 

> 예문 

Send poersonal email to ben@forta.com or  
ben.forta@forta.com. For questions about a   
book use support@forta.com. If your message  
is urgent try ben@urgent.forta.com. Feel  
....

> Regex

[\\w.]+@[\\w.]+\\.\\w+

> 결과

Send poersonal email to __ben@forta.com__ or  
__ben.forta@forta.com__. For questions about a   
book use __support@forta.com__. If your message  
is urgent try __ben@urgent.forta.com__. Feel  
....

> 분석

[\\w.]+를 쓰니 문자, 밑, 마침표(.)가 하나 이상 일치해 ben.forta를 제대로 찾아 냈다.
 [\\w.]+는 앳(@) 뒤에서 더 깊은 단계의 도메인 주소를 찾기도 했다.

__문자가 없거나 하나 이상 연속하는 문자 찾기__

더하기(+)는 하나 이상 연속된 문자를 찾는다. 문자가 없는 경우는 아예 찾지 못하고, 최소한 하나는 일치해야 한다. 하지만 있을 수도 있고 없을 수도 있는 문자와 일치시키려면 어떻게 해야 할까?  그럴 때는 메타문자인 별표(\*)를 사용하면 된다. 별표(\*)는 더하기(+)와 거의 비슷하게 사용하는데, 문자나 집합 바로 뒤에 두면 찾고자 하는 문자나 집합이 없는 경우 또는 하나 이상 연속하는 경우에 일치한다. 따라서 B.* Forta  패턴은 B Forta, B. Forta, BenForta 같은 조합과도 일치한다.
앞서 나온 이메일 예제를 수정해 별표(\*)의 사용법을 살펴보자.

> 얘문

Hello .ben@forta.com is my email address.

> Regex

[\\w.]+@[\\w.]+\\.\\w+

> 결과

Hello .__ben@forta.com__ is my email address.

> 분석

패턴이 더 복잡해 진 것 같지만 실재로는 그렇지 않다. \\w|는 마침표를 제외한 영숫자 문자와 모두 일치한다.(즉, 이메일 주소의 시작으로 유효한 문자를 말한다.) 우선 첫 문자가 유효하면, 그 다음에는 마침표(.)가 하나 나오거나 문자가 더 나올 수도 있다. 사실 이런 이멤일 주소는 없을지도 모른다. [\\w.]*는 문자가 없는 연우를 포함해 여러 개의 영숫자 혹은 마침표(.)와 일치하는데, 이것이 우리가 찾고자 한 텍스트다.

__문자가 없더나 하나인 문자 찾기__

매우 유용한 메타 문자로 물음표(?)가 있다. 별표(\*)처럼 물음표(?)는 문자가 있는 경우 일치하고 문자가 없어도 일치하디만, 별표(\*)와 달리 문자나 집합이 없거나 하나만 있는 경우에만 일치하며, 하나 이상은 일치하지 않는다. 즉, 물음표(?)는 문자 묶음 안에서 있는지 없는지 확실하지 않은 특정한 문자를 하나만 찾을 때 매우 유용하다.

> 예문

The URL is http://www.forta.com/, to connect  
securely user https:///www.forta.com/ instead.

> Regex

http:\\/\\/[\\w.\\/]+

> 결과

The URL is __http://www.forta.com/__, to connect  
securely user https:///www.forta.com/ instead.

> 분석

이 패턴은 URL을 일치시키고자 http:\\/\\/를 썼고, 문자 그대로 찾기 때문에 오직 해당 문자와만 일치한다. 이어서 [\\w.\\/]+가 영숫자 문자, 마침표(.), 슬러시(/)로 이루어진 집합의 구성 요소 가운데 하나 이상과 일치한다. 이 패턴은 처음에 있는 http:// 로 시작하는 URL과는 일치하지만 두 번째에 있는 https:// 로 시작하는 URL과는 일치하지 않는다. 그렇다고 s가 없더나 하나 이상 연속될 대 일치하는 s*가 적합하지도 않다. httpssssss:// 도 일치하기 때문이다.

해결방법은 다음 예제처럼 s?를 쓰는 것이다.


> 예문

The URL is http://www.forta.com/, to connect  
securely user https:///www.forta.com/ instead.

> Regex

http?:\\/\\/[\\w.\\/]+

> 결과

The URL is __http://www.forta.com/__, to connect  
securely user __https:///www.forta.com/__ instead.

> 분석

이 패턴은 https?:\\/\\/로 시작한ㄷ. 물음표(?)는 자기 앞에 있는 문자가 없거나 그 문자가 하나만 있는 경우 일치한다. 여기서는 s인데, https?:// 는 http:// 나 https:// 와는 일치하지만, 그 외에는 일치하지 않는다.

덧붙여 물음표(?)를 쓰면 4장에서 언듭한 문제도 해결된다. 우리는 \\r\\n 으로 줄의 끝을 일치시키는 예제를 살펴봤는데, 유닉스나 리눅스 환경에서는 \\r 은 제외하고 \\n 만 사용한다고 언급했다. 이때 \\n 앞에 \\r이 있을 경우에만 일치시키는 것이 이상적인 해결책일 것이라고도 했다. 정규표현식을 약간 수정했다.

> 예문

"101","Ben","forta"  
"102","Jim","James"  

"103","Robert","Bet"  

> Regex

[\\r]?\\n[\\r]?\\n

> 결과

"101","Ben","forta"  
"102","Jim","James"  
 
"103","Robert","Bet"  

> 분석

[\\r]?\\n은 \\r이 있을 경우에는 \\r과 일치하고, \\n과는 반드시 일치한다.

__구간 지정하기__

더하기(+), 별표(*), 물음표(?)는 정규 표현식을 쓰면서 발생하는 많은 문제를 해결해 주지만, 충분하지 않은 때도 있다. 다음과 같은 상황을 생각해 보자.

- 더하기(+)와 별표(*)는 일치하는 문자 수에 제한이 없다. 문자가 최대 몇 개까지 일치하는지는 정할 수 없다.
- 더하기(+), 별표(*), 물음표(?)가 일치하는 무자 수의 최솟값은 0이나 1이다. 일치하는 문자 숫의 최솟값을 명시적으로 정의할 수 없다.
- 정확히 원하는 만큼만 일치하도록 문자 수를 정의할 수 없다.

이런 문제들을 해결하고, 연혹하는 문자를 찾을 때 검색 조건을 더 구체적으로 지정하고자 정규 표현식에서는 __구간__ 을 사용한다. 구산은 중괄호({}) 안에 표시한다.

__정확한 구간 찾기__

문자가 일치하는 수를 정확히 정하려면 여는 중괄호({)와 닫는 중괄호(}) 사이에 숫자를 넣는다. 즉, {3}은 바로 앞에 있는 문자나 문자 집합이 세 번 연속해서 일치하는지 확인한다. 만약 요소가 두 개만 있다면, 패턴이 일치하지 않는다.

 3장과 4장에서 활용한 RGB예제를 수정해 어ㄸ러게 작동하는지 알아보자. 여러분은 RGB값이 두 개씩 ㅅ짝지어진 16진수 숫자 집합 세개로 이루어짐을 기억할 것이다. 처음에는 RGB 값을 찾을 때 다음과 같은 패턴을 사용했다.

\#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]

이 예제에 구간 찾기를 사용해 보겠다

> 예문

body{  
    background-color : #fefbd8;  
}  
h1{  
    background-color : #fefbd8;  
}  

> Regex

\#[0-9A-Fa-f]{6}

> 결과


body{  
    background-color : __#fefbd8__;  
}  
h1{  
    background-color : __#fefbd8__;  
}  

> 분석

[0-9A-Fa-f]는 하나의 16진수 문자와 일치함을, {6}은 이를 여섯번 반복함을 뜻한다.

__범위 구간 찾기__

값(일치 횟수)의 범위, 다시 말해 일치시키려는 요소(instance) 수의 최솟값과 최댓값을 나타낼 때도 구간을 사용한다. 범위는 {2,4}처럼 표현한다. 최소 두 번에서 최대 네 번까지 일치시킨다는 의미다. 날짜 형식을 찾는 정규 표현식이 범위 구간 찾기를 보여주는 예로 적정하다. 

> 예문

4/8/17
10-6-2020
2/2/2
01-01-01

> Regex

\\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{2,4}

> 결과

__4/8/17__
__10-6-2020__
2/2/2
__01-01-01__

> 분석

여기에는 사용자가 입력창에 써넣었을 만한 값이 나열되었다. 이 값들은 날짜 형식에 맞게 입력되어야 한다. \\d{1,2}는 한 자리 혹은 두 자리 숫자와 일치해 날짜와 월을 검사하고 \\d{2,4}는 연도와 일치하며, [-\\/]는 날짜 구분선인 하이픈(-)이나 슬러시(/)와 일치한다. 결과적으로 연도가 너무 짧아서 일치하지 않은 2/2/를 제외하고 날짜가 세개 일치했다.

중요한 것은 이 패턴으로는 날짜가 옳은지 검사하지는 못한다는 점이다. 54/67/9999 처럼 값이 틀려도 검사를 통과한다. 이 패턴은 날짜형식에 맞는지만 검사할 뿐이다. 그래서 이 단계는 주로 날짜 자체가 유효한지 검사하기 전에 이루어진다.

__'최소' 구간 찾기__

마지막으로 구간 검색은 최댓값 없이 찾고자 하는 요소의 최솟값을 지정할 수도 있다. 이 패턴에서 쓴 구간 문법은 범위와 비슷하지만, 최댓값이 없다는 점만 다르다. 예를 등러 {3,}은 최소한 요소가 세번 일치함을 의미한다. 다시 말해, 요소가 세 번 이상 일치한다는 것이다. 다음 예제에서는 이 장에서 배운 것들을 조합해 보았다. 이 예제에는 주문 금액이 100달러 이상인 주문을 모두 찾는 정규 표현식을 썼다.

> 얘문

1001: $496.80
1002: $1290.80
1003: $26.80
1004: $613.80
1005: $7.80
1006: $414.80
1007: $25.80

> Regex

\\d+:\\$\\d{3,}\\.\\d{2}

> 결과

__1001: $496.80__
__1002: $1290.80__
1003: $26.80
__1004: $613.80__
1005: $7.80
__1006: $414.80__
1007: $25.80

> 분석

예문은 주문 번호와 주문 금액을 보여 주는 보고서다. 이 정규 표현식은 처음에 \\d+:를 써 주문 번호를 찾는다. 주문 번호를 포함한 전체 행이 아니라, 단순히 금액만 찾고 싶다면 이 패턴을 빼도 무방하다. 

\\$\\d{3,}\\.\\d{2} 는 금액과 일치하는 패턴이다. \\$는 달러기호($). \\d{3,}은 최소한 세 자리 숫자(즉, 최소 100달러), \\.은 마침표(.), 마지막으로 \d{2}는 소수점 이하 두 자리 숫자와 일치한다. 이 패턴은 일곱 개 주문 중 네 개와 일치한다.

__과하게 일치하는 상황 방지하기__

물음표(?)는 제한된 범위만큼 일치시키고(없거나 하나만 있는 경우와 일치한다.), 구간을 쓰면 정확히 지정한 만큼 일치하거나 지정한 범위 안에서만 검색을 수행한다. 하지만 이 장에서 소개한 패턴들은 일차하는 횟수에 제한이 없기 때문에 때로는 너무 많이 일치하기도 한다.

 그래서 지금까지 나온 예제는 모두 일치하지 않아도 되는 텍스트까지 과도하게 일치하는 상황이 없도록 주의 깊게 선택했지만, 다음 예제를 생각해 보자. 다음 예문은 웹 페이지의 일부고 HTML 테그인 \<b\> 가 포함되었다. 정규 표현식으로 \<b\> 태그로 둘러싸인 텍스트(형식을 바꾸려고 하는지도 모든다)를 일치시켜야 한다.

 > 예문

This offer is not available to customers
living in \<b\>AK\</b\> and \<b\>HI\</b\>.

> Regex

\<[Bb]\>.*\<\\/[Bb]\>

> 결과

This offer is not available to customers
living in __\<b\>AK\</b\> and \<b\>HI\</b\>__.

> 분석

\<[Bb]\>는 \<b\> 시작 태그와 일치하고, <\\/[Bb]\> 는 \</b\> 종료 태그와 일치한다. 두 경우 모두 대소문자를 구별하지 않는다. 하지만 두 번이 아니라 오직 한 번만 일치했다. .* 는 처음 나온 \<b\>부터 마지막에 나온 \</b\> 사이에 있는 모든 텍스트와 일치하므로 __AK\</b\> and \<b\>HI__ 가 일치한 것이다. 우리가 원하는 텍스트를 포함하긴 하지만, 찾으려 하지 않은 텍스트도 포함했다.

바로 별표(*)와 더하기(+) 같은 메타 문자가 __탐욕적(Greedy)__ 이므로 이는 가능한 가장 큰 덩어리를 찾으려 한다는 뜻이다. 이런 메타 문자는 찾으려는 텍스트를 앞에서부터 찾는 게 아니라, 텍스트 마지막에서 시작해 거꾸로 찾는다. 의도적으로 수량자를 탐욕적으로 설계했기 때문이다.

 하지만 만약 우리가 탐욕적 일치를 원하지 않는다면 어떻게 해야 할까? 탐욕적 수량자를 __게으른(Lazy)__ 수량자로 바꿔 이 문제를 해결한다.  
 '게으른'이라고 부르는 이유는 문자가 최소로 일치하기 때문이다. 게으른 수량자는 기존 수량자 뒤에 물음표(?)를 붙여서 표현한다. 아래 표는 탐욕적 수량자에 대응되는 게으른 수량자 이다. 

|탐욕적 수량자|게으른 수량자|
|:--|:--|
|*|*?|
|+|+?|
|{n,}|{n,}?|

*?는 별표(\*)의 게으른 수량자인데, 이 문자를 이용해 앞서 나온 예제를 수정해 보자

 > 예문

This offer is not available to customers
living in \<b\>AK\</b\> and \<b\>HI\</b\>.

> Regex

\<[Bb]\>.*?\<\\/[Bb]\>

> 결과

This offer is not available to customers
living in __\<b\>AK\</b\>__ and __\<b\>HI\</b\>__.

> 분석

게으른 수량자인 *?를 사용해서, 두 부분을 따로 일치시켰다.

## 6장 위치 찾기

이따금 텍스트 영역 내에 있는 특정 위치에서 텍스트를 찾아야 할 때도 있다. 그러려면 위치 찾기가 필요하며, 이 장에서는 바로 위치 찾기를 배울 것이다.

__경계 지정하기__

위치 찾기는 텍스트 문자열 안에서 만드시 일치해야 하는 위치를 지정할 때 사용한다. 위치 찾기가 왜 필요한지 이해하기 위해 다음 예제를 살펴보자

> 예문

The cat scattered his food all over the room.

> Regex

cat

> 결과

The __cat__ s __cat__ tered his food all over the room.

> 분석

cat 패턴은 cat이 있는 부분과 모두 일치한다. 심지어  scattered라는 단어 사이에 있는 cat 과도 일치한다. 사실 이런 결과를 바랐을 수도 있다. 하지만 그렇지 않을 가능성이 더 크다. 만약 우리가 cat을 모두 dog로 치환화려고 검색했다면 다음과 같은 말도 안되는 결과를 얻게 된다.

The dog sdogtered his food all over the room.

이렇 때 __경계__ 를 사용하거나 패턴 앞이나 뒤에 특정한 위치 혹은 경계를 나타내는 메타 문자를 사용하면 된다.

__단어 경계 지정하기__

처음으로 알아볼 경계는 가장 흔하게 쓰는 방법인데,  \\b로 표시하는 단어 경계다. 단어 경계라는 이름에서 유추해 볼 수 있듯이, \\b는 단어의 시작이나 마지막을 일치시킬 때 사용한다.

 \\b를 어떻게 쓰는지 알아보고자 앞서 본 예제를 다시 사용할 텐데, 이번에는 경계를 지정하겠다.

> 예문

The cat scattered his food all over the room.

> Regex

\\bcat\\b

> 결과

The __cat__ scattered his food all over the room.

> 분석

cat이라는 단어 앞뒤는 빈칸인데 여기서 빈칸은 단어와 단어를 구분하는 문자들 가운데 하나이므로,  \\bcat\\b와 일치한다. 하지만 scattered라는 단어 사이에 있는 cat은 앞에는 s, 뒤에는 t가 이어서 나와 둥 가 \\b와 일치하지 않으므로 일치하지 않는다. 

중요한 것은 완전한 단어 하나를 일치시키고자 한다면, 일치시키고자 하는 단어 앞뒤에 모두 \\b를 붙여야 한다는 점이다. 다음 예제를 살펴보자.

> 예문

The captain wore this cap and cape proudly as  
he sat listening to the recap of how his  
crew saved the men from a capsized vessel.

> Regex

\\bcap

> 결과

The __cap__ tain wore this __cap__ and __cap__ e proudly as  
he sat listening to the recap of how his  
crew saved the men from a __cap__ sized vessel.

> 분석

\\bcap 패턴은 cap으로 시작하는 모든 단어와 일치한다. 따라서 단어가 총 네 새 일치했지만, 그중 세 단어는 cap이 포함된 다른 단어다.

다음은 같은 예제지만, \\b를 뒤에만 붙인 것이다.


> 예문

The captain wore this cap and cape proudly as  
he sat listening to the recap of how his  
crew saved the men from a capsized vessel.

> Regex

cap\\b

> 결과

The captain wore this __cap__ and cape proudly as  
he sat listening to the re __cap__ of how his  
crew saved the men from a capsized vessel.

> 분석

cap\\b는 cap으로 끝나는 단어와 모두 일치한다. 따라서 단어가 총 두 개 일치했지만, 그중 하나는 cap을 포함하는 다른 단어다. 만약 cap만으로 구성된 단어만 일치시키려 한다면, 패턴을 \\bcap\\b로 작성해야 한다.

특별히 단어 결계외 일치시키고 싶지 않을 땐, \\B를 사용한다. 다음 예제에서는 \\B 메타 문자를 활용해 잘못 쓰인 빈칸으로 둘어싸인 하이픈을 찾는다.

> 얘문

Please enter the nine-digit id ad it  
appears on your color - coded pass-key.

> 정규 표현식

\\B-\\B

> 결과

Please enter the nine-digit id ad it  
appears on your color __-__ coded pass-key.

> 분석

\\B-\\B는 단어 구분 문자로 둘어싸인 하이픈과 일치한다. 그러므로 
nine-digit , pass-key는 일치하지 않지만, color - coded는 일치한다.

__문자열 경계 정의하기__

단어 경계는 단어의 위치(단어의 시작, 단어의 마지막, 단어 전체 등)를 기반으로 위치를 찾는다. 문자열 경계는 단어 경계와 기능은 비슷하지만, 전체 문자열의 시작이나 마지막 부분과 패턴을 일치시키고자 할 때 사용한다. 문자열 경계는 메타 문자 가운데 캐럿(^)으로 문자열의 시작을, 달러 기호($)로 문자열의 마지막을 나타낸다.

문자열 경계를 사용하는 방법을 다음 예제를 통해 알아보자. 올바른 XML 문서는 <\?xml>로 시작하고, 주로 부가 속성(<\?xml version="1.0"\?>)처럼 버전 번호일 수 있다)을 포함한다. 다음은 주어진 텍스트가 XML 문서인지 아닌지 간단하게 검사하는 에제다.

> 예문

<\?xml version="1.0" encoding="UTF-8" \?>
...

> Regex

<\\?xml.*\\?>

> 결과

__<\?xml version="1.0" encoding="UTF-8" \?>__
...

> 분석

제대로 동작하는 것처럼 보인다. <\\?xml 은 <\?xml 과 일치하고, \\?>는 마지막 \?>와 일치하며, .*은 텍스트가 없는 경우도 포함하여 둘 사이에 있는 모든 텍스트와 일치한다.

하지만 이 검사는 부정확하다. 다음 예제를 보자. 같은 패턴을 적용했지만, XML 파일이 시작하기 전에 관계없는 텍스트가 포함되었다.

> 예문

This is bad, real bad!
<\?xml version="1.0" encoding="UTF-8" \?>
...

> 정규 표현식

<\\?xml.*\\?>

> 결과

This is bad, real bad!
__<\?xml version="1.0" encoding="UTF-8" \?>__
...

> 분석

<\\?xml.*\\?> 패턴은 예문에서 두 번째 줄과 일치한다. 그리고 실제로 예문 두 번째 줄에 XML을 여는 태그가 있긴 하지만, 결코 유요한 예문은 아니다.(xml관련 선언문은 반드시 첫줄에 표현이 있어야 한다.) 게다가 이 예문으로 XML를 처리하려다가는 여러 문제가 발생할 수 있다.

우리는 XML을 여는 태그가 문자열 안에 있는 실제 택스트에서 첫 번째중에 위치한다는 사실을 확인해야 한다. 이 작업을 하기에는 다음에 나올 캐럿(^) 메타 문자가 제격이다.

> 예문

<\?xml version="1.0" encoding="UTF-8" \?>
...

> Regex

^\\s<\\?xml.*\\?>

> 결과

__<\?xml version="1.0" encoding="UTF-8" \?>__
...

> 분석

앞에 있는 캐럿(^) 문자는 문자열의 시작과 일치하므로, ^\\s\*는 문자열 시작이면서 바로 뒤에 공백 문자가 없거나, 하나 이상 있는 경우와 일치한다. 즉, XML 문서가 시작하기 전에 나올 수 있는 빈칸, 탭, 줄바꿈들은 처리한다. 전체 
^\\s<\\?xml.*\\?> 는 어떤 속성을 지닌 XML이든 여는 태그와 일치하며, 공백도 정확하게 처리한다.

달러 기호($)도 캐럿(^) 문자와 매우 유사한 방법으로 사용한다. 다음 패턴은 웹 페이지에서 닫는 <\/html> 태그 뒤에 아무 문자도 나오지 않는지 확인하는 데 쓴다.

> 정규 표현식

</[Hh][Tt][Mm][Ll]>\\s*$

> 분석

문자 집합은 대소문자를 어떨게 조합해도 일치할 수 있도록 H,T,M,L 문자를 하나씩 찾고, \\s*$는 공백 문자와 그 뒤에 오는 문자열 마지막을 찾는다.

__다중행 모드 사용하기__

대개 캐럿(^)은 문자열의 시작과 일치하고, 달러 기호($)는 문자열의 마지막과 일치한다. 예외적으로 두 메타 문자의 동작을 바꾸는 방법이 있다.  
 많은 정규 표현식 구현은 아른 메타 문자의 동작을 변경하는 특수한 메타 문자를 지원하는데, 그중 하나 (\?m)으로, 다중행을 지원한다. 다중행 모드로 변경하면 정규 표현식 엔진이 줄바꿈 문자를 문자열 구분자로 강제로 인식한다. 캐럿(^)은 문자열의 시작이나 줄바꿈 다음(새로운 행)에 나오는 문자열의 시작과 일치하고, 달러 기호($)는 문자열의 마지막이나 줄바꿈 다음에 나오는 문자열의 마지막과 일치한다.  
 (\?m)은 항상 패턴 제일 앞에 두어야 한다. 다음은 정규 표현식을 사용하여 코드 블록 내의 모든 자바스크립트 주석을 찾는 예제다.

 > 예문

 \<script\>  
function doSpellCheck(form, field){  
  //Make sure not empty  
  if(field.value == ''){  
    return false;  
  }  
  // Init  
  ...  
    
  // Done  
  
  ...  
}  
\</script\>

> Regex

(\?m)^\\s*\\/\\/.*$

> 결과

 \<script\>  
function doSpellCheck(form, field){  
  __//Make sure not empty__  
  if(field.value == ''){  
    return false;  
  }  
  __// Init__  
  ...  
    
  __// Done__  
  
  ...  
}  
\</script\>

> 분석

^\\s*\\/\\/.*$는 문자열 시작 부분과 바로 뒤에 나오는 공백들, 그리고 다시 //)자바스크립트 주석을 정의하는 데 쓴다.), 그다음으로 모든 텍스트, 마지막으로 문자열의 끝과 일치한다. 하지만 이 패턴은 오직 첫 번째 주석과만 일치한다(그것도 해당 주석이 그 페이지에서 유일할 때만 그렇다.) (\?m)^\\s*\\/\\/.*$ 에서 (\?m) 변경자를 써 이 패턴에서 줄바꿈을 문자열 구분자로 인식하게 했더니 모든 주석이 일치했다.

_(\?m) 은 자바스크립트를 포함한 대부분의 정규 표현식 구현에서는 지원하지 않는다._ 

## 7장 하위 표현식 사용하기

__하위 표현식 이해하기__

5장 "반복 찾기" 에서는 단어 한나가 여러 번 일치하는 경우를 살펴보았다. 거기서 설명한 대로, \\d+_는 하나 이상 연속된 숫자와 일치하고, https?:\\/\\/는 http:// 나 https:// 와 일치한다. 이 두 예에서 (사실 모든 경우에) 물음표(?), 별표(*), {2} 같은 반복 메타 문자는 자기 바로 샆에 있는 문자나 메타 문자에 적용한다. 예를 들어 HTML 개발자는 단어 사이에 공백을 확실히 유지할 목적으로 주로 강제 공백을 단어 사이에 넣는다. 이제 이런 강제공백을 다른 것으로 대체하고자, HTML에서 반복해 나오는 강제 공백을 모두 찾아야 한다고 가정해 보자. 다음 예제를 보자.

> 예문

Hello, my name is Ben\&nbsp;Forta, I am  
the author of multiple books on SQL (including  
MySQL, Oracle PL/SQL, and SQL Server T-SQL),  
Regular\&nbsp;\&nbsp;Expressions, and other subjects.

> Regex

\&nbsp;{2,}

> 결과

Hello, my name is Ben\&nbsp;Forta, I am  
the author of multiple books on SQL (including  
MySQL, Oracle PL/SQL, and SQL Server T-SQL),  
Regular\&nbsp;\&nbsp;Expressions, and other subjects.

> 분석

\&nbsp;는 HTML 강제 공백을 나타내는 참조 항목이다. \&nbsp;{2,} 패턴은 \&nbsp;와 두개 이상 일치해야 한다. 하지만 일치하지 않았다. 왜일까> {2,}는 바로 앞에 있는 문자가 연속해서 반복된 횟수만을 표현한다. 이 경우에 앞에 놓인 문자가 세미콜론이므로, \&nbsp;;;;;는 일치할 테지만 \&nbsp;\&nbsp;는 일치하지 않는다.

__하위 표현식으로 묶기__

위의 문제를 해결하는 데 하위 표현식이 필요하다. 하위 표현식은 큰 표현식 안에 속한 일부 표현식을 한 항목으로 다루도록 한데 묶은 것이다.  
하위 표현식은 괄호 사이에 사용한다.

_괄호는 메타문자다. 실제 여는 괄호(()와 닫는 괄호())를 찾으려면 각각 \\(와 \\)로 이스케이프 해야 한다._

앞서 나온 예제를 수정해 하위 표현식을 사용하는 방법을 익혀 보자.

> 예문

Hello, my name is Ben\&nbsp;Forta, I am  
the author of multiple books on SQL (including  
MySQL, Oracle PL/SQL, and SQL Server T-SQL),  
Regular\&nbsp;\&nbsp;Expressions, and other subjects.

> Regex

(\&nbsp;){2,}

> 결과

Hello, my name is Ben\&nbsp;Forta, I am  
the author of multiple books on SQL (including  
MySQL, Oracle PL/SQL, and SQL Server T-SQL),  
Regular __\&nbsp;\&nbsp;__ Expressions, and other subjects.

> 분석

(\&nbsp;)는 하위 표현식이며 한 항목으로 취급한다. 따라서 {2,}는 세미콜론이 아니라 이 하위 표현식 전체가 반복하는 횟수를 나타낸다. 

다른 예제를 살펴보자. 이번에는 정규 표현식으로 IP 주소를 찾는다. IP주소는 숫자 네 묶음을 마침표로 구분해 이루어지며 12.123.23.200 같은 형식이다. 각 묶음에는 숫자가 한 자리 숫자부터 세 자리 숫자까지 들어갈 수 있으므로 이 숫자 묶음과 일치시키려면 패턴을 \\d{1,3}으로 표현한다.

> 예문

Pinging hog.forta.com [12.159.26.200]  
with 32 bytes of data:

> Regex  

\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}

> 결과

Pinging hog.forta.com [__12.159.26.200__]  
with 32 bytes of data:

> 분석

각 \\d{1,3}은 IP 주소 숫자들 가운데 한 묶음과 일치한다. 숫자 네 묶음은 마침표(.)로 구분하므로 \\.로 이스케이프 했다.

최대 세 자리 정수 뒤에 마침표가 오는 \\d{1,3}\\. 패턴 자체도 세 번 반복되므로 반복표현으로 사용할 수 있다.

> 예문

Pinging hog.forta.com [12.159.26.200]  
with 32 bytes of data:

> Regex  

(\\d{1,3}\\.){3}\\d{1,3}

> 결과

Pinging hog.forta.com [__12.159.26.200__]  
with 32 bytes of data:

> 분석

이 패턴도 앞서 본 예제와 마찬가지로 잘 동작하지만, 문법은 다르다. \\d{1,3}\\.을 하위 표현식으로 만들고자 괄호로 감쌌다. (\\d{1,3}\\.){3}은 이 하위 표현식을 세 번 반복하고(IP 주소의 앞에서부터 세 묶음과 일치), \\d{1,3}은 마지막 숫자 묶음과 일치한다.

하위 표현식으로 묶는 방식은 굉장히 중요하다. 그래서 한 가지 예제를 더 추가했다. 이 예제에서는 하위 표현식의 반복을 사용하지 않았다. 이 예제에서는 사용자 기록에서 연도를 일치시키려 한다.

> 예문

ID : 042  
SEX : M  
DOB : 1957-08-17  
Status : Active  

> Regex

19|20\\d{2}

> 결과

ID : 042  
SEX : M  
DOB : __19__ 57-08-17  
Status : Active  

> 분석

이 예제에서는 패턴을 써 네 자리 숫자로 이루어진 연도를 일치시켜야 했다. 더 정확한 결과를 얻고자 앞 두 자리 숫자는 명확아세 19와 20으로 정했다. |는 OR 연산자를 의미한다. 그러므로 19|20은 19 혹은 20과 일치하고, 따라서 19|20\\d{2}는 19나 20으로 시작하는 네 자리 숫자와 일치해야 한다. 그런데 분명 의도한 대로 일치 하지 않았다. 왜일까? OR(|) 연산자는 자신의 왼편과 오픈현에 각각 무엇이 있는지 살펴보는데, 19|20\\d{2}를 19 혹은 20\\d{2}, 즉 \\d{2} 역시 20으로 시작하는 표현 일부로 여겼기 때문이다. 그래서 19와 일치하든지 20으로 시작하는 네 자리 연도와 일치할 텐데, 여기서는 19와 일치했다.

해결법은 19|20을 하위표현식으로 묶는 것이다.

> 예문

ID : 042  
SEX : M  
DOB : 1957-08-17  
Status : Active  

> Regex

(19|20)\\d{2}

> 결과

ID : 042  
SEX : M  
DOB : __1957__ -08-17  
Status : Active  

> 분석

선택 사항이 모두 하위 표현식 안에 있으므로 OR(|) 연산자는 우리가 묶음 안에 있는 숫자 가운데 하나를 일치시키려 한다는 사실을 안다. 그래서 (19|20)\\d{2}는 정확하게 1957과 일치하고, 19 혹은 20 으로 시작하는 다른 네 자리 숫자와도 일치할것이다. 지금으로부터 대략 백 년쯤 시간이 흐른 후에는, 21로 시작하는 연도와도 일치하도록 약간 수정할 필요가 있을 텐데, 이때는 패턴을 (19|20|21)\\d{2}로 바꾸면 된다.

__중첩된 하위 표현식__

하위 표현식을 중첩해(nest) 쓰기도 한다. 사실 하위 표현식은 다른 하위 표현식을 중첩하고 그 하위 표현식은 또 다른 하위 표현식을 중첩하기도 한다.  
어떤 모습인지 알겠는가? 중첩되는 능력 적분에 하위 표현식을 매우 강력한 표현도 만들 수 있다. 하지만 반대로 표현식을 뒤엉키게 해 읽거나 분석하기 어렵고, 그 복잡한 모습에 겂을 먹게 만들기도 한다. 하지만 사실 복잡해 보이도록 중첩된 하위 표현식은 거의 사용되지 않는다.  
중첩된 하위 표현식을 어떻게 사용하는지 알아보고자 IP 주소 예제를 다시 살펴볼 것이다. 다음은 앞서 사용했던 패턴인데, 하위 표현식이 세번 반복된 다음 마지막 숫자가 나타난다.

> Regex

(\\d{1.3\\.}){3}\\d{1,3}

> 분석

이 패턴든 뭐가 잘못되었을까? 문법은 잘못되지 않았다. IP 주소는 실제로 숫자 네 묶음으로 구성되었고, 각 묶음은 한 자리에서 세 자리 숫자이며 마침표로 구분한다. 형식도 맞고, 올바른 IP 주소도 찾아낸다는 점이 문제다.  
IP 주소는 4바이트로 구성되고, 12.123.46.200 으로 나타나는 IP 수조는 바로 이 4바이트를 표현한 것이다. 따라서 IP 주소에서 숫자 네 묶음은 각각 한 바이트 값을 나타내고, 이 값의 범위는 0부터 255 사이에 속한다. 이는 IP 주소에 255보다 큰 숫자는 들어갈 수 없음을 의미한다. 하지만 앞서 본 패턴을 사용하면 356, 700, 999 같이 IP 숫자로 바르지 않은 숫자와도 일치한다.  
유효한 값의 범위를 지정할 수 있으면 매우 좋겠지만, 정규 표현식은 문자를 일치시킬 뿐이지 문자가 의미하는 바에 대해서는 아무런 지식이 없다. 또 수학적 연산을 사용할 수도 없다. 우리가 할 수 있는 일이 있을까? 아마 있을 것이다. 정규 표현식을 만들려면 일치해야 할 것과 일치해서는 안 되는 것을 명확하게 정의해야 한다. 다음은 IP 주소를 구성하는 각 숫자 묶음을 유효한 조합으로 정의하는 규칙히다.

- 모든 한 자리 혹은 두 자리 숫자
- 1로 시작하는 모든 세 자리 숫자
- 2로 시작하면서 두 번째 자리 숫자가 0부터 4 사이인 모든 세 자리 숫자
- 25로 시작하면서 세 번째자리 숫자가 0부터 5 사이인 모든 세 자리 숫자

위와 같이 순서대로 표현하면 실재로 패턴이 명확하게 작동한다. 다음 예제를 살펴보자.

> 예문

Pinging hog.forta.com [12.159.26.200]  
with 32 bytes of data:

> Regex  

(((25[0-5])|(2[0-4]\\d)|(1\\d{2})|(\\d{1,2}))\\.){3}(((25[0-5])|(2[0-4]\\d)|(1\\d{2})|(\d{1,2})))

> 결과

Pinging hog.forta.com [__12.159.26.200__]  
with 32 bytes of data:

> 분석

이 패턴은 제대로 동작하지만, 설명이 약간 필요하다. 이 패턴이 제대로 동작하는 이유는 하위 표현식이 연속해서 중첩되었기 때문이다. 하위 표현식 네 개가 중첩된 (((25[0-5]|(2[0-4]\\d)|(1\\d{2})|(\\d{1,2}))\\.)로 시작한다.  
(\\d{1,2})는 한 자리 혹은 두 자리 숫자, 즉 0부터 99 사이의 숫자와 일치한다. (1\\d{2})는 1로 시작하는 모든 세 자리 숫자(1 뒤에는 두 자리 숫자가 온다), 즉 100부터 199 사이의 숫자와 일치한다. (2[0-4]\\d)는 200 부터 249 사이의 숫자와 일치한다. (25[0-5])는 250부터 255 사이의 숫자와 일치한다. 여기에 나온 하위 표현식은 더 큰 하위 표현식으로 묶이고 이렇게 묶인 하위 표현식 사이에는 OR(|) 연산자가 위치한다. OR(|)연산자를 통해 전부가 아니라 네 가지 하위 표현식 가운데 하나와만 일치한다. 숫자의 범위가 나온 다음에는 \\/가 마침표(.)와 일치하고 이렇게 설정된 모든 숫자 범위와 \\. 를 또 다른 하위 표현식으로 묶어 {3}으로 세 번 반복한다. 마지막으로 IP 주소의 마지막 숫자와 일치하는 숫자 범위를 반복한다(이번에는 마지막에 \\.가 없다). 데 묶음의 범위를 각각 0에서 255 사이로 제한하여 이 패턴은 실제로 올바른 IP 주소와는 일치하고 바르지 않은 주소는 거부한다.

앞에서 설명한 것처럼, 네 가지 표현식에 대해 논리적인 순서는 의미가 없다. 다음을 확인해 보자

> 예문

Pinging hog.forta.com [12.159.26.200]  
with 32 bytes of data:

> Regex  

(((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))\\.){3}((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))

> 결과

Pinging hog.forta.com [__12.159.26.20__ 0]  
with 32 bytes of data:

> 분석

이번에는 마지막 0이 일치하지 않았다. 왜 그럴까? 패턴이 왼쪽에서 오른쪽으로 평가 되므로, 일치하는 식이 네 개 있다면, 첫 번째 식을 시도하고, 두 번째 식을 시도하는 식으로 일치한다. 만약 패턴이 일치하면 다른 선택 사항은 시도되지 않는다. 이 예제에서 (\\d{1,2})는 마지막 200의 20에 일치해서, 다른 옵션(여기에 필요한 마지막(25[0-5]) 패턴을 포함해서)은 평가되지 않았다.

## 8장 역참조 사용하기

__역참조 이해하기__

역참조가 언제 필요한지 이해하는 가장 좋은 방법은 예제를 보는 것이다. HTML 개발자는 웹 페이지에서 해더 텍스트를 정의하고 만들고자, 해더 테그를 사용한다. 해더 태그는 \<h1\>부터 \<h6\>까지 있으며, 이에 대응하는 종료 태그를 함께 사용한다. 단계에 상관없이 헤더를 모두 찾아야 한다고 생각해 보자. 다음 예제를 보자.

> 예문

\<body\>  
  \<h1\>Welcome to my Homepage\</h1\>  
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
\</body\>  

> 정규 표현식

<[hH]1>.*<\\/[hH]1>

> 결과

\<body\>  
  __\<h1\>Welcome to my Homepage\</h1\>__  
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
\</body\>  

> 분석

<[hH]1>.*<\\/[hH]1> 패턴은 첫 번째 헤더(\<h1\>부터 \</h1\>까지)와 일치하고, HTML은 대소문자를 가리지 않으므로 \>h1\>과도 일치할 것이다. 하지만 여섯 개 수준의 헤더를 모두 썼을지도 모르는데, 여기 쓰인 헤더를 모두 찾으려면 어떤 패턴을 써야 할까?

> 예문

\<body\>  
  \<h1\>Welcome to my Homepage\</h1\>  
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
\</body\>  

> 정규 표현식

<[hH][1-6]>.*?<\\/[hH][1-6]>

> 결과

\<body\>  
  __\<h1\>Welcome to my Homepage\</h1\>__  
  __\<h2\>SQL\</h2\>__  
  Information about SQL.  
  __\<h2>Regex\</h2\>__  
  Information about Regular Expressions.  
\</body\>  

> 분석

<[hH][1-6]>은 모든 헤더의 시작 태그(예제에서는 \<h1\>과 \<h2\>)와 일치하고, <\\/[hH][1-6]>은 모든 헤더의 종료 태그와 일치하여 제대로 동작하는 것처럼 보인다.

여기서 탐욕적 수량자가 아니라 개으른 수량자를 사용했음에 유의하자.

성공했을까? 아니다. 다음 예제를 살펴보자

> 예문

\<body\>  
  \<h1\>Welcome to my Homepage\</h1\>  
  \<h2\>SQL\</h2\>  
  Information about SQL.  
  \<h2>Regex\</h2\>  
  Information about Regular Expressions.  
  \<h2>This is not valid HTML</h3\>  
\</body\>  

> 정규 표현식

<[hH][1-6]>.*?<\\/[hH][1-6]>

> 결과

\<body\>  
  __\<h1\>Welcome to my Homepage\</h1\>__  
  __\<h2\>SQL\</h2\>__  
  Information about SQL.  
  __\<h2>Regex\</h2\>__  
  Information about Regular Expressions.  
  __\<h2>This is not valid HTML</h3\>__  
\</body\>  

> 분석 

해더 태그가 \<h2\> 로 시작해 \<h3\>으로 끝나 올바른 형식이 아니지만, 패턴과 일치한다.

문제는 두 번째 태그(종료 태그)가 일치할 때 첫 번째 태그(시작 태그)가 어떤 텍스트인지 알 수 있는 정보가 없다는 점이다. 이런 경우에 역참조가 매우 유용해 진다.

__역참조로 찾기__

해더 문제는 잠시 후에 다시 다루기로 하다. 지금은 더 간단하지만, 역참조를 사용하지 않고는 절대 풀 수 없는 예제를 살펴볼 것이다.  
한 문장이 있고, 이 문장 안에 반복해 나오는 문자, 바로 실수로 같은 단어를 두 번 입력한 오자를 모두 찾고 싶다고 가정해 보자. 두 단어가 일치하는지 알려면 먼저 나온 단어가 무엇인지 반드시 알고 있어야 한다. 역참조는 정규 표현식 패턴으로, 앞서 일치한 부분을 다시 가리킨다(이 경우에는 먼저 일치한 단어를 말한다.)  
가장 좋은 방법은 직접 사용해 보면서 이해하는 것이다. 다음 예제에는 반복해 나오는 단어가 세 가지 있고, 이 세 단어를 모두 찾아야 한다.

> 예문

This is a block of of text,  
serveral words here are are  
repreted, and and they  
should no be.

> Regex

[ ]+(\\w+)[ ]+\\1

> 결과

This is a block __of of__ text,  
serveral words here __are are__  
repreted, __and and__ they  
should no be.

> 분석

패턴이 재대로 동작하는 것 같다. 하지만 어떻게 동작하는 것인까? [ ]+는 공백이 하나 이상 연속되는 경우 일치하고, \\w= 영숫자 문자가 하나 이상 연속되는 경우 일치하며, [ ]+는 그 뒤에 공백이 있을 때 일치한다. 여기서 \\w+를 괄호로 감싸 하위 표현식으로 만들었음에 주목하자. 반복해 일치시키려고 하위 표현식을 사용한 것이 아니다. 반복해서 일치하는 부분도 없다. 여기서는 나중에 일치한 부분을 사용할 수 있도록 표시하여 구별하고자 하위 표현식을 사용했다. 이 패턴에서 마지막 부분인 \\1은 앞서 일치한 하위 표현식을 참조함을 의미하고, 따라서 (\\w+)와 일치한 문자는 \\1과도 일치한다.

\\1은 정확히 무엇을 뜻할까? \=\1은 패턴에서 처음 사용한 하위 표현식과 일치한다는 뜻이다. \\2는 두 번째, 그리고 \\3은 세 번째 사용한 하위 표현식과 일치하는 식이다. 따라서 
[ ]+(\\w+)[ ]+\\1 은 앞서 나온 예제에서 보듯이 어떤 단어가 일치하고, 그다음에는 같은 단어가 반복해 나와야만 일치한다.


## 9장 전방탐색과 후방탐색
## 19장 조건 달기
## 11장 정규 표현식으로 해결하는 일반적인 문제들
## 부록 많이 쓰는 애플리케이션과 언어에서 활용하는 정규 표현식
