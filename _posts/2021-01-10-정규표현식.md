---
title: 10분 정규 표현식
date : 2021-01-10
categories : review
---

# 손에 잡히는 10분 정규 표현식

## 1장 정규 표현식 소개
직관 적이지 않지만 간단한 문제를 풀때 코드를 줄일 수 있다.

> 정규 표현식은 어디에 사용하는가?
- 검색
- 치환

---

## 2장 문자 하나 찾기

**1.문자 그대로 찾기**

문장 자체도 정규식이라고 볼수 있다

> 예문  

hello, my name is Ben. please visit ...
> Regex

Ben
> 결과

hello, my name is  __Ben__. please visit ...

> 추가

자바스크립트에서는 일치된 결과물을 모두 담은 배열을 반환하고자 할때, `g`(Global:전역) 플레그를 사용한다.



__2.모든 문자 찾기__

마침표(.)는 어떠한 문자나 알파벳, 숫자, 문장 부호로 쓰인 마침표(.)차체와도 일치한다.

> 예문  
 
saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls   

> Regex

sales.
> 결과

__sales1__.xls   
orders3.xls   
__sales3__.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls

>분석

여기서 사용한 sales.라는 정규 표현식은 sales로 시작하고, sales 바로 뒤에 아무문자가 하나 더 붙는 파일명을 모두 찾는다.

마침표(.)는 어떠한 문자나 알파벳, 숫자, 심지어 문장 부호로 쓰인 마침표(.)자체와도 일치한다.


.a. 다음에 바로 마침표가 따라오는 문자열과 일치시키려면 어떨게 해야할까?

__특수문자 찾기__

마침표(.)는 정규 표현식에서 특별한 의마가 있다. 따라서 여러분이 마침표(.)를 찾으려고 한다면, 정규 표현식에세 특별한 의미의 마침표(.)가 아니라 지짜 마침표(.)를 찾고 싶다고 알려 줘야 한다. 그러려면 마침효(.)앞에 역슬레시(\\)를 문자를 붙이면 된다. 역슬래시(\\)는 __메타 문자__(일반적으로 문자 그대로 사용되지 않고 특별한 의미를 지니는 문자를 칭한다)다. 따라서 마침표(.)는 모든 문자와 일치하디만, \\.는 마침표(/)문자 자체와 일치한다는 의미다.

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls   

> Regex

.a.\\.

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
__na1.__xls   
__na2.__xls   
__na3.__xls  

> 분석

.a.\\.로 해결되었다. 첫 번째 마침표(.)는 n 혹은 s와 일치하였다. 두 번째 마침표(.)는 1 혹은 2와 일치하였으며, \\.는 파일명과 확장자를 구분하는 마침표(.)와 일치하였다.

`역슬레시 자체를 찾고 싶을 경우 \\\이라고 쓴다.`

---

## 3장 문자 집합으로 찾기

문자집합을 사용하면 특정 문자들과 문자 번위를 일치시킬 수 있다.

__여러 문자 중 하나와 일치시키기__

마침표(.)는 어떤 문자든지 문자 하나와 일치한다. 하지만 만약 이전 예제에서 `cal1.xls` 를 제외한 , 
`na`와 `sa` 만을 찾고 싶을 때는 어떨게 할 것인가?

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls 
ca3.xls   

> Regex

[ns]a.\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
__na1.xls__   
__na2.xls__   
__na3.xls__   
ca3.xls  

> 분석

정규 표혁인시 [ns] 로 시작한다. 이 패턴은 ns이나 s 중 한 문자와 일치하며, c나 다른 문자와는 일치하지 않는다. 대괄호([])는 집합을 의미하므로 대괄호 자체는 어떤 문자와도 일치하지 않는다. 문자 a는  a와 일치하고 마침표(.)는 모든 문자와 일치한다.

문자 집합은 흔희 대소문자를 구별하지 않고 검색하거나 검색할 부분의 특정 영역만 대소문자를 구별하지 않을 때 사용한다.

> 예문

The parase "regulas expression" is often  
abbreviated as Regex or regex

> Regex

[Rr]eg[Ee]x

> 결과

The parase "regulas expression" is often  
abbreviated as __Regex__ or __regex__

> 분석

여기서 사용한 패턴에는 문자 집합이 두 개 있가. [Tr]은 R이나 r과 일치하고, [Ee]는 E나 e와 일치한다. 이런 식으로 `Regex`와 `regex` 둘 다 일치시킬 수 있다. 하디만 REGEX와는 일치하지 않는다.

__문자 집합 범위 사용하기__

마지막으로 사용한 패턴 [ns]a.\\.xls 에는 또 다른 문제가 있다. 만약 `sam.xls` 라는 파일이 있다면, 어떻게 할 것인가?
문자 집합을 사용해 이 문제를 해결할 수 있다.

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
na1.xls   
na2.xls   
na3.xls 
ca3.xls  

> Regex

[ns]a[0123456789]\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
sam.xml   
__na1.xls__   
__na2.xls__   
__na3.xls__  
ca3.xls  

> 분석

이번에 수정한 정규 표현식에서는 첫 글자가 n이나 s와 일치하고, 두 번째 글자는 a, 세 번째 글자는 숫자([0123456789]에 소한 숫자)와 일치한다. sam.xls는 일치하지 않았다는 점을 확인하자.
아래는 하이픈을 통한 범위를 설정하여, 같은 결과를 표현한다.


> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls  
sam.xml     
na1.xls   
na2.xls   
na3.xls 
ca3.xls  

> Regex

[ns]a[0-9]\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls   
sam.xml   
__na1.xls__   
__na2.xls__   
__na3.xls__  
ca3.xls  

> 분석

범위를 단지 숫자에만 쓸 수 있는 것은 아니다. 다음과 같은 범위에서도 모두 사용할 수 있다.

- A-Z는 A부터 Z사이에 있는 모든 대문자와 일치한다
- a-z는 a부터 z사이에 있는 모든 소문자와 일치한다
- A-z는 아스키 문자 A와 아스키 문자 z 사이에 있는 모든 문자와 일치한다.(이 패턴은 비추천한다. Z와 a 사이에는 대괄호나([) 캐럿(^)도 포함되기 때문이다.)

아래의 예는 RGB 값을 찾는 방법이다

> 예문

body{  
    background-color : #fefbd8;  
}  
h1{  
    background-color : #fefbd8;  
}  

> Regex

\#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]

> 결과


body{  
    background-color : __#fefbd8__;  
}  
h1{  
    background-color : __#fefbd8__;  
}  

> 분석

여기서 사용한 패턴에서는 샵(#) 문자가 문자 그대로 일치하고, [0-9A-Fa-f] 문자 집합이 여섯 번 반복된다.
이 패턴은 숫자나 A와 F사이의 문자이며, 대소문자를 구별하지 않는다.

__'제외하고' 찾기__

멸 개만 빼고 대부분의 문자를 포함해야 할 경우에는 패턴이 너무 실어지므로 원하는 문자를 모두 나열하기보다는 캐럿(^) 문자를 써 제외할 문자 집합을 지정한다.

> 예문

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls  
sam.xml     
na1.xls   
na2.xls   
na3.xls 
ca3.xls  

> Regex

[ns]a[^0-9]\\.xls

> 결과

saled1.xls   
orders3.xls   
sales3.xls   
apac1.xls   
europe2.xls  
__sam.xml__     
na1.xls   
na2.xls   
na3.xls 
ca3.xls  

> 분석

[0-9]는 모든 숫자와 일치한다 [^0-9]는 정해징 범위 내에 있는 수자와 일치하지 않는다.   
즉, [ns]a[^0-9]\\.xls는 na1.xls, na2.xls, na3.xls 와는 일치하지 않고, sam.xls와 일치한다.

---
## 4장 메타 문자 사용하기

_이스케이프 다시 살펴보기__

메타 문자는 정규 표션식 안에서 특별한 의미가 있다. 마침표(.)는 메타 문자로, 어떤 문자든 문자 하나와 일치한다. 이와 유사하게, 여는 대괄호([)도 집합의 시작을 나타내는 메타 문자다

메타 문자들은 정규 표현식에서 특별한 의미가 있으므로 자기 자신을 문자 그대로 표현할 수 없다. 여는 대괄호([)가 여는 대괄호([))와 일치하지 않는다는 의미다.

다음 예제를 보자. 이 정규 표현식에서는 여는 대괄호([)와 단는 대괄호(])를 포함하는 자바스크리ㅂ트 배열을 찾으려 한다.

> 예문

var myArray = new Array();  
...  
if(myArray[0] == 0){}  
...  

> Regex

myArray\\[0\\]

> 결과

var myArray = new Array();  
...  
if(__myArray[0]__ == 0){}  
...  

> 분석

이이 예제에서 쓴 정규 표현식은 다소 불필요해 보인다. 단순한 텍스트 검색만으로도 충분희 만족스러운 결과를 더 쉽게 얻을 수 있다. 하지만 단순히 myArray[0]뿐만 아니라 myArray[1] 과 같은 배열도 찾으려면 어떻게 해야 할지 상상해 보자. 이때는 정규 표현식을 사용하는 편이 더 유용하다. 여는 대괄호([)와 닫는 대괄호(])는 이스케이프 하고 두 문자 사이에 원하는 문자들이 일치하도록 조건을 정하면 된다. 만약 배열 요소를 0부터 9까지 일치시키고 싶다면 다음과 같이 정규 표현식을 작성할 수도 있다.

myArray\\[[0-9]\\]

역슬레시(\\)는 메타 문자들을 이스케이프 하는 데 사용된디. 이 말은 열슬레시(\\)도 메타 문자이며, 다른 메타 문자들을 이스케이프 하는데 사용된다는 뜻이다. 
 다음에 나온 간단한 예제에선 윈도우에서 볼 수 있는 역슬래시(\\)를 이용한 파일 경로다. 이 경로를 리눅스에서 사용한다는 가정하에 모든 역슬래시를 찾아 슬래시로 변경해 보자

> 예문

\home\ben\sales\

> Regex

\\\

> 결과

__\\__ home __\\__ ben __\\__ sales __\\__

> 분석

전규 표현식에 역슬래시(\\)만을 사용했다면, 아마 에러가 발생했을 것이다. 정규 표현식 분석기가 정규표현식을 다 작성하지 않았다고 판단하기 때문이다. 그러니 정규 표현식에서는 역슬래시(\\)위에 반드시 다른 문자를 함께 써넣어야 한다.

__공백 문자 찾기__

메타 문자는 일반적으로 두 가지 범주로 나뉜다. 마침표(.)처럼 텍스트와 와 일치하는 문자와 여는 대괄호([)나 닫는 대괄호(])처럼 정규 표현식문법의 일부로 쓰는 문자다. 이제 공백 문자를 살펴보면서 두 가지 유형의 메타 문자들을 더 많이 접할 것이다. 우선 공백 메타 문자부터 시작 해 보자.

 정규 표현식 검색을 수행할 때, 여러분은 눈에 보이지 않지만 텍스트에 포함되는 공백 문자를 찾아야 할 때가 있을 것이다. 꼼수를 이용하지 않고 이런 문자를 정슈 표현식에 직접 써넣기는 어려우므로 아래ㅠㅛ와 같은 특수한 메타 문자들을 사용할 수 있다.

 |메타 문자 | 설명|
 |:--|:--|
 |\[\\b\]|백 스페이스|
 |\\f|페이지 넘김(form feed)|
 |\\n|줄바꿈|
 |\\r|캐리지 리턴|
 |\\t|텝|
 |\\v|수직 텝|

 다음 예제를 보자. 여기에 나오는 예문에는 콤마로 구분된(일반적으로 CSV라고 부른다) 레코드가 담겨 있다. 여러분은 게디어터에 있는 빈 줄을 모두 제거한 다음, 이 레코드를 처리해야한다.

 > 예문

"101","Ben","forta"  
"102","Jim","James"  

"103","Robert","Bet"  

> Regex

\\r\\n\\r\\n

> 결과

"101","Ben","forta"  
"102","Jim","James"  
 
"103","Robert","Bet"  

> 분석

\\r\\n은 줄바꿈과 캐리지 리턴의 조합과 일치한다. 윈도우에서 이 조합은 줄의 끝을 나타내는 데 사용된다.
따라서 \\r\\n\\r\\n을 검색하면, 줄 씉이 연속해서 두 번 나오는 부분과 일치하는데, 이때 줄의 끝이 두번 나온다는 것은 바로 두 레코드 사이에 빈 줄이 있음을 의미한다.

__특정한 문자 형태와 일치시키기__

자주 쓰는 문자 집합들은 특수한 메타 문자로 대신하기도 한다. 이런 메타 문자들을 __문자 클래스__ 라고 부른다. 직접 찾고 싶은 문자들을 열거하거나 범위를 사용하면 되기 때문에, 실제로 클래스 메타 문자를 써야만 하는 경우는 결코 없지만, 일단 사용해 보면 너무나도 유용함을 알게 된다.

__숫자와 숫자가 아닌 문자 찾기__

|메타 문자| 설명|
|:--|:--|
|\\d| 숫자 하나([0-9])와 같다|
|\\D| 숫자를 제외한 문자 하나([^0-9])와 같다.|
 
앞선 예문를 수정하여 이 메타문자를 어떻게 쓰는지 확인해보자

> 예문

var myArray = new Array();  
...  
if(myArray[0] == 0){}  
...  

> Regex

myArray\\[\\d\\]

> 결과

var myArray = new Array();  
...  
if(__myArray[0]__ == 0){}  
...  

> 분석

이 정규 표현직은 myArray[1] 과는 일치하지만  myArray[10] 과는 일치하지 않는다.

__영숫자 문자와 영숫자가 아닌 문자 찾기

자주 사용하는 문자 집합이 또 있다. 영숫자 무자로, 대소문자와 소문자를 포함한 알파벳 A부터 Z, 숫자, 밑줄(대개 파일이나 디렉터리 이름, 애플리케리션 변수명, 데이터베이스 객체 이름 등에 사용한다.)을 포함한다.

|메타 문자| 설명|
|:--|:--|
|\\w|대소문자와 밑줄을 포함하는 모든 영숫자[a-zA-Z0-9]와 같다.|
|\\W|대소문자와 밑줄을 아닌 모든 영숫자[^a-zA-Z0-9]와 같다.|

> 예문

12313  
A1C2E3  
480787  
48907  
H1B4F2  
908700  
H1H2H3  

> Regex

\w\d\w\d\w\d

> 결과

12313  
__A1C2E3__  
480787  
48907  
__H1B4F2__  
908700  
__H1H2H3__  

> 분석 

여기서는 메타 문자 \\w와 \\d를 조합한 패턴을 사용했는데, 캐나다 우편번호만을 찾아낸다

__공백 문자와 공백이 아닌 문자 찾기

마지막으로 살펴볼 분류는 공백 클래스다.

|메타 문자| 설명|
|:--|:--|
|\\s|모든 공백 문자([\\f\\n\\r\\t\\v])와 같다.|
|\\S|공백 문자가 아닌 모든 문자([^\\f\\n\\r\\t\\v])와 같다.|

__16진수나 8진수 표현하기__

__16진수 사용하기__

16진수 같은 앞에 \\x를 붙여 표시한다. 즉, \\x0A는 줄바꿈 문자가 되며 \\n과 기능이 같다.

__8진수 사용하기__

8진수 같은 두 자리나 세 자리 정수 앞에 \\0을 붙여 표시한다. 즉, \\011은 탭 문자이며, \\t와 기능이 같다

__포직스 문자 클래스 사용하기__

포직스 문자 클래스는 줄여 쓰기를 나타내는 또 다른 형태인데, 전부는 아니지만 많은 정규 표현식 구현에서 지원한다.

_자바스크립트는 정규 표현식에서 포직스 문자 클래스를 지원하지 않는다._

[정규표현식](https://www.nextree.co.kr/p4327/)

## 5장 반복찾기

이 장에서는 여러 번 반복해 나타나는 문자나 문자 집합을 어떨게 팢는지 알아본다.

__몇 번 일치하는가?__

이메일 주소와 일치하는 정규 표현직을 작성한다고 생각해 보자. 이메일 주소의 기본 형식은 다음과 같다.

text@text.text

4장에서 배운 메타 문자를 사용해 다음롸 같은 정규 표현식을 만들 수 있다.

\\w@\\w\\.\\w

\\w 문자는 모든 영숫자 문자와 일치한다. 더불어 밑줄도 함께 찾는데, 밑줄 역시 이메일 주소에서 사용하는 문자다. 앳(@)은 이스케이프 하지 않아도 되지만, 마침표(.)는 이스케이프 해야한다.

이 패턴은 문법에 완벽하게 맞는 정규 표현식이긴 하지만 쓸모 없다. 이 패턴으로는  a@b.v 같은 이메일 주소만 찾을 수 있다. 문법은 맞지만, 분명히 유효한 메일 주소는 아니다. 문제는 \\w는 문자 하나하고만 일치하는데, 얼마나 많은 문자를 검사해야 할지 모른다는 점이다. 다음 이메일 주소들은 모두 유효하지만, @ 문자 앞에 나온 문자 수는 서로 다르다.

b@forta.com  
ben@forta.com  
bfort@forta.com  

__하나 이상의 문자 찾기__

문자나 집합에 속한 요소를 하나 이상 찾으려면 간단리 문자 뒤에 더하기(+) 문자를 붙이면 된다. 더하기(+) 문자는 문자가 하나 이상일때 일치한다(최소한 하나와 일치하고, 없을 때는 일치하지 않는다). a가 a를 찾는 데 반해, a+는 하나 이상 연속된 a를 찾는다. 비슷하게 [0-9]는 자릿수가 하나인 숫자를 찾는 데 반해, [0-9]+는 한자리 이상 연속된 숫자를 찾는다.

이번에는 더하기(+)를 사용해 하나 이상의 문자와 일치시키자.

> 예문

Send personal email to ben@forta.com For questions  
about a book use support@forta.com Feel free to send
....

> Regex

\\w+@\\w+\\.\\w+

> 결과

Send personal email to __ben@forta.com__ For questions  
about a book use __support@forta.com__ Feel free to send
....

다하기(+)는 문자 집합이 하나 이상인 경우에도 사용한다. 다음 예제로 실험해 보자. 정규 표현식은 같지만 예문이 조금 다르다.

> 예문

Send poersonal email to ben@forta.com or  
ben.forta@forta.com. For questions about a   
book use support@forta.com. If your message  
is urgent try ben@urgent.forta.com. Feel  
....

> Regex

\\w+@\\w+\\.\\w+

> 결과

Send poersonal email to __ben@forta.com__ or  
ben.__forta@forta.com__. For questions about a   
book use __support@forta.com__. If your message  
is urgent try __ben@urgent.forta__.com. Feel  
....

> 분석

정규 표현식으로 주소를 네가지 찾았지만, 그중 두 개는 제대로 검색되지 않았다.  
\\w+@\\w+\\.\\w+는 앳(@) 앞에 나오는 마침표(.)를 일치시키지 못하고, 앳(@) 귀에 문자열을 둘로 나누는 마침표(.)는 하나만 검색되도록 설정되었기 때문이다. \\w는 영숫자와 일치하지만, 문자열 중간에 있는 마침표(.)와는 일치하지 않기 때문에 ben.forta@forta.com리 올바른 이메일 주소라 해도, 이 정규 표현식은 ben.forta 대신 forta만 찾는 것이다.

이제 \\w나 마침표(.) 와 일치하도록, 정규 표현식 규칙에 따라 [\\w.] 집합을 정의해야 한다. 

> 예문 

Send poersonal email to ben@forta.com or  
ben.forta@forta.com. For questions about a   
book use support@forta.com. If your message  
is urgent try ben@urgent.forta.com. Feel  
....

> Regex

[\\w.]+@[\\w.]+\\.\\w+

> 결과

Send poersonal email to __ben@forta.com__ or  
__ben.forta@forta.com__. For questions about a   
book use __support@forta.com__. If your message  
is urgent try __ben@urgent.forta.com__. Feel  
....

> 분석

[\\w.]+를 쓰니 문자, 밑, 마침표(.)가 하나 이상 일치해 ben.forta를 제대로 찾아 냈다.
 [\\w.]+는 앳(@) 뒤에서 더 깊은 단계의 도메인 주소를 찾기도 했다.

__문자가 없거나 하나 이상 연속하는 문자 찾기__

더하기(+)는 하나 이상 연속된 문자를 찾는다. 문자가 없는 경우는 아예 찾지 못하고, 최소한 하나는 일치해야 한다. 하지만 있을 수도 있고 없을 수도 있는 문자와 일치시키려면 어떻게 해야 할까?  그럴 때는 메타문자인 별표(\*)를 사용하면 된다. 별표(\*)는 더하기(+)와 거의 비슷하게 사용하는데, 문자나 집합 바로 뒤에 두면 찾고자 하는 문자나 집합이 없는 경우 또는 하나 이상 연속하는 경우에 일치한다. 따라서 B.* Forta  패턴은 B Forta, B. Forta, BenForta 같은 조합과도 일치한다.
앞서 나온 이메일 예제를 수정해 별표(\*)의 사용법을 살펴보자.

> 얘문

Hello .ben@forta.com is my email address.

> Regex

[\\w.]+@[\\w.]+\\.\\w+

> 결과

Hello .__ben@forta.com__ is my email address.

> 분석

패턴이 더 복잡해 진 것 같지만 실재로는 그렇지 않다. \\w|는 마침표를 제외한 영숫자 문자와 모두 일치한다.(즉, 이메일 주소의 시작으로 유효한 문자를 말한다.) 우선 첫 문자가 유효하면, 그 다음에는 마침표(.)가 하나 나오거나 문자가 더 나올 수도 있다. 사실 이런 이멤일 주소는 없을지도 모른다. [\\w.]*는 문자가 없는 연우를 포함해 여러 개의 영숫자 혹은 마침표(.)와 일치하는데, 이것이 우리가 찾고자 한 텍스트다.

__문자가 없더나 하나인 문자 찾기__

매우 유용한 메타 문자로 물음표(?)가 있다. 별표(\*)처럼 물음표(?)는 문자가 있는 경우 일치하고 문자가 없어도 일치하디만, 별표(\*)와 달리 문자나 집합이 없거나 하나만 있는 경우에만 일치하며, 하나 이상은 일치하지 않는다. 즉, 물음표(?)는 문자 묶음 안에서 있는지 없는지 확실하지 않은 특정한 문자를 하나만 찾을 때 매우 유용하다.

> 예문

The URL is http://www.forta.com/, to connect  
securely user https:///www.forta.com/ instead.

> Regex

http:\\/\\/[\\w.\\/]+

> 결과

The URL is __http://www.forta.com/__, to connect  
securely user https:///www.forta.com/ instead.

> 분석

이 패턴은 URL을 일치시키고자 http:\\/\\/를 썼고, 문자 그대로 찾기 때문에 오직 해당 문자와만 일치한다. 이어서 [\\w.\\/]+가 영숫자 문자, 마침표(.), 슬러시(/)로 이루어진 집합의 구성 요소 가운데 하나 이상과 일치한다. 이 패턴은 처음에 있는 http:// 로 시작하는 URL과는 일치하지만 두 번째에 있는 https:// 로 시작하는 URL과는 일치하지 않는다. 그렇다고 s가 없더나 하나 이상 연속될 대 일치하는 s*가 적합하지도 않다. httpssssss:// 도 일치하기 때문이다.

해결방법은 다음 예제처럼 s?를 쓰는 것이다.


> 예문

The URL is http://www.forta.com/, to connect  
securely user https:///www.forta.com/ instead.

> Regex

http?:\\/\\/[\\w.\\/]+

> 결과

The URL is __http://www.forta.com/__, to connect  
securely user __https:///www.forta.com/__ instead.

> 분석

이 패턴은 https?:\\/\\/로 시작한ㄷ. 물음표(?)는 자기 앞에 있는 문자가 없거나 그 문자가 하나만 있는 경우 일치한다. 여기서는 s인데, https?:// 는 http:// 나 https:// 와는 일치하지만, 그 외에는 일치하지 않는다.

덧붙여 물음표(?)를 쓰면 4장에서 언듭한 문제도 해결된다. 우리는 \\r\\n 으로 줄의 끝을 일치시키는 예제를 살펴봤는데, 유닉스나 리눅스 환경에서는 \\r 은 제외하고 \\n 만 사용한다고 언급했다. 이때 \\n 앞에 \\r이 있을 경우에만 일치시키는 것이 이상적인 해결책일 것이라고도 했다. 정규표현식을 약간 수정했다.

> 예문

"101","Ben","forta"  
"102","Jim","James"  

"103","Robert","Bet"  

> Regex

[\\r]?\\n[\\r]?\\n

> 결과

"101","Ben","forta"  
"102","Jim","James"  
 
"103","Robert","Bet"  

> 분석

[\\r]?\\n은 \\r이 있을 경우에는 \\r과 일치하고, \\n과는 반드시 일치한다.

__구간 지정하기__

더하기(+), 별표(*), 물음표(?)는 정규 표현식을 쓰면서 발생하는 많은 문제를 해결해 주지만, 충분하지 않은 때도 있다. 다음과 같은 상황을 생각해 보자.

- 더하기(+)와 별표(*)는 일치하는 문자 수에 제한이 없다. 문자가 최대 몇 개까지 일치하는지는 정할 수 없다.
- 더하기(+), 별표(*), 물음표(?)가 일치하는 무자 수의 최솟값은 0이나 1이다. 일치하는 문자 숫의 최솟값을 명시적으로 정의할 수 없다.
- 정확히 원하는 만큼만 일치하도록 문자 수를 정의할 수 없다.

이런 문제들을 해결하고, 연혹하는 문자를 찾을 때 검색 조건을 더 구체적으로 지정하고자 정규 표현식에서는 __구간__ 을 사용한다. 구산은 중괄호({}) 안에 표시한다.

__정확한 구간 찾기__

문자가 일치하는 수를 정확히 정하려면 여는 중괄호({)와 닫는 중괄호(}) 사이에 숫자를 넣는다. 즉, {3}은 바로 앞에 있는 문자나 문자 집합이 세 번 연속해서 일치하는지 확인한다. 만약 요소가 두 개만 있다면, 패턴이 일치하지 않는다.

 3장과 4장에서 활용한 RGB예제를 수정해 어ㄸ러게 작동하는지 알아보자. 여러분은 RGB값이 두 개씩 ㅅ짝지어진 16진수 숫자 집합 세개로 이루어짐을 기억할 것이다. 처음에는 RGB 값을 찾을 때 다음과 같은 패턴을 사용했다.

\#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]

이 예제에 구간 찾기를 사용해 보겠다

> 예문

body{  
    background-color : #fefbd8;  
}  
h1{  
    background-color : #fefbd8;  
}  

> Regex

\#[0-9A-Fa-f]{6}

> 결과


body{  
    background-color : __#fefbd8__;  
}  
h1{  
    background-color : __#fefbd8__;  
}  

> 분석

[0-9A-Fa-f]는 하나의 16진수 문자와 일치함을, {6}은 이를 여섯번 반복함을 뜻한다.

__범위 구간 찾기__

값(일치 횟수)의 범위, 다시 말해 일치시키려는 요소(instance) 수의 최솟값과 최댓값을 나타낼 때도 구간을 사용한다. 범위는 {2,4}처럼 표현한다. 최소 두 번에서 최대 네 번까지 일치시킨다는 의미다. 날짜 형식을 찾는 정규 표현식이 범위 구간 찾기를 보여주는 예로 적정하다. 

> 예문

4/8/17
10-6-2020
2/2/2
01-01-01

> Regex

\\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{2,4}

> 결과

__4/8/17__
__10-6-2020__
2/2/2
__01-01-01__

> 분석

여기에는 사용자가 입력창에 써넣었을 만한 값이 나열되었다. 이 값들은 날짜 형식에 맞게 입력되어야 한다. \\d{1,2}는 한 자리 혹은 두 자리 숫자와 일치해 날짜와 월을 검사하고 \\d{2,4}는 연도와 일치하며, [-\\/]는 날짜 구분선인 하이픈(-)이나 슬러시(/)와 일치한다. 결과적으로 연도가 너무 짧아서 일치하지 않은 2/2/를 제외하고 날짜가 세개 일치했다.

중요한 것은 이 패턴으로는 날짜가 옳은지 검사하지는 못한다는 점이다. 54/67/9999 처럼 값이 틀려도 검사를 통과한다. 이 패턴은 날짜형식에 맞는지만 검사할 뿐이다. 그래서 이 단계는 주로 날짜 자체가 유효한지 검사하기 전에 이루어진다.

__'최소' 구간 찾기__

마지막으로 구간 검색은 최댓값 없이 찾고자 하는 요소의 최솟값을 지정할 수도 있다. 이 패턴에서 쓴 구간 문법은 범위와 비슷하지만, 최댓값이 없다는 점만 다르다. 예를 등러 {3,}은 최소한 요소가 세번 일치함을 의미한다. 다시 말해, 요소가 세 번 이상 일치한다는 것이다. 다음 예제에서는 이 장에서 배운 것들을 조합해 보았다. 이 예제에는 주문 금액이 100달러 이상인 주문을 모두 찾는 정규 표현식을 썼다.

> 얘문

1001: $496.80
1002: $1290.80
1003: $26.80
1004: $613.80
1005: $7.80
1006: $414.80
1007: $25.80

> Regex

\\d+:\\$\\d{3,}\\.\\d{2}

> 결과

__1001: $496.80__
__1002: $1290.80__
1003: $26.80
__1004: $613.80__
1005: $7.80
__1006: $414.80__
1007: $25.80

> 분석

예문은 주문 번호와 주문 금액을 보여 주는 보고서다. 이 정규 표현식은 처음에 \\d+:를 써 주문 번호를 찾는다. 주문 번호를 포함한 전체 행이 아니라, 단순히 금액만 찾고 싶다면 이 패턴을 빼도 무방하다. 

\\$\\d{3,}\\.\\d{2} 는 금액과 일치하는 패턴이다. \\$는 달러기호($). \\d{3,}은 최소한 세 자리 숫자(즉, 최소 100달러), \\.은 마침표(.), 마지막으로 \d{2}는 소수점 이하 두 자리 숫자와 일치한다. 이 패턴은 일곱 개 주문 중 네 개와 일치한다.

__과하게 일치하는 상황 방지하기__

물음표(?)는 제한된 범위만큼 일치시키고(없거나 하나만 있는 경우와 일치한다.), 구간을 쓰면 정확히 지정한 만큼 일치하거나 지정한 범위 안에서만 검색을 수행한다. 하지만 이 장에서 소개한 패턴들은 일차하는 횟수에 제한이 없기 때문에 때로는 너무 많이 일치하기도 한다.

 그래서 지금까지 나온 예제는 모두 일치하지 않아도 되는 텍스트까지 과도하게 일치하는 상황이 없도록 주의 깊게 선택했지만, 다음 예제를 생각해 보자. 다음 예문은 웹 페이지의 일부고 HTML 테그인 \<b\> 가 포함되었다. 정규 표현식으로 \<b\> 태그로 둘러싸인 텍스트(형식을 바꾸려고 하는지도 모든다)를 일치시켜야 한다.

 > 예문

This offer is not available to customers
living in \<b\>AK\</b\> and \<b\>HI\</b\>.

> Regex

\<[Bb]\>.*\<\\/[Bb]\>

> 결과

This offer is not available to customers
living in __\<b\>AK\</b\> and \<b\>HI\</b\>__.

> 분석

\<[Bb]\>는 \<b\> 시작 태그와 일치하고, <\\/[Bb]\> 는 \</b\> 종료 태그와 일치한다. 두 경우 모두 대소문자를 구별하지 않는다. 하지만 두 번이 아니라 오직 한 번만 일치했다. .* 는 처음 나온 \<b\>부터 마지막에 나온 \</b\> 사이에 있는 모든 텍스트와 일치하므로 __AK\</b\> and \<b\>HI__ 가 일치한 것이다. 우리가 원하는 텍스트를 포함하긴 하지만, 찾으려 하지 않은 텍스트도 포함했다.

바로 별표(*)와 더하기(+) 같은 메타 문자가 __탐욕적(Greedy)__ 이므로 이는 가능한 가장 큰 덩어리를 찾으려 한다는 뜻이다. 이런 메타 문자는 찾으려는 텍스트를 앞에서부터 찾는 게 아니라, 텍스트 마지막에서 시작해 거꾸로 찾는다. 의도적으로 수량자를 탐욕적으로 설계했기 때문이다.

 하지만 만약 우리가 탐욕적 일치를 원하지 않는다면 어떻게 해야 할까? 탐욕적 수량자를 __게으른(Lazy)__ 수량자로 바꿔 이 문제를 해결한다.  
 '게으른'이라고 부르는 이유는 문자가 최소로 일치하기 때문이다. 게으른 수량자는 기존 수량자 뒤에 물음표(?)를 붙여서 표현한다. 아래 표는 탐욕적 수량자에 대응되는 게으른 수량자 이다. 

|탐욕적 수량자|게으른 수량자|
|:--|:--|
|*|*?|
|+|+?|
|{n,}|{n,}?|

*?는 별표(\*)의 게으른 수량자인데, 이 문자를 이용해 앞서 나온 예제를 수정해 보자

 > 예문

This offer is not available to customers
living in \<b\>AK\</b\> and \<b\>HI\</b\>.

> Regex

\<[Bb]\>.*?\<\\/[Bb]\>

> 결과

This offer is not available to customers
living in __\<b\>AK\</b\>__ and __\<b\>HI\</b\>__.

> 분석

게으른 수량자인 *?를 사용해서, 두 부분을 따로 일치시켰다.

## 6장 위치 찾기

이따금 텍스트 영역 내에 있는 특정 위치에서 텍스트를 찾아야 할 때도 있다. 그러려면 위치 찾기가 필요하며, 이 장에서는 바로 위치 찾기를 배울 것이다.

__경계 지정하기__

위치 찾기는 텍스트 문자열 안에서 만드시 일치해야 하는 위치를 지정할 때 사용한다. 위치 찾기가 왜 필요한지 이해하기 위해 다음 예제를 살펴보자

> 예문

The cat scattered his food all over the room.

> Regex

cat

> 결과

The __cat__ s __cat__ tered his food all over the room.

> 분석

cat 패턴은 cat이 있는 부분과 모두 일치한다. 심지어  scattered라는 단어 사이에 있는 cat 과도 일치한다. 사실 이런 결과를 바랐을 수도 있다. 하지만 그렇지 않을 가능성이 더 크다. 만약 우리가 cat을 모두 dog로 치환화려고 검색했다면 다음과 같은 말도 안되는 결과를 얻게 된다.

The dog sdogtered his food all over the room.

이렇 때 __경계__ 를 사용하거나 패턴 앞이나 뒤에 특정한 위치 혹은 경계를 나타내는 메타 문자를 사용하면 된다.

__단어 경계 지정하기__

처음으로 알아볼 경계는 가장 흔하게 쓰는 방법인데,  \\b로 표시하는 단어 경계다. 단어 경계라는 이름에서 유추해 볼 수 있듯이, \\b는 단어의 시작이나 마지막을 일치시킬 때 사용한다.

 \\b를 어떻게 쓰는지 알아보고자 앞서 본 예제를 다시 사용할 텐데, 이번에는 경계를 지정하겠다.

> 예문

The cat scattered his food all over the room.

> Regex

\\bcat\\b

> 결과

The __cat__ scattered his food all over the room.

> 분석

cat이라는 단어 앞뒤는 빈칸인데 여기서 빈칸은 단어와 단어를 구분하는 문자들 가운데 하나이므로,  \\bcat\\b와 일치한다. 하지만 scattered라는 단어 사이에 있는 cat은 앞에는 s, 뒤에는 t가 이어서 나와 둥 가 \\b와 일치하지 않으므로 일치하지 않는다. 

중요한 것은 완전한 단어 하나를 일치시키고자 한다면, 일치시키고자 하는 단어 앞뒤에 모두 \\b를 붙여야 한다는 점이다. 다음 예제를 살펴보자.

> 예문

The captain wore this cap and cape proudly as  
he sat listening to the recap of how his  
crew saved the men from a capsized vessel.

> Regex

\\bcap

> 결과

The __cap__ tain wore this __cap__ and __cap__ e proudly as  
he sat listening to the recap of how his  
crew saved the men from a __cap__ sized vessel.

> 분석

\\bcap 패턴은 cap으로 시작하는 모든 단어와 일치한다. 따라서 단어가 총 네 새 일치했지만, 그중 세 단어는 cap이 포함된 다른 단어다.

다음은 같은 예제지만, \\b를 뒤에만 붙인 것이다.


> 예문

The captain wore this cap and cape proudly as  
he sat listening to the recap of how his  
crew saved the men from a capsized vessel.

> Regex

cap\\b

> 결과

The captain wore this __cap__ and cape proudly as  
he sat listening to the re __cap__ of how his  
crew saved the men from a capsized vessel.

> 분석

cap\\b는 cap으로 끝나는 단어와 모두 일치한다. 따라서 단어가 총 두 개 일치했지만, 그중 하나는 cap을 포함하는 다른 단어다. 만약 cap만으로 구성된 단어만 일치시키려 한다면, 패턴을 \\bcap\\b로 작성해야 한다.

특별히 단어 결계외 일치시키고 싶지 않을 땐, \\B를 사용한다. 다음 예제에서는 \\B 메타 문자를 활용해 잘못 쓰인 빈칸으로 둘어싸인 하이픈을 찾는다.

> 얘문

Please enter the nine-digit id ad it  
appears on your color - coded pass-key.

> 정규 표현식

\\B-\\B

> 결과

Please enter the nine-digit id ad it  
appears on your color __-__ coded pass-key.

> 분석

\\B-\\B는 단어 구분 문자로 둘어싸인 하이픈과 일치한다. 그러므로 
nine-digit , pass-key는 일치하지 않지만, color - coded는 일치한다.

__문자열 경계 정의하기__

단어 경계는 단어의 위치




## 7장 하위 표현식 사용하기
## 8장 역참조 사용하기
## 9장 전방탐색과 후방탐색
## 19장 조건 달기
## 11장 정규 표현식으로 해결하는 일반적인 문제들
## 부록 많이 쓰는 애플리케이션과 언어에서 활용하는 정규 표현식
