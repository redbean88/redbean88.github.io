[ { "title": "자바 ORM 표준 JPA 프로그래밍(희망편08)", "url": "/posts/JPA-CH08/", "categories": "JPA", "tags": "", "date": "2022-05-16 22:20:01 +0900", "snippet": "Chapter 08. 값 타입JPA의 데이터 타입을 가장 크게 분류하면 엔티티 타입과 값 타입으로 나눌 수 있다. 엔티티 타입은 @Entity로 정의하는 객체이고, 값 타입은 int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체를 말한다.엔티티 타입은 식별자를 통해 지속해서 추적할 수 있지만, 값 타입은 추적할 수 없다.값 타입은 3가지로 분류할 수 있다. 기본 값 타입basic value type 자바 기본 타입 래퍼 클래스 임베디드 타입embeded type(복합 값 타입) 컬렉션 값 타입collection value type임베디드 타입은 JPA에서 사용자가 직접 정의한 값 타입이다.8.1 기본값 타입 기본값 타입@Entitypublic class Member { @Id @GeneratedValue private Long id; private String name; private int age; ...}Member 엔티티는 id라는 식별자 값도 가지고 생명주기도 있지만 값 타입인 name, age 속성은 식별자 값도 없고 생명주기도Member 엔티티에 의존한다. 따라서 당연히 회원 엔티티 인스턴스르 제거하면 name, age 값도 제거된다.8.2 임베디드 타입(복합 값 타입)새로운 값 타입을 직접 정의해서 사용할 수 있는데, JPA에서 이것을 임베디드 타입embedded type이라 한다. 임베디드 타입도 int, String처럼 값 타입이다. 기본 회원 엔티티@Entitypublic class Member { @Id @GeneratedValue private Long id; private String name; // 근무 기간 @Temporal (TemporalType.DATE) Date startDate; @Temporal (TemporalType.DATE) Date endDate; // 집 주소 private String city; private String street; private String zipcode; ...}위 회원 엔티티를 ‘이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다.’고 표현하기보다‘회원 엔티티는 이름, 근무 기간, 집 주소를 가진다.’고 표현하는 것이 객체지향적이고 응집력이 있는 표현이다.[근무기간, 집주소]를 가지도록 임베디드 타입을 사용해보자. 값 타입 적용 회원 엔티티@Entitypublic class Member { @Id @GeneratedValue private Long id; private String name; // 근무 기간 @Embedded Period workPeriod; // 집 주소 @Embedded Address homeAddress; ...} 기간 임베디드 타입@Embeddablepublic class Period { @Temporal (TemporalType.DATE) Date startDate; @Temporal (TemporalType.DATE) Date endDate; public boolean isWork(Date date) { //.. 값 타입을 위한 메서드 정의 가능 }} 주소 임베디드 타입@Embeddablepublic class Address { @Column(name = &quot;city&quot;) // 매핑할 컬럼 정의 가능 private String city; private String street; private String zipcode; ...}새로 정의한 값 타입들은 재사용할 수 있고 응집도도 아주 높다. 또한 isWork()처럼 Period만 사용하는 의미있는 메서드도 만들 수 있다.임베디드 타입을 사용하려면 2가지 애노테이션이 필요하다. 둘 중 하나는 생략해도 된다. @Embeddable: 값 타입을 정의하는 곳에 표시 @Embedded: 값 타입을 사용하는 곳에 표시 임베디드 타입은 기본 생성자가 필수다. 임베디드 타입을 포함한 모든 값 타입은 엔티티의 생명주기에 의존하므로 엔티티와 임베디드 타입은 컴포지션구성 관계다. 하이버네이트는 임베디드 타입을 컴포넌트components라 한다.8.2.1 임베디드 타입과 테이블 매핑임베디드 타입은 엔티티의 값일 뿐이다. 임베디드 타입을 사용하기 전 후의 매핑하는 테이블은 같다.임베디드 타입 덕분에 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능하다.8.2.2 임베디드 타입과 연관관계임베디드 타입은 값 타입을 포함하거나 엔티티를 참조할 수 있다. 엔티티는 공유될 수 있으므로 참조한다고 표현하고, 값 타입은 특정 주인에 소속되고 논리적인 개념상으로 공유되지 않으므로 포함한다고 표현한다. 임베디드 타입과 연관관계@Entitypublic class Member { @Embedded Address address; @Embedded PhoneNumber phoneNumber; ...}@Embeddablepublic class Address { String street; String city; String state; @Embedded Zipcode zipcode; // 임베디드 타입 포함 }@Embeddablepublic class Zipcode { String zip; String plusFour; }@Embeddablepublic class PhoneNumber { String areaCode; String localNumber; @ManyToOne PhoneServiceProvider provider; // 엔티티 참조 ...}@Entitypublic class PhoneServiceProvider { @Id String name; ...} 값 타입인 Address가 값 타입인 Zipcode를 포함할 수 있다. 값 타입인 PhoneNumber가 엔티티 타입인 PhoneServiceProvider를 참조할 수 있다.8.2.3 @AttributeOverride: 속성 재정의임베디드 타입에 정의한 매핑정보를 재정의하려면 엔티티에 @AttributeOverride를 사용하면 된다.예를 들어 회원에게 주소가 하나 더 필요하다고 해보자.@Entitypublic class Member { @Id @GeneratedValue private Long id; private String name; @Embedded Address homeAddress; @Embedded Address companyAddress; }이렇게 했을 때의 문제점은 테이블에 매핑하는 컬럼명이 중복되는 것이다. 이 때 @AttributeOverrides를 사용하면 된다.@Entitypublic class Member { @Id @GeneratedValue private Long id; private String name; @Embedded Address homeAddress; @Embedded @AttributeOverrides({ @AttributeOverride(name=&quot;city&quot;, column=@Column(name=&quot;company_city&quot;)), @AttributeOverride(name=&quot;street&quot;, column=@Column(name=&quot;company_steet&quot;)), @AttributeOverride(name=&quot;zipcode&quot;, column=@Column(name=&quot;company_zipcode&quot;)), }) Address companyAddress; }생성된 테이블을 확인하자.CREATE TABLE MEMBER { company_city varchar(255), company_street varchar(255), company_zipcode varchar(255), city varchar(255), street varchar(255), zipcode varchar(255), ...}@AttributeOverrides는 엔티티에 설정해야 한다. 임베디드 타입이 임베디드 타입을 가지고 있더라도 엔티티에 설정해야 한다.8.3 값 타입과 불변 객체8.3.1 값 타입 공유 참조임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다.member1.setHomeAddress(new Address(&quot;OldCity&quot;));Address address = member1.getHomeAddress();address.setCity(&quot;newCity&quot;); // 회원1의 address 값을 공유해서 사용member2.setHmeAddress(address);회원2의 주소만 NewCity로 변경되길 기대했지만 회원1의 주소도 NewCity로 변경되어 버린다.회원1과 2가 같은 address 인스턴스를 참조하기 때문인데, 영속성 컨텍스트는 회원1과 2 둘 다 city 속성이 변경된 것으로 판단해서 각각 UPDATE SQL을 실행한다.이렇게 뭔가를 수정했는데 예상치 못한 곳에서 문제가 발생하는 것을 부작용side effect이라 한다.8.3.2 값 타입 복사값을 공유하여 사용하는 것 대신에 값인스턴스를 복사해서 사용해야 한다.member1.setHomeAddress(new Address(&quot;OldCity&quot;));Address address = member1.getHomeAddress();Address newAddress = address.clone();new Address.setCity(&quot;NewCity&quot;);member2.setHomeAddress(newAddress);이처럼 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입primitive type이 아니라 객체 타입이다.따라서 값을 대입하면 항상 복사본을 전달하는 기본 타입과는 다르게 항상 참조 값을 전달한다.Address a = new address(&quot;Old&quot;);Address b = a; // 참조 값 전달 b.setCity(&quot;New&quot;);복사하지 않고 원본의 참조 값을 직접 넘기는 것을 막을 방법은 없다. 따라서 객체의 공유 참조는 피할 수 없다.따라서 근본적인 해결책이 필요한데 객체의 값을 수정하지 못하게 막으면 된다.8.3.3 불변 객체값 타입은 부작용 없이 쓸 수 있어야 한다. 객체를 불변하게 만들면 부작용을 원천 차단할 수 있다. 따라서 값 타입은 가능하면 불변 객체Immutable Object로 설계해야 한다.불변 객체의 값은 조회할 수 있지만 수정할 수 없다. 인스턴스 참조 값의 공유를 피할 순 없지만 부작용은 발생하지 않는다.구현하는 다양한 방법이 있지만 가장 간단하게 생성자로만 값을 설정하고 설정자를 만들지 않으면 된다. 주소 불변 객체@Embeddablepublic class Address { private String city; protected Address() {} // JPA에서 기본 생성자는 필수다. public Address(String city) {this.city = city} public String getCity() {return city;} // Setter는 만들지 않는다. }Integer, String 등은 자바가 제공하는 대표적인 불변 객체다.불변이라는 작은 제약으로 부작용이라는 큰 재앙을 막을 수 있다.8.4 값 타입의 비교자바에서 equals()를 재정의하면 hashCode()도 재정의하는 것이 안전하다. 그렇지 않으면 해시를 사용하는 컬렉션HashSet, HashMap이 정상 동작하지 않는다. 자바 IDE에는 대부분 equals, hashCode 메서드를 자동으로 생성해주느 기능이 있다.8.5 값 타입 컬렉션값 타입을 하나 이상 저장하려면 컬렉션에 보관하고 @ElementCollection, @CollectionTable 을 사용하면 된다. 값 타입 컬렉션@Entitypublic class Member { @Id @GeneratedValue private Long id; @Embedded private Address homeAddress; @ElementCollection @CollectionTable(name=&quot;favorite_food&quot;, joinColumns=@JoinColumn(name=&quot;member_id&quot;)) @Column(name=&quot;food_name&quot;) private Set&amp;lt;String&amp;gt; favoriteFoods = new HashSet&amp;lt;&amp;gt;(); @ElementCollection @CollectionTable(name=&quot;address&quot;, joinColumns=@JoinColumn(name=&quot;member_id&quot;)) @Column(name=&quot;member_id&quot;) private List&amp;lt;Address&amp;gt; addressHistory = new ArrayList&amp;lt;&amp;gt;(); }@Embeddablepublic class Address { @Column private String city; private String street; private String zipcode; ...}favoriteFoods는 기본값 타입인 String을 컬렉션으로 가진다. 이것을 테이블로 매핑해야 하는데 테이블은 컬럼안에 컬렉션을 포함할 수 없다. 따라서 별도의 테이블을 추가하고 @CollectionTable을 사용해서 추가한 테이블을 매핑해야 한다. 그리고 favoriteFoods처럼 값으로 사용되는 컬럼이 하나면 @Column을 사용해서 컬럼명을 지정할 수 있다.테이블 매핑 정보는 @AttributeOverride를 사용해서 재정의할 수 있다.@CollectionTable을 생략하면 기본값을 사용해서 매핑한다. {엔티티 이름}_{컬렉션 속성 이름}이 기본값이다.8.5.1 값 타입 컬렉션 사용 값 타입 컬렉션 등록Member member = new Member();// 임베디드 값 타입member.setHomeAddress(new Address(&quot;통영&quot;, &quot;몽돌해수욕장&quot;, &quot;660-123&quot;));// 기본값 타입 컬렉션member.getFavoriteFoods().add(&quot;짬뽕&quot;);member.getFavoriteFoods().add(&quot;짜장&quot;);member.getFavoriteFoods().add(&quot;탕수육&quot;);// 임베디드 값 타입 컬렉션member.getAddressHistory().add(new Address(&quot;서울&quot;, &quot;강남&quot;, &quot;123-123&quot;));member.getAddressHistory().add(new Address(&quot;서울&quot;, &quot;강북&quot;, &quot;000-000&quot;));em.persist(member);JPA는 member 엔티티를 영속화할 때 값 타입들도 함께 저장한다. 실제 실행되는 INSERT SQL을 보자. member: INSERT SQL 1번 member.homeAddress: 컬렉션이 아닌 임베디드 값 타입이므로 회원 테이블에 포함된다. member.favoriteFoods: INSERT SQL 3번 member.addressHistory: INSERT SQL 2번따라서 em.persist(member) 한 번 호출로 총 6번의 INSERT SQL을 실행한다. 값 타입은 영속성 전이 + 고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.값 타입 컬렉션도 조회할 때 페치 전략을 선택할 수 있는데 LAZY가 기본 전략이다.@ElementCollection(fetch = FetchType.LAZY)지연 로딩으로 가정하고 다음 코드를 실행하면 어떻게 되는지 보자. 조회// SQL: SELECT ID, CITY, STREET, ZIPCODE FROM MEMBER WHERE ID = 1Member member = em.find(Member.class, 1L); // 1. Member// 2. member.homeAddressAddress homeAddress = member.getAddress();// 3. member.favoriteFoodsSet&amp;lt;String&amp;gt; favoriteFoods = member.getFavoriteFoods(); // LAZY// SQL: SELECT MEMBER ID, FOOD_NAME FROM FAVORITE_FOODS// WHERE MEMBER_ID = 1for (String favoriteFood : favoriteFoods) { System.out.println(&quot;favotiteFood = &quot; + favoriteFood);}// 4. member.addressHistoryList&amp;lt;Address&amp;gt; addressHistory = member.getAddressHistory(); // LAZY// SQL: SELECT MEMBER_ID, CITY, STREET, ZIPCODE FROM ADDRESS// WHERE MEMBER_ID = 1addressHistory.get(0); member: 회원만 조회한다. 이때 임베디드 값 타입인 homeAddress도 함께 조회한다. member.homeAddress: 1번에서 회원을 조회할 때 같이 조회해 둔다. member.favoriteFoods: LAZY로 설정해서 실제 컬렉션을 사용할 때 SELECT SQL을 1번 호출한다. member.addressHistory: LAZY로 설정해서 실제 컬렉션을 사용할 때 SELECT SQL을 1번 호출한다. 수정Member member = em.find(Member.class, 1L);// 1. 임베디드 값 타입 수정member.setHomeAddress(new Address(&quot;새로운도시&quot;, &quot;신도시1&quot;, &quot;123456&quot;);// 2. 기본값 타입 컬렉션 수정Set&amp;lt;String&amp;gt; favoriteFoods = member.getFavoriteFoods();favoriteFoods.remove(&quot;탕수육&quot;);favoriteFoods.add(&quot;치킨&quot;);// 3. 임베디드 값 타입 컬렉션 수정List&amp;lt;Address&amp;gt; addressHistory = member.getAddressHistory();addressHistory.remove(new Address(&quot;서울&quot;, &quot;기존 주소&quot;, &quot;123-123&quot;));addressHistory.remove(new Address(&quot;신도시&quot;, &quot;새로운 주소&quot;, &quot;123-456&quot;)); 임베디드 값 타입 수정: homeAddress 임베디드 값 타입은 MEMBER 테이블과 매핑했으므로 MEMBER 테이블만 UPDATE 한다. Member 엔티티를 수정하는 것과 같다. 기본값 타입 컬렉션 수정: 탕수육을 치킨으로 변경하려면 탕수육을 제거하고 치킨을 추가해야 한다.자바의 String 타입은 불변 객체이다. 임베디드 값 타입 컬렉션 수정: 값 타입은 불변해야 하므로 컬렉션에서 기존 주소를 삭제하고 새로운 주소를 등록했다.값 타입은 equals, hashCode를 꼭 구현해야 한다고 했다.8.5.2 값 타입 컬렉션의 제약사항값 타입 컬렉션에 보관된 값 타입들은 별도의 테이블에 보관되므로 이 테이블에 보관된 값이 변경되면 데이터베이스에 있는 원본 데이터를 찾기 어렵다는 문제가 있다. 이런 문제로 JPA 구현체들은 값 타입 컬렉션에 변경사항이 생기면 값 타입 컬렉션 테이블의 모든 데이터를 삭제하고현재 값 타입 컬렉션 객체에 있는 모든 값을 데이터베이스에 다시 저장한다.따라서 실무에서는 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 일대다 관계를 고려해야 한다.추가로 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 한다.따라서 기본 키 제약으로 인해 컬럼에 null을 입력할 수 없고, 같은 값을 중복해서 저장할 수도 없다.위의 문제를 해결하려면 값 타입 컬렉션 대신에 새로운 엔티티를 만들어서 일대다 관계로 설정하고,추가로 영속성 전이cascade + 고아 객체 제거ORPHAN REMOVE 기능을 적용하면 값 타입 컬렉션처럼 사용할 수 있다.8.6 정리엔티티 타입의 특징 식별자@Id가 있다. 엔티티 타입은 식별자가 있고 식별자로 구별할 수 있다. 생명 주기가 있다. 생성, 영속화, 소멸의 생명주기가 있다. em.persist(entity)로 영속화. em.remove(entity)로 제거. 공유할 수 있다. 참조 값을 공유할 수 있다. 이것을 공유 참조라 한다. 회원 엔티티가 있다면 다른 엔티티에서 참조할 수 있다. 값 타입의 특징 식별자가 없다. 생명 주기를 엔티티에 의존한다. 스스로 생명주기를 가지지 않고 엔티티에 의존한다. 엔티티를 제거하면 같이 제거된다. 공유하지 않는 것이 안전하다. 값을 복사해서 사용해야 한다. 오직 하나의 주인만이 관리해야 한다. 불변 객체로 만드는 것이 안전하다." }, { "title": "자바 ORM 표준 JPA 프로그래밍(희망편09)", "url": "/posts/JPA-CH09/", "categories": "JPA", "tags": "", "date": "2022-05-16 21:20:01 +0900", "snippet": "Chapter 10. 객체지향 쿼리 언어 이장의 내용 객체지향 쿼리 소개 JPQL Criteria QueryDSL 네이티브 SQL 객체지향 쿼리 심화 9.1 객체지향 쿼리 소개 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다. SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.9.2 JPQL JPQLJava Persistence Query Language은 엔티티 객체를 조회하는 객체지향 쿼리다. JPQL은 결국 SQL로 변환된다. Criteria나 QueryDSL도 결국 JPQL을 만들어주는 빌더 역할을 할 뿐이므로 JPQL을 잘 알아야 한다.9.2.1 기본 문법과 쿼리 APIJPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다.엔티티를 저장할 때는 em.persist() 메서드를 사용하면 되므로 INSERT 문은 없다.SELECT 문SELECT m FROM Member AS m WHERE m.username = &#39;Hello&#39; 대소문자 구분 JPQL 키워드를 제외한 엔티티와 속성은 대소문자를 구분한다. 엔티티 이름 Member는 클래스 명이 아니라 엔티티 명이다. 기본값인 클래스 명을 엔티티 명으로 사용하는 것을 추천한다. 별칭은 필수 Member AS m처럼 JPQL은 별칭을 필수로 사용해야 한다. AS는 생략할 수 있다. TypedQuery, Query작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다.반환할 타입을 명확하게 지정할 수 있으면 TypedQuery 객체를 사용하고,반환 타입을 명확하게 지정할 수 없으면 Query 객체를 사용하면 된다. TypeQuery 사용TypedQuery&amp;lt;Member&amp;gt; query = em.createQuery(&quot;SELECT m FROM Member m&quot;, Member.class);List&amp;lt;Member&amp;gt; resultList = query.getResultList();em.createQuery()의 두 번째 파라미터에 반환할 타입을 지정하면 TypeQuery를 반환하고 지정하지 않으면 Query를 반환한다. 여기선 조회 대상이 Member 엔티티이므로 대상 타입이 명확하다. Query 사용Query query = em.createQuery(&quot;SELECT m.username, m.age from Member m&quot;);List resultList = query.getResultList();여기선 조회 대상이 String 타입과 Integer 타입이므로 조회 대상 타입이 명확하지 않다.Query 객체는 SELECT 절의 조회 대상이 둘 이상이면 Object[]를 반환하고 하나면 Object를 반환한다.일반적으로 타입을 변환할 필요가 없는 TypedQuery를 사용하는 것이 더 편리하다.결과 조회다음 메서드들을 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회한다. query.getResultList(): 결과를 리스트로 반환한다. 결과가 없으면 빈 컬렉션을 반환한다. query.getSingleResult(): 결과가 정확히 하나일 때 사용한다. 결과가 없으면 NoResultException 발생 1개보다 많으면 NonUniqueResultException 발생 9.2.2 파라미터 바인딩JDBC는 위치 기준 파라미터 바인딩만 지원하지만 JPQL은 이름 기준 파라미터 바인딩도 지원한다. 이름 기준 파라미터 파라미터를 이름으로 구분하는 방법. 앞에 :를 사용한다. String usernameParam = &quot;User1&quot;; TypedQuery&amp;lt;Member&amp;gt; query = em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class); query.setParameter(&quot;username&quot;, usernameParam);List&amp;lt;Member&amp;gt; resultList = query.getResultList(); 추가로 JPQL API는 대부분 메서드 체인 방식으로 설계되어 다음과 같이 작성할 수도 있다. List&amp;lt;Member&amp;gt; members = em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class) .setParameter(&quot;username&quot;, usernameParam) .getResultList(); 위치 기준 파라미터 ? 다음에 위치 값을 주면 된다. 위치 값은 1부터 시작한다. List&amp;lt;Member&amp;gt; members = em.createQuery(&quot;select m from Member m where m.username = ?1&quot;, Member.class) .setParameter(1, usernameParam) .getResultList(); 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확한 방법이다.9.2.3 프로젝션SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라 한다. 엔티티 프로젝션 SELECT m FROM Member m SELECT m.team FROM Member m 조회한 엔티티는 영속성 컨텍스트에서 관리된다. 임베디드 타입 프로젝션 임베디드 타입은 엔티티와 거의 비슷하게 사용되지만 조회의 시작점이 될 수 없다는 제약이 있다. String query = &quot;SELECT o.address FROM Order o&quot;;List&amp;lt;Address&amp;gt; addresses = em.createQuery(query, Address.class) .getResultList(); 임베디드 타입은 엔티티 타입이 아닌 값 타입이다. 따라서 영속성 컨텍스트에서 관리되지 않는다. 스칼라 타입 프로젝션 숫자, 문자, 날짜와 같은 기본 데이터 타입을 스칼라 타입이라 한다. 통계 쿼리도 주로 스칼라 타입으로 조회한다. NEW 명령어 TypedQuery&amp;lt;UserDTO&amp;gt; query = em.createQuery(&quot;SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m&quot;, UserDTO.class);List&amp;lt;UserDTO&amp;gt; resultList = query.getResultList(); NEW 명령어를 사용한 클래스로 지루한 객체 변환 작업을 줄일 수 있다. 사용 시 다음 2가지를 주의해야 한다. 패키지 명을 포함한 전체 클래스 명을 입력해야 한다. 순서와 타입이 일치하는 생성자가 필요하다. 9.2.4 페이징 API페이징 처리용 SQL은 지루하고 반복적인데다가 데이터베이스마다 처리하는 SQL이 다르다.JPA는 페이징을 두 API로 추상화했다. setFirstResult(int startPosition): 조회 시작 위치 (0부터 시작) setMaxResults(int maxResult): 조회할 데이터 수List&amp;lt;Member&amp;gt; members = em.createQuery(&quot;SELECT m FROM Member m ORDER BY m.username DESC&quot;, Member.class) .setFirstResult(10) .setMaxResults(20) .getResultList();9.2.5 집합과 정렬select count(m), sum(m.age), avg(m.age), max(m.age), min(m.age)from Member m참고 사항 DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다. select count(distinct m.age) from Member m DISTINCT를 COUNT에서 사용할 때 임베디드 타입은 지원하지 않는다. GROUP BY, HAVING다음 코드는 그룹별 통계 데이터 중에서 평균나이가 10살 이상인 그룹을 조회한다.select t.name, count(m.age), sum(m.age), avg(m.age), max(m.age), min(m.age)from Member m LEFT JOIN m.team tGROUP BY t.nameHAVING avg(m.age) &amp;gt;= 109.2.6 JPQL 조인JPQL도 조인을 지원하는데 SQL 조인과 기능은 같고 문법만 약간 다르다.내부 조인INNER JOIN을 사용한다. INNER는 생략 가능하다.String teamName = &quot;팀A&quot;;String query = &quot;SELECT m FROM Member m INNER JOIN m.team t &quot; + &quot;WHERE t.name = :teamName&quot;;List&amp;lt;Member&amp;gt; members = em.createQuery(query, Member.class) .setParameter(&quot;teamName&quot;, teamName) .getResultList();JPQL 조인의 가장 큰 특징은 연관 필드를 사용한다는 것이다. FROM Member m: 회원을 선택하고 m이라는 별칭을 주었다. Member m JOIN m.team t: 회원이 가지고 있는 연관 필드로 팀과 조인한다. 조인한 팀에는 t라는 별칭을 주었다.만약 조인한 두 개의 엔티티를 조회하려면 다음과 같이 JPQL을 작성하면 된다.select m, tfrom Member m join m.team t외부 조인select mfrom Member m left [outer] join m.team t outer는 생략 가능해서 보통 left 조인으로 사용한다.컬렉션 조인일대다, 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 것을 컬렉션 조인이라 한다.팀 → 회원은 일대다 조인이면서 컬렉션 값 연관 필드t.members를 사용한다.select t, m from Team t left join t.members m팀과 팀이 보유한 회원 목록을 컬렉션 값 연관 필드로 외부 조인했다.세타 조인 카테시안곱에서 선택연산이 비교 연산자가 사용되는 것. 특별히 = 연산이 사용되는 경우를 동등equi 조인이라 한다.WHERE 절을 사용해서 세타 조인을 할 수 있다. 세타조인은 내부 조인만 지원한다.세타 조인을 사용하면 전혀 관계 없는 엔티티도 조인할 수 있다.// JPQLselect count(m) from Member m, Team twhere m.username = t.name// SQLSELECT COUNT(M.ID)FROM MEMBER M CROSS JOIN TEAM TWHERE M.USERNAME=T.NAMEJOIN ON 절JPA 2.1ON 절을 사용하면 조인 대상을 필터링하고 조인할 수 있다. 참고로 내부 조인의 결과는 ON 절 = WHERE 절이므로보통 외부 조인에서만 사용된다.// JPQLselect m, t from Member mleft join m.team t on t.name = &#39;A&#39; // SQLselect m.*, t.* from Member mleft join Team t on m.team_id and t.name=&#39;A&#39;9.2.7 페치 조인페치fetch 조인은 SQL에서 이야기하는 조인의 종류가 아니라 JPQL에서 성능 최적화를 위해 제공하는 기능으로연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능이다. join fetch 명령어로 사용할 수 있다.엔티티 페치 조인회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회하는 JPQL을 보자.select mfrom Member m join fetch m.team여기선 회원과 팀을 함께 조회한다. 페치 조인은 별칭을 사용할 수 없지만 하이버네이트 구현체에선 사용할 수 있도록 구현되었다. 페치 조인 사용String jpql = &quot;select m from Member m join fetch m.team&quot;;List&amp;lt;Member&amp;gt; members = em.createQuery(jpql, Member.class) .getResultList(); 실행된 SQLselect m.*, t.*from member minner join team t on m.team_id=t.id엔티티페치 조인에서 회원 엔티티만 선택했는데 SQL을 보면 회원과 연관된 팀도 함께 조회된 것을 확인할 수 있다.회원과 팀을 지연 로딩으로 설정해도 회원을 조회할 때 페치 조인으로 함께 조회했으므로 연관된 팀 엔티티는프록시가 아닌 실제 엔티티다. 따라서 연관된 팀을 사용해도 지연 로딩이 발생하지 않는다.또한 실제 엔티티이므로 회원 엔티티가 준영속 상태가 되어도 연관된 팀을 조회할 수 있다.컬렉션 페치 조인 JPQLselect tfrom Team t join fetch t.memberswhere t.name = &#39;팀A&#39; 실행된 SQLSELECT T.*, M.*FROM TEAM TINNER JOIN MEMBER M ON T.ID=M.TEAM_IDWHERE T.NAME=&#39;팀A&#39;마찬가지로 팀만 선택했는데 팀과 연관된 회원도 함께 조회한 것을 볼 수 있다.teamname = 팀A, team = Team@0x100-&amp;gt;username = 회원1, member = Member@0x200-&amp;gt;username = 회원2, member = Member@0x300teamname = 팀A, team = Team@0x100-&amp;gt;username = 회원1, member = Member@0x200-&amp;gt;username = 회원2, member = Member@0x300TEAM 테이블에서 ‘팀A’는 하나지만 MEMBER 테이블과 조인하면서 결과가 증가ex) 팀A에 속한 회원이 2명해서 같은 ‘팀A’가 2건조회되었다. 따라서 중복 제거가 필요하다.페치 조인과 DISTINCTJPQL의 DISTINCT 명령어는 SQL에 DISTINCT를 추가하고 애플리케이션에서 한 번 더 중복을 제거한다.select distinct tfrom Team t join fetch t.memberswhere t.name = &#39;팀A&#39;select distinct t는 팀 엔티티의 중복을 제거하라는 것이다. 따라서 이제 ‘팀A’는 하나만 조회된다.teamname = 팀A, team = Team@0x100-&amp;gt;username = 회원1, member = Member@0x200-&amp;gt;username = 회원2, member = Member@0x300페치 조인과 일반 조인의 차이JPQL은 결과를 반환할 때 연관관계까지 고려하지 않는다. 단지 SELECT 절에 지정한 엔티티만 조회할 뿐이다.만약 회원 컬렉션을 지연 로딩으로 설정하면 프록시나 아직 초기화하지 않은 컬렉션 래퍼를 반환한다.즉시 로딩으로 설정하면 회원 컬렉션을 즉시 로딩하기 위해 쿼리를 한 번 더 실행한다.반면에 페치 조인을 사용하면 연관된 엔티티도 같이 조회한다.페치 조인의 특징과 한계페치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 조회할 수 있어서 성능을 최적화할 수 있다.페치 조인은 글로벌 로딩 전략보다 우선한다. 예를 들어 지연 로딩으로 설정해도 JPQL에서 페치 조인을 사용하면 페치 조인을 적용해서 함께 조회한다.최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어난다.일부는 빠를 수 있어도 전체로 보면 자주 사용하지 않는 엔티티를 자주 로딩하므로 오히려 성능에 악영향을 미칠 수 있다.따라서 되도록 지연 로딩을 사용하고 최적화가 필요하면 페치 조인을 적용하는 것이 효과적이다.페치 조인은 다음과 같은 한계가 있다. 페치 조인 대상에는 별칭을 줄 수 없다. 둘 이상의 컬렉션을 페치할 수 없다. 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.9.2.8 경로 표현식경로 표현식이란 쉽게 표현해서 .을 찍어 객체 그래프를 탐색하는 것이다.용어 정리 상태 필드state field: 단순히 값을 저장하기 위한 필드 연관 필드association field: 연관관계를 위한 필드, 임베디드 타입 포함 단일 값 연관 필드: @ManyToOne, @OneToOne, 대상이 엔티티 컬렉션 값 연관 필드: @OneToMany, @ManyToMany, 대상이 컬렉션 상태 필드 연관 필드 예제@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = &quot;name&quot;) private String username; // 상태 필드 private Integer age; // 상태 필드 @ManyToOne(..) private Team team; // 단일 값 연관 필드 @OneToMany(..) private List&amp;lt;Order&amp;gt; orders; // 컬렉션 값 연관 필드 }경로 표현식과 특징 상태 필드 경로: 경로 탐색의 끝이다. 더는 탐색할 수 없다. 단일 값 연관 경로: 묵시적으로 내부 조인이 일어난다. 계속 탐색할 수 있다. 컬렉션 값 연관 경로: 묵시적으로 내부 조인이 일어난다. 더는 탐색할 수 없다. 단 FROM 절에서 조인을 통해 별칭을 얻으면 탐색할 수 있다. 명시적 조인: JOIN을 직접 적어주는 것 묵시적 조인: 경로 표현식에 의해 조인이 일어나는 것, 내부 조인만 할 수 있다. select m.team from Member m 컬렉션 값 연관 경로 탐색 select t.members from Team t // 성공select t.members.username from Team t // 실패 select m.username from Team t join t.members m // 이처럼 해야함select t.members.size from Team t // size 사용 가능 COUNT로 적절히 변환 됨 묵시적 조인 시 주의사항 항상 내부 조인이다. 컬렉션은 경로 탐색의 끝이다. 탐색하려면 명시적으로 조인을 해서 별칭을 얻어야 한다. ​ 조인이 성능상 차지하는 부분은 아주 크다. 따라서 성능이 중요하면 분석하기 쉽도록 명시적 조인을 사용하자.9.2.9 서브 쿼리JPQL에선 서브 쿼리를 WHERE, HAVING 절에서만 사용할 수 있고 하이버네이트는 추가적으로 SELECT 절의 서브 쿼리도 허용한다. 나이가 평균보다 많은 회원 예제select m from Member mwhere m.age &amp;gt; (select avg(m2.age) from Member m2)서브 쿼리 함수 [NOT] EXISTS : 서브 쿼리에 결과가 존재하면 참 { ALL ANY SOME } : ALL: 조건을 모두 만족하면 참 ANY 혹은 SOME: 조건을 하나라도 만족하면 참 [NOT] IN : 서브 쿼리의 결과 중 하나라도 같은 것이 있으면 참9.2.10 조건식####타입 표현 종류 설명 예제 문자   ‘HELLO’‘She’’s’ 숫자   10L10D10F 날짜 DATE {d ‘yyyy-mm-dd’}TIME {t ‘hh-mm-ss’}DATETIME {ts ‘yyyy-mm-dd hh:mm:ss.f’} {d ‘2012-03-24’}{ts ‘2012-03-24 10-11-11.123’} Boolean TRUE, FALSE   Enum 패키지명을 포함한 전체 이름을 사용해야 한다. jpabook.MemberType.Admin 엔티티 타입 엔티티의 타입을 표현한다. 주로 상속과 관련해서 사용한다. TYPE(m) = Member Between X [NOT] BETWEEN A AND B: X는 A ~ B 사이의 값이면 참 (A, B값 포함)컬렉션 식 빈 컬렉션 비교 식 {컬렉션 값 연관 경로} IS [NOT] EMPTY 컬렉션의 멤버 식: 엔티티나 값이 컬렉션에 포함되어 있으면 참 {엔티티나 값} [NOT] MEMBER [OF] {컬렉션 값 연관 경로} select t from Team t where :memberParam member of t.members CASE 식 기본 CASE 심플 CASE COALESCE NULLIF9.2.11 다형성 쿼리9.2.12 사용자 정의 함수 호출JPA 2.1...9.2.15 Named 쿼리: 정적 쿼리 동적 쿼리: em.createQuery(“select ..”) 처럼 JPQL을 문자로 완성해서 직접 넘기는 것을 동적 쿼리라 한다.런타임에 특정 조건에 따라 JPQL을 동적으로 구성할 수 있다. 정적 쿼리: 미리 정의한 쿼리에 이름을 부여해서 필요할 떄 사용할 수 있는데 이 것을 Named 쿼리라 한다.Named 쿼리는 한 번 정의하면 변경할 수 없는 정적인 쿼리다.Named 쿼리는 애플리케이션 로딩 시점에 JPQL 문법을 체크하고 미리 파싱해둔다. 따라서 오류를 빨리 확인할 수 있고, 사용하는 시점에는 파싱된 결과를 재사용하므로 성능상 이점도 있다.Named 쿼리는 @NamedQuery 애노테이션을 사용해서 자바 코드에 작성하거나 XML 문서에 작성할 수 있다.애노테이션에 정의 정의@Entity@NamedQuery( name = &quot;Member.findByUsername&quot;, query = &quot;select m from Member m where m.username = :username&quot;)public class Member { ...} 사용List&amp;lt;Member&amp;gt; resultList = em.createNamedQuery(&quot;Member.findByUsername&quot;, Member.class) .setParameter(&quot;username&quot;, &quot;회원1&quot;) .getResultList();하나의 엔티티에 2개 이상의 Named 쿼리를 정의하려면 @NamedQueries를 사용하면 된다.Named 쿼리를 XML에 정의JPA에서 애노테이션으로 작성할 수 있는 것은 XML로도 작성할 수 있다.만약 XML과 애노테이션에서 같은 설정이 있으면 XML이 우선권을 가진다.9.4 QueryDSLCriteria는 문자가 아닌 코드로 JPQL을 작성하므로 문법 오류를 컴파일 단계에서 잡을 수 있고 자동완성 기능의 도움을 받을 수 있는 등 여러 가지 장점이 있지만 너무 복잡하고 어렵다. QueryDSL도 Criteria처럼 JPQL 빌더 역할을 하므로 대체할 수 있다.메이븐 설정을 마치고 콘솔에서 mvn compile을 입력하면 outputDirectory에 지정한 target/generated-sources 위치에 Q로 시작하는 쿼리 타입들이 생성된다.시작public void queryDSL() { EntityManager em = emf.crateEntityManager(); JPAQuery query = new JPAQuery(em); QMember qMember = new QMember(&quot;m&quot;); // 생성되는 JPQL의 별칭 m List&amp;lt;Member&amp;gt; members = query.from(qMember) .where(qMember.name.eq(&quot;회원1&quot;)) .orderBy(qMember.name.desc()) .list(qMember);} QueryDSL을 사용하려면 우선 JPAQuery 객체를 생성해야 하는데 이때 엔티티 매니저를 생성자에 넘겨준다. 다음으로 사용할 쿼리 타입을 생성하는데 생성자에는 별칭을 주면 된다. 이 별칭을 JPQL에서 별칭으로 사용한다. 그 다음 코드들은 보기만해도 쉽게 이해할 수 있을 것이다.기본 Q 생성쿼리 타입은 사용하기 편하도록 기본 인스턴스를 보관하고 있다.@Generated(&quot;com.querydsl.codegen.EntitySerializer&quot;)public class QAccount extends EntityPathBase&amp;lt;Account&amp;gt; { public static final QAccount account = new QAccount(&quot;account&quot;); ...하지만 같은 엔티티끼리 조인하거나 서브쿼리에 사용하면 같은 별칭이 되므로 이때는 별칭을 직접 지정해서 사용해야 한다.프로젝션과 결과 반환select 절에 조회 대상을 지정하는 것을 프로젝션이라 했다.프로젝션 대상이 하나QItem item = QItem.item;List&amp;lt;String&amp;gt; result = query.from(item).list(item.name);프로젝션 대상이 하나면 해당 타입으로 반환한다.여러 컬럼 반환과 튜플프로젝션 대상으로 여러 필드를 선택하면 QueryDSL은 기본으로 Tuple이라는 Map과 비슷한 내부 타입을 사용한다.조회 결과는 tuple.get() 메서드에 조회한 쿼리 타입을 지정하면 된다.QItem item = QItem.item;List&amp;lt;Tuple&amp;gt; result = query.from(item).list(item.name, item.price);for (Tuple tuple : result) { System.out.println(&quot;name = &quot; + tuple.get(item.name)); System.out.println(&quot;price = &quot; + tuple.get(item.price));}빈 생성DTO쿼리 결과를 엔티티가 아닌 특정 객체로 받고 싶으면 빈 생성 기능을 사용한다. (더 자주 사용됨)QueryDSL은 객체를 생성하는 다양한 방법을 제공한다. 프로퍼티 접근 필드 직접 접근 생성자 사용원하는 방법을 지정하기 위해 Projections를 사용하면 된다. 예제 ItemDTO@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class ItemDTO { private String username; private int price; } 프로퍼티 접근SetterQItem item = QItem.item;List&amp;lt;ItemDTO&amp;gt; result = query.from(item).list( Projections.bean(ItemDTO.class, item.name.as(&quot;username&quot;), item.price));bean() 메서드는 Setter를 사용해서 값을 채운다. as를 사용해서 쿼리 결과인 name을 ItemDTO가 가지고 있는 프로퍼티인 username으로 변경했다. 이처럼 쿼리 결과와 매핑할 프로퍼티 이름이 다르면 as를 사용해서 별칭을 주면 된다. 필드 직접 접근QItem item = QItem.item;List&amp;lt;ItemDTO&amp;gt; result = query.from(item).list( Projections.fields(ItemDTO.class, item.name.as(&quot;username&quot;), item.price));fields() 메서드는 필드에 직접 접근해서 값을 채워준다. 필드를 private로 설정해도 동작한다. 생성자 사용QItem item = QItem.item;List&amp;lt;ItemDTO&amp;gt; result = query.from(item).list( Projections.constructor(ItemDTO.class, item.name, item.price));지정한 프로젝션과 파라미터 순서가 같은 생성자가 필요하다.DISTINCTquery.distinct().from(item)....수정, 삭제 배치 쿼리QueryDSL도 수정, 삭제같은 배치 쿼리를 지원한다. JPQL 배치 쿼리와 같이 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다는 점을 유의하자. 수정 배치 쿼리QItem item = QItem.item;JPAUpdateClause updateClause = new JPAUpdateClause(em, item);long count = updateClause.where(item.name.eq(&quot;시골 개발자의 JPA 책&quot;)) .set(item.price, item.price.add(100)) .execute(); 삭제 배치 쿼리QItem item = QItem.item;JPADeleteClause deleteClause = new JPADeleteClause(em, item);long count = deleteClause.where(item.name.eq(&quot;시골개발자의 JPA 책&quot;)) .execute()동적 쿼리BooleanBuilder를 사용하면 특정 조건에 따른 동적 쿼리를 편리하게 생성할 수 있다.SearchParam param = new SearchParam();param.setName(&quot;시골개발자&quot;);param.setPrice(10000);QItem item = QItem.item;BooleanBuilder builder = new BooleanBuilder();if (StringUtils.hasText(param.getName())) { builder.and(item.name.contains(param.getName()));}if (param.getPrice() != null) { builder.and(item.price.gt(param.getPrice()));}List&amp;lt;Item&amp;gt; result = query.from(item) .where(builder) .list(item);메서드 위임메서드 위임Delegate Methods 기능을 사용하면 쿼리 타입에 검색 조건을 직접 정의할 수 있다. 검색 조건 정의public class ItemExpression { @QueryDelegate(Item.class) public static BooleanExpression isExpensive(QItem item, Integer price) { return item.price.gt(price); } }메서드 위임 기능을 사용하기 위해 우선 static 메서드를 만들고 QueryDelegate 애노테이션으로 이 기능을 적용할 엔티티를지정한다. 메서드의 첫 번째 파라미터에는 대상 엔티티의 쿼리 타입을 지정하고 나머지는 필요한 파라미터를 정의한다. 쿼리 타입에 생성된 결과public class QItem extends EntityPathBase&amp;lt;Item&amp;gt; { ... public com.mysema.query.types.expr.BooleanExpression isExpensive(Integer price) { return ItemExpression.isExpensive(this, price); } }이제 메서드 위임 기능을 사용해보자.query.from(item).where(item.isExpensive(30000)).list(item);필요하다면 String, Date 같은 자바 기본 내장 타입에도 메서드 위임 기능을 사용할 수 있다.9.5 네이티브 SQLJPQL은 표준 SQL이 지원하는 대부분의 문법과 SQL 함수들을 지원하지만 특정 데이터베이스 종속적 기능은 지원하지 않는다.JPQL에서 특정 데이터베이스에 종속적인 기능을 지원하는 방법은 다음과 같다. 특정 데이터베이스만 사용하는 함수 JPQL에서 네이티브 SQL 함수를 호출할 수 있다 JPA 2.1. 하이버네이트는 데이터베이스 방언에 각 데이터베이스에 종속적인 함수들을 정의해두었다. 특정 데이터베이스만 지원하는 SQL 쿼리 힌트 하이버네이트를 포함한 몇몇 JPA 구현체들이 지원한다. 인라인 뷰, UNION, INTERSECT 하이버네이트는 지원하지 않지만 일부 JPA 구현체들이 지원한다. 스토어드 프로시저 JPQL에서 스토어드 프로시저를 호출할 수 있다 JPA 2.1 JDBC API와의 차이점이라면 네이티브 SQL은 JPA가 지원하는 영속성 컨텍스트의 기능을 그대로 사용할 수 있다.네이티브 쿼리 API는 다음 3가지가 있다. 결과 타입 정의 public Query createNativeQuery(String sqlString, Class resultClass); 결과 타입을 정의할 수 없을 때 public Query createNativeQuery(String sqlString); 결과 매핑 사용 public Query createNativeQuery(String sqlString, String resultSetMapping); 네이티브 SQL도 JPQL을 사용할 때와 마찬가지로 Named 쿼리를 사용할 때 Query.TypeQuery를 반환한다.따라서 JPQL API를 그대로 사용할 수 있다.9.6 객체지향 쿼리 심화9.6.1 벌크 연산수백개 이상의 엔티티를 하나씩 처리하기에는 시간이 너무 오래걸린다. 이럴 때 여러 건을 한 번에 수정하거나 삭제하는 연산이다. UPDATE 벌크 연산String qlString = &quot;update Product p &quot; + &quot;set p.price = p.price * 1.1 &quot; + &quot;where p.stickAmount &amp;lt; : stockAmount&quot;;int resultCount = em.createQuery(qlString) .setParameter(&quot;stockAmount&quot;, 10) .executeUpdate(); DELETE 벌크 연산String qlString = &quot;delete from Product p&quot; + &quot;where p.price &amp;lt; :price&quot;;int resultCount = em.createQuery(qlString) .setParameter(&quot;price&quot;, 100) .executeUpdate();JPA 표준은 아니지만 하이버네이트는 INSERT 벌크 연산도 지원한다.다음 코드는 100원 미만의 모든 상품을 ProductTemp에 저장한다. INSERT 벌크 연산String qlString = &quot;insert into ProductTemp(id, name, price, stockAmount) &quot; + &quot;select p.id, p.name, p.price, p.stockAmount from Product p &quot; + &quot;where p.price &amp;lt; :price&quot;;int resultCount = em.createQuery(qlString) .setParameter(&quot;price&quot;, 100) .executeUpdate();벌크 연산의 주의점벌크 연산을 사용할 때는 벌크 연산이 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다는 점에 주의해야 한다. 가격이 1000원인 상품A를 조회했다. 조회된 상품 A는 영속성 컨텍스트에서 관리된다. 벌크 연산으로 모든 상품의 가격을 10% 상승시켰다. 따라서 가격은 1100원이 되어야 한다. 벌크 연산을 수행한 후에 가격을 출력하면 1100원이 아니라 1000원이 출력된다.벌크 연산은 영속성 컨텍스트를 통하지 않고 데이터베이스에 직접 쿼리하므로 영속성 컨텍스트에 있는 상품 A와데이터베이스에 있는 상품A의 가격이 다를 수 있다. 이런 문제를 해결하는 방법을 살펴보자. em.refresh() 사용 벌크 연산을 수행한 직후에 정확한 상품 A 엔티티를 사용해야 한다면 em.refresh(productA)로 다시 조회하면 된다. 벌크 연산 먼저 실행 벌크 연산을 먼저 실행하고 나서 상품 A를 조회하면 이미 변경된 상품 A를 조회하게 된다. 벌크 연산 수행 후 영속성 컨텍스트 초기화 영속성 컨텍스트를 초기화하면 이후 엔티티를 조회할 때 벌크 연산이 적용된 데이터베이스에서 엔티티를 조회한다. 가능하면 벌크 연산을 가장 먼저 실행하는 것이 좋고 상황에따라 초기화하는 것도 필요하다.find() vs JPQLem.find() 메서드는 엔티티를 영속성 컨텍스트에서 먼저 찾고 없으면 데이터베이스에서 찾는다.해당 엔티티가 영속성 컨텍스트에 있으면 메모리에서 바로 찾으므로1차 캐시 성능상 이점이 있다.그에 비해 JPQL은 항상 데이터베이스에 SQL을 실행해서 결과를 조회한다.JPQL의 특징을 정리하자면 JPQL은 항상 데이터베이스를 조회한다. JPQL로 조회한 엔티티는 영속 상태다. 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.9.6.3 JPQL과 플러시 모드플러시는 영속성 컨텍스트의 변경 내역을 데이터베이스에 동기화하는 것이다. JPA는 플러시가 일어날 때 영속성 컨텍스트에 등록, 수정, 삭제한 엔티티를 찾아서 INSERT, UPDATE, DELETE SQL을 만들어 데이터베이스에 반영한다.플러시를 호출하려면 em.flush()를 직접 사용할수도 있지만 보통 플러시 모드에 따라 커밋하기 직전이나 쿼리 실행 직전에 자동으로 호출된다. 플러시 모드는 FlushModeType.AUTO가 기본값이므로 JPA는 트랙젝션 커밋 직전이나쿼리 실행 직전에 자동으로 플러시를 호출한다. 플러시 모드 설정em.setFlushMode(FlushModeType.COMMIT); // 커밋 시에만 플러시// 가격을 1000 -&amp;gt; 2000으로 변경product.setPrice(2000);// 1.em.flush() 직접 호출// 가격이 2000인 상품 조회Product product2 = em.createQuery(&quot;select p from Product p where p.price = 2000&quot;, Product.class) .setFlushMode(FlushModeType.AUTO) // 2. setFlushMode() .getSingleResult();JPQL은 영속성 컨텍스트에 있는 데이터를 고려하지 않고 데이터베이스에서 데이터를 조회한다.따라서 JPQL을 실행하기 전에 영속성 컨텍스트의 내용을 데이터베이스에 반영해야 한다.플러시 모드의 기본값은 AUTO이므로 일반적인 상황에서는 위 내용을 고려하지 않아도 된다.그렇다면 왜 COMMIT 모드를 사용하는 것일까?플러시 모드와 최적화COMMIT 모드는 트랜잭션을 커밋할 때만 플러시하고 쿼리를 실행할 때는 플러시하지 않는다. 따라서 데이터 무결성에 심각한 피해를 줄 수 있는데, 그럼에도 플러시가 너무 자주 일어나는 상황에 이 모드를 사용하면 플러시 횟수를 줄여서 성능을 최적화할 수 있다." }, { "title": "자바 ORM 표준 JPA 프로그래밍(희망편07)", "url": "/posts/JPA-CH07/", "categories": "JPA", "tags": "", "date": "2022-05-16 21:20:01 +0900", "snippet": "Chapter 07. 프록시와 연관관계 관리 프록시와 즉시 로딩, 지연 로딩 영속성 전이와 고아 객체7.1 프록시엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다. printUserAndTeam() 메서드는 memberId로 회원 엔티티를 찾아서 연관된 팀의 이름도 출력한다. 반면 printUser() 메서드는 회원 엔티티만 출력하고 연관된 팀 엔티티는 전혀 사용하지 않는다. printUser() 메서드는 회원 엔티티만 사용하므로 em.find()로 회원 엔티티를 조회할 때 회원과 연관된 팀 엔티티까지데이터베이스에서 함께 조회해 두는 것은 효율적이지 않다.JPA는 위 문제를 해결하려고 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 지연로딩이라는 방법을 제공한다.지연 로딩이 가능하려면 실제 엔티티 객체 대신에 조회를 지연할 수 있는 가짜 객체 프록시 객체가 필요하다.7.1.1 프록시 기초EntityManager.find()는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회한다.Member meber = em.find(Member.class, &quot;member1&quot;);이렇게 직접 조회하면 사용하든 안하든 데이터베이스를 조회한다. 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를미루고 싶다면 EntityManager.getReference()를 사용하면 된다.Member member = em.getReference(Member.class, &quot;member1&quot;);이 메서드를 호출할 때 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다.대신에 데이터베이스 접근을 위임한 프록시 객체를 반환한다. 프록시 조회그림 프록시의 특징 프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같다.사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다. 프록시 객체는 실제 객체에 대한 참조target를 보관한다. 프록시 객체의 메서드를 호출하면 프록시 객체는 실제 객체의 메서드를 호출한다. 프록시 객체의 초기화 프록시 객체는 member.getName() 처럼 실제 사용될 떄 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데이것을 프록시 객체의 초기화라 한다. // MemberProxy 반환Member member = em.gerReference(Member.class, &quot;id1&quot;);member.getName(); // 1.getName() 프록시 클래스 예상 코드 class MemberProxy extends Member { Member target = null; // 실제 엔티티 참조 public String getName() { if (target == null) { // 2. 초기화 요청 // 3. DB 조회 // 4. 실제 엔티티 생성 및 참조 보관 this.target = ...; } // 5. target.getName(); return target.getName(); } } 프록시 초기화 그림 프록시 객체에 member.getName()을 호출해서 실제 데이터를 조회한다. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라 한다. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 필드에 보관한다. 프록시 객체는 실제 엔티티 객체의 getName()을 호출해서 결과를 리턴한다. 프록시의 특징 프록시 객체는 처음 사용할 때 한 번만 초기화된다. 프록시 객체를 초기화해도 실제 엔티티로 바뀌는 것은 아니다. 초기화 되면 실제 엔티티에 접근 가능하다. 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다. 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다. 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 준영속 상태의 프록시를 초기화하면 문제가 발생한다. 준영속 상태와 초기화 // MemberProxy 반환Member member = em.getReference(Member.class, &quot;id1&quot;);transaction.commit();em.close(); // 영속성 컨텍스트 종료 member.getName(); // 준영속 상태에서 초기화 시도, // hibernate.LazyInitializationException 발생 7.1.2 프록시와 식별자엔티티를 프록시로 조회할 때 식별자PK 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.Team team = em.getReference(Team.class, &quot;team1&quot;); // 식별자 보관team.getId(); // 초기화되지 않음단 엔티티 접근 방식을 프로퍼티@Access(AccessType.PROPERTY)로 설정한 경우에만 초기화하지 않는다.접근 방식을 필드@Access(AccessType.FIELD)로 설정하면 JPA는 getId()가 id만 조회하는 메서드인지 다른 필드까지 활용하는메서드인지 알지 못하므로 프록시 객체를 초기화한다.프록시는 연관관계를 설정할 때 유용하게 사용할 수 있다.Member member = em.find(Member.class, &quot;member1&quot;);Team team = em.getReference(Team.class, &quot;team1&quot;); // SQL을 실행하지 않음member.setTeam(team);연관관계를 설정할 때는 식별자 값만 사용하므로 프록시를 사용하면 데이터베이스 접근 횟수를 줄일 수 있다.연관관계를 설정할 때는 엔티티 접근 방식이 필드여도 프록시를 초기화하지 않는다.7.1.3 프록시 확인JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object entity) 메서드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다.boolean isLoaded = emf.getPersistenceUnitUtil().isLoaded(entity);조회한 엔티티가 프록시로 조회한 것인지 확인하려면 클래스명을 직접 출력해보면 된다.7.2 즉시 로딩과 지연 로딩JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 두 가지 방법을 제공한다. 즉시 로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다. 설정 방법: @ManyToOne(fetch = FetchType.EAGER) 지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다. 설정 방법: @ManyToOne(fetch = FetchType.LAZY) 7.2.1 즉시 로딩 즉시 로딩 설정@Entitypublic class Member { ... @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = &quot;team_id&quot;) private Team team; ... } 즉시 로딩 실행 코드Member member = em.find(Member.class, &quot;member1&quot;);Team team = member.getTeam();이때 회원과 팀 두 테이블을 조회해야 하므로 쿼리를 2번 실행할 것 같지만, 대부분의 JPA 구현체는 즉시 로딩을 최적화 하기 위해 가능하면 조인 쿼리를 사용한다. 이후 getTeam()을 호출하면 이미 로딩된 팀1 엔티티를 반환한다.7.2.2 지연 로딩 지연 로딩 설정@Entitypublic class Member { ... @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;team_id&quot;) private Team team; ... } 지연 로딩 실행 코드Member member = em.find(Member.class, &quot;member1&quot;);Team team = member.getTeam();team.getName();em.find(Member.class, &quot;member1&quot;)를 호출하면 회원만 조회하고 팀은 조회하지 않는다. 대신에 조회한 회원의 team 멤버 변수에 프록시 객체를 넣어둔다.이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다. 실제 사용될 때 데이터베이스를 조회해서 프록시 객체를 초기화한다.7.2.3 즉시, 지연 로딩 정리 지연 로딩LAZY: 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다. 즉시 로딩EAGER: 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 조인을 사용해서 한 번에 조회한다.7.3 지연 로딩 활용 회원은 팀 하나에만 소속할 수 있다. (N:1) 회원은 여러 주문내역을 가진다. (1:N) 주문내역은 상품정보를 가진다.(N:1)애플리케이션 로직을 분석해본 결과, Member와 Team은 자주 함께 사용되었다. 그래서 즉시 로딩으로 설정했다. Order와 Product도 마찬가지다. Member와 Order는 가끔 사용되었다. 그래서 지연 로딩으로 설정했다.7.3.1 프록시와 컬렉션 래퍼하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경하는데 이것을 컬렉션 래퍼라고 한다.Member meber = em.find(Member.class, &quot;member1&quot;);List&amp;lt;Order&amp;gt; orders = member.getOrders();System.out.println(&quot;orders = &quot; + orders.getClass().getName());// 결과: orders = org.hibernate.collection.internal.PersistentBag엔티티를 지연 로딩하면 프록시 객체를 사용해서 지연 로딩을 수행하지만 컬렉션은 컬렉션 래퍼가 지연 로딩을 처리해준다.컬렉션은 member.getOrders().get(0)처럼 컬렉션에서 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화한다.7.3.2 JPA 기본 페치 전략 @ManyToOne, @OneToOne: 즉시 로딩FetchType.EAGER @OneToMany, @ManyToMany: 지연 로딩FetchType.LAZY연관된 엔티티가 하나면 즉시 로딩, 컬렉션이면 지연 로딩을 사용한다. 컬렉션을 로딩하는 것은 비용이 많이 들고 너무 많은 데이터를 로딩할 수 있기 때문이다.7.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다. 일대다 조인은 결과 데이터가 다N의 수만큼 증가하게 된다.문제는 서로 다른 컬렉션을 2개 이상 조인하면 SQL 실행 결과가 N * M이 되면서 너무 많은 데이터를 반환해 앱 성능이 저하될 수 있다. JPA는 이렇게 조회된 결과를 메모리에서 필터링해서 반환한다. 따라서 2개 이상의 컬렉션을 즉시 로딩으로 설정하는 것은 권장하지 않는다. 컬렉션 즉시 로딩은 항상 외부 조인OUTER JOIN을 사용한다. 다대일 관계인 회원 테이블과 팀 테이블을 조회할 때 회원 테이블의 외래 키에 not null 제약조건을 걸어두면 모든 회원은 팀에 소속되므로 항상 내부 조인을 해도 되지만 반대로 팀 테이블에서 회원 테이블로 일대다 관계를 조인할 때 회원이 한 명도 없는 팀을 내부 조인하면 팀까지 조회되지 않는 문제가 생긴다.데이터 제약조건으로도 이런 상황을 막을 수 없기 때문에 JPA는 일대다 관계를 즉시 로딩할 때 항상 외부 조인을 사용한다. ManyToOne, @OneToOne (optional = false): 내부 조인 (optional = true): 외부 조인 OneToMany, @ManyToMany (optional = false): 외부 조인 (optional = true): 외부 조인 7.4 영속성 전이: CASCADE특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이transitive persistence 기능을 사용하면 된다. JPA는 CASCADE 옵션으로 영속성 전이를 제공한다.쉽게 말해서 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장되는 것이다.7.4.1 영속성 전이: 저장@Entitypublic class Parent { ... @OneToMany(mappedBy = &quot;parent&quot;, cascade = CascadeType.PERSIST) private List&amp;lt;Child&amp;gt; children = new ArrayList&amp;lt;&amp;gt;(); ...}이 옵션을 적용하면 간편하게 부모와 자식 엔티티를 한 번에 영속화할 수 있다.private static void saveWithCascade(final EntityManager em) { Child child1 = new Child(); Child child2 = new Child(); Parent parent = new Parent(); child1.setParent(parent); child2.setParent(parent); parent.getChildren().add(child1); parent.getChildren().add(child2); em.persist(parent); // 부모 저장, 연관된 자식들도 저장}영속성 전이는 연관관계를 매핑하는 것과는 관련이 없다. 단지 엔티티를 영속화할 때 연관된 엔티티를 같이 영속화하는 것이다.그래서 예제에서도 양방향 연관관계를 직접 추가한 다음 영속 상태로 만든 것을 확인할 수 있다.7.4.2 영속성 전이: 삭제CascadeType.REMOVE로 설정하고 부모 엔티티만 삭제하면 연관된 자식 엔티티도 함께 삭제된다.Parent findParent = em.find(Parent.class, 1L);em.remove(findParent);코드를 실행하면 DELETE SQL을 3번 실행하고 부모는 물론 연관된 자식도 모두 삭제한다. 삭제 순서는 외래 키 제약조건을 고려해서 자식을 먼저 삭제하고 부모를 삭제한다.만약 CascadeType.REMOVE 옵션이 없다면 부모 엔티티만 삭제된다. 하지만 데이터베이스의 부모 로우를 삭제하는 순간 자식 테이블에 걸려 있는 외래 키 제약조건으로 인해, 외래 키 무결성 예외가 발생한다.7.4.3 CASCADE의 종류 CascadeType enum 클래스public enum CascadeType { ALL, // 모두 적용 PERSIST, // 영속 MERGE, // 병합 REMOVE, // 삭제 REFRESH, DETACH}cascade = {CascadeType.PERSIST, CascadeType.REMOVE} 처럼 사용할 수 있다.참고로 CascadeType.PERSIST, REMOVE는 em.persist(), em.remove()를 실행할 때가 아니라 플러시를 호출할 때전이가 발생한다.7.5 고아 객체JPA는 부모 엔티티와 연관관계가 끊긴 자식 엔티티를 자동 삭제하는 기능을 제공하는데 이것을 고아ORPHAN 객체 제거라 한다.부모 엔티티의 컬렉션에서 자식 엔티티의 차몾만 제거하면 자식 엔티티가 자동으로 삭제되도록 해보자. 고아 객체 제거 기능 설정@Entitypublic class Parent { @Id @GeneratedValue private Long id; @OneToMany(mappedBy = &quot;parent&quot;, orphanRemoval = true) private List&amp;lt;Child&amp;gt; children = new ArrayList&amp;lt;&amp;gt;(); ...}Parent parent1 = em.find(Parent.class, id);parent1.getChildren().remove(0); // 자식 엔티티를 컬렉션에서 제거orphanRemoval 옵션으로 인해 컬렉션에서 엔티티를 제거하면 데이터베이스의 데이터도 삭제된다.고아 객체 제거 기능은 영속성 컨텍스트를 플러시할 때 적용되므로 플러시 시점에 DELETE SQL이 실행된다.고아 객체 제거는 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.따라서 이 기능은 특정 엔티티가 개인 소유하는 엔티티에만 적용해야 한다. 만약 삭제한 엔티티를 다른 곳에서도 참조한다면문제가 발생할 수 있다. 이러한 이유로 oprphanRemoval은 @OneToOne, @OneToMany에만 사용할 수 있다.고아 객체 제거는 개념적으로 볼 때 부모를 제거하면 자식은 고아가 되므로 부모를 제거하면 자식도 같이 제거된다.이것은 CascadeType.REMOVE를 설정한 것과 같다.7.6 영속성 전이 + 고아 객체, 생명 주기일반적으로 엔티티는 EntityManager.persist()를 통해 영속화되고 EntityManager.remove()를 통해 제거된다.이것은 엔티티 스스로 생명주기를 관리한다는 뜻이다. 여기서 CascadeType.ALL + orphanRemoval = true 를 동시에 활성화하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다. 자식을 저장하려면 부모에 등록만 하면 된다CASCADE. Parent parent = em.find(Parent.class, parentId);parent.addChild(child1); 자식을 삭제하려면 부모에서 제거하면 된다orphanRemoval Parent parent = em.find(Parent.class, parentId);parent.getChildren().remove(removeChild); 7.7 정리이 장에서 다룬 주요 내용을 정리해보자. JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 지원하는데 이때 프록시 기술을 사용한다. 객체를 조회할 때 연관된 객체를 즉시 로딩하는 방법을 즉시 로딩이라 하고, 연관된 객체를 지연해서 로딩하는 방법을 지연 로딩이라 한다. 객체를 저장하거나 삭제할 때 연관된 객체도 함께 저장하거 삭제할 수 있는데 이것을 영속성 전이라 한다. 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 제거 기능을 사용하면 된다." }, { "title": "자바 ORM 표준 JPA 프로그래밍(희망편06)", "url": "/posts/JPA-CH06/", "categories": "JPA", "tags": "", "date": "2022-04-25 21:20:01 +0900", "snippet": "고급 매핑이 장에서 배울 고급 매핑은 다음과 같다. 상속 관계 매핑: 객체의 상속 관계를 어떻게 데이터베이스에 매핑하는지 배운다. @MappedSuperclass: 등록일, 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속 받고 싶으면이 기능을 사용하면 된다. 복합 키와 식별 관계 매핑: 데이터베이스의 식별자가 하나 이상일 때 매핑하는 방법을 다룬다.그리고 데이터베이스 설계에서 이야기하는 식별 관계와 비식별 관계에 대해서도 다룬다. 조인 테이블: 테이블은 외래 키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는 연결 테이블을 두는 방법도 있다.여기서는 이 연결 테이블을 매핑하는 방법을 다룬다. 엔티티 하나에 여러 테이블 매핑하기: 보통 엔티티 하나에 테이블 하나를 매핑하지만 엔티티 하나에 여러 테이블을 매핑하는 방법도 있다.6.1 상속 관계 매핑관계형 데이터베이스에는 객체지향 언어에서 다루는 상속이라는 개념이 없다. 대신 슈퍼타입 서브타입 관계Super-Type Sub-Type Relationship라는 모델링 기법이 객체의 상속 개념과 가장 유사하다.ORM에서의 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것이다. 슈퍼타입 서브타입 논리 모델 객체 상속 모델슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 때는 3가지 방법이 있다. 각각의 테이블로 변환: 각각의 테이블로 만들고 조회할 때 조인을 사용. JPA에서는 조인 전략 이라고 한다. 통합 테이블로 변환: 테이블 하나만 사용해서 통합한다. JPA에선 단일 테이블 전략이라 한다. 서브타입 테이블로 변환: 서브 타입마다 하나의 테이블을 만든다. JPA에선 구현 클래스마다 테이블 전략이라 한다.위 그림의 객체 상속 모델을 위 3가지 방법으로 매핑해보자.6.1.1 조인 전략조인 전략Joined Strategy은 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략이다. 따라서 조회할 때 조인을 자주 사용한다. 이 전략을 사용할 때 주의할 점은 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없으므로 타입을 구분하는 컬럼을추가해야 한다. (여기서는 DTYPE 컬럼을 구분 컬럼으로 사용한다.) JOINED TABLE 조인 전략 매핑 코드매핑 정보를 분석해보자. @Inheritance(strategy = InheritanceType.JOINED): 상속 매핑은 부모 클래스에 @Inheritance를 사용해야 한다.그리고 매핑 전략을 조인 전략으로 지정해 주었다. @DiscriminatorColumn(name = “DTYPE”): 부모 클래스에 구분 컬럼을 지정한다. 이 컬럼으로 저장된 자식 테이블을 구분할 수 있다. 기본값이 DTYPE이므로 @DiscriminatorColumn으로 줄여서 사용해도 된다. @DiscriminatorValue(“M”): 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정한다. 만약 영화 엔티티를 저장하면 구분 컬럼인 DTYPE에 M이 저장된다.기본 값으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하는데, 만약 자식 테이블의 기본 키 컬럼명을 변경하고 싶으면@PrimaryKeyJoinColumn을 사용하면 된다.BOOK 테이블의 item_id 기본 키 컬럼명을 book_id로 변경했다.조인 전략을 정리해보자. 장점 테이블이 정규화된다. 외래 키 참조 무결성 제약조건을 활용할 수 있다. 저장공간을 효율적으로 사용한다. 단점 조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있다. 조회 쿼리가 복잡하다. 데이터를 등록하는 INSERT를 두 번 실행한다. 특징 JPA 표준 명세는 구분 컬럼을 사용하도록 하지만 하이버네이트를 포함한 몇몇 구현체는 구분 컬럼@DiscriminatorColumn없이도 동작한다. 관련 애노테이션 @PrimaryKeyJoinColumn, @DiscriminatorColumn, @DiscriminatorValue 6.1.2 단일 테이블 전략단일 테이블 전략Single-Table Strategy은 이름 그래도 테이블을 하나만 사용한다. 그리고 구분 컬럼DTYPE으로 어떤 자식 데이터가 저장되었는지 저장한다. 조회할 때 조인을 사용하지 않으므로 일반적으로 가장 빠르다. SINGLE TABLE이 전략을 사용할 때 주의점은 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다는 점이다.Book 엔티티를 저장하면 ITEM 테이블의 AUTHOR, ISBN 컬럼을 제외한 컬럼은 사용하지 않으므로 null이 입력되기 때문이다. 단일 테이블 전략 매핑단일 테이블 전략은 테이블 하나에 모든 것을 통합하므로 구분 컬럼을 필수로 사용해야 한다. 단일 테이블 전략의 장단점은하나의 테이블을 사용하는 특징과 관련이 있다. 장점 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다. 조회 쿼리가 단순하다. 단점 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다. 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다. 특징 구분 컬럼을 꼭 사용해야 한다. 따라서 @DiscriminatorColumn을 꼭 설정해야 한다. @DiscriminatorValue를 지정하지 않으면 기본으로 엔티티 이름을 사용한다. 예: Movie, Album, Book 6.1.3 구현 클래스마다 테이블 전략구현 클래스마다 테이블 전략Table-per-Concrete-Class Strategy은 자식 엔티티마다 테이블을 만든다. 그리고 자식 테이블 각각에필요한 컬럼이 모두 있다. CONCRETE TABLE 구현 클래스마다 테이블 전략 매핑구현 클래스마다 테이블 전략은 자식 엔티티마다 테이블을 만든다. 일반적으로 추천하지 않는 전략이다. 장점 서브 타입을 구분해서 처리할 때 효과적이다. not null 제약조건을 사용할 수 있다. 단점 여러 자식 테이블을 함께 조회할 때 성능이 느리다SQL에 UNION을 사용해야 한다. 자식 테이블을 통합해서 쿼리하기 어렵다. 특징 구분 컬럼을 사용하지 않는다. 이 전략은 데이터베이스 설계자, ORM 전문가 모두 추천하지 않는 전략이다. 조인이나 단일 테이블 전략을 고려하자.6.2 @MappedSuperclass지금까지 학습한 상속 관계 매핑은 부모 클래스와 자식 클래스를 모두 데이터베이스 테이블과 매핑했다.부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 @MappedSuperclass를 사용하면 된다.@MappedSuperclass는 비교하자면 추상 클래스와 비슷한데 @Entity는 실제 테이블과 매핑되지만 @MappedSuperclass는 실제 테이블과는 매핑되지 않는다. 이것은 단순히 매핑 정보를 상속할 목적으로만 사용된다.예제를 통해 알아보자. @MappedSuperclass 설명 테이블 @MappedSuperclass 설명 객체회원과 판매자는 서로 관계가 없는 테이블과 엔티티다. 테이블은 그대로 두고 객체 모델의 공통 속성을 부모 클래스로 모으고객체 상속 관계로 만들어보자.여기서 BaseEntity는 테이블과 매핑할 필요가 없고 자식 엔티티에게 공통으로 사용되는 매핑 정보만 제공하면 된다.따라서 @MappedSuperclass를 사용했다. 부모로부터 물려받은 매핑 정보를 재정의하려면 @AttributeOverride나 Overrides를 사용하고, 연관관계를 재정의하려면 @AssociationOverride, Overrides를 사용한다.@Entity@AttributeOverride(name = &quot;id&quot;, column = @Column(name = &quot;member_id&quot;))public class Member extends BaseEntity {...}부모에게 상속받은 id 속성의 컬럼명을 member_id로 재정의했다.둘 이상을 재정의 하려면 @AttributeOverrides를 사용하면 된다.@Entity@AttributeOverrides({ @AttributeOverride(name = &quot;id&quot;, column = @Column(name = &quot;member_id&quot;)) @AttributeOverride(name = &quot;name&quot;, column = @Column(name = &quot;member_name&quot;))})public class Member extends BaseEntity {...}@MappedSuperclass의 특징을 보자. 테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑 정보를 상속하기 위해 사용한다. @MappedSuperclass로 지정한 클래스는 엔티티가 아니므로 영속성 관리 대상이 아니다. 이 클래스를 직접 생성해서 사용할 일은 거의 없으므로 추상 클래스로 만드는 것을 권장한다.정리하자면 @MappedSuperclass는 테이블과는 관계가 없고 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모아주는 역할을 할 뿐이다.@MappedSuperclass를 사용하면 등록일자, 수정일자, 등록자, 수정자 같은 여러 엔티티에서 공통으로 사용하는 속성을효과적으로 관리할 수 있다. 엔티티는 엔티티이거나 @MappedSuperclass로 지정한 클래스만 상속받을 수 있다.6.3 복합 키와 식별 관계 매핑복합 키를 매핑하는 방법과 식별 관계, 비식별 관계를 매핑하는 방법을 알아보자.6.3.1 식별 관계 vs 비식별 관계데이터베이스 테이블 사이에 관계는 외래 키가 기본 키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분한다.두 관계의 특징을 이해하고 어떻게 매핑하는지 알아보자. 식별 관계identifying Relationship 비식별 관계Non-identifying Relationship식별 관계식별 관계는 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계다.PARENT 테이블의 기본 키 PRENT_ID를 받아서 CHILD 테이블의 기본 키 + 외래 키로 사용한다.비식별 관계비식별 관계는 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계다. 필수적 비식별 관계 선택적 비식별 관계PARENT 테이블의 기본 키 PARENT_ID를 받아서 CHILD 테이블의 외래 키로만 사용한다.비식별 관계는 외래 키에 NULL을 허용하는지에 따라 필수적 비식별 관계와 선택적 비식별 관계로 나눈다. 필수적 비식별 관계Mandatory: 외래 키에 NULL을 허용하지 않는다. 연관관계를 필수적으로 맺어야 한다. 선택적 비식별 관계Optional: 외래 키에 NULL을 허용한다. 연관관계를 맺을지 말지 선택할 수 있다.데이터베이스 테이블을 설계할 때 식별 관계나 비식별 관계 중 하나를 선택해야 한다.최근에는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세다. JPA는 두 관계 모두 지원한다.식별 관계와 비식별 관계를 어떻게 매핑하는지 알아보자. 먼저 복합 키를 사용하는 비식별 관계부터 보자.6.3.2 복합 키: 비식별 관계 매핑기본 키를 구성하는 컬럼이 하나면 다음처럼 단순하게 매핑한다.@Entitypublic class Hello { @Id private String id;}둘 이상의 컬럼으로 구성된 복합 기본 키는 다음처럼 매핑하면 될 것 같지만 해보면 매핑 오류가 발생한다.JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야 한다.@Entitypublic class Hello { @Id private String id1; @Id private String id2; // 실행 시점에서 매핑 예외 발생}JPA는 영속성 컨텍스트에 엔티티를 보관할 때 엔티티의 식별자를 키로 사용한다. 그리고 식별자를 구분하기 위해 equals와 hashCode를 사용해서 동등성 비교를 한다.그런데 식별자 필드가 하나일 때는 보통 자바의 기본 타입을 사용하므로 문제가 없지만, 식별자 필드가 2개 이상이면 별도의 식별자 클래스를 만들고 그곳에 equals와 hahCode를 구현해야 한다.JPA는 복합 키를 지원하기 위해 두 가지 방법을 제공한다. @IdClass: 관계형 데이터베이스에 가까운 방법 @EmbededId: 객체지향에 가까운 방법@IdClass위 복합 키 테이블은 비식별 관계고 PARENT는 PARENT_ID1, 2를 묶은 복합 기본 키를 사용한다.따라서 복합 키를 매핑하기 위해 식별자 클래스를 별도로 만들어야 한다.먼저 각각의 기본 키 컬럼을 @Id로 매핑했다. 그리고 @IdClass를 사용해서 ParentId 클래스를 식별자 클래스로 지정했다.@IdClass를 사용할 때 식별자 클래스는 다음 조건을 만족해야 한다. 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다. Serializable 인터페이스를 구현해야 한다. equals, hashCode를 구현해야 한다. 기본 생성자가 있어야 한다. 식별자 클래스는 public이어야 한다.실제 어떻게 사용하는지 알아보자. 먼저 복합 키를 사용하는 엔티티를 저장해보자.em.persist(parent)를 호출하면 영속성 컨텍스트에서 엔티티를 등록하기 직전에 내부에서 Parent.id1, id2를 사용해서식별자 클래스인 ParentId를 생성하고 영속성 컨텍스트의 키로 사용한다.복합 키로 조회해보자.식별자 클래스인 ParentId를 사용해서 엔티티를 조회한다. 이제 자식 클래스를 추가해보자.부모 테이블의 기본 키 컬럼이 복합 키이므로 자식 테이블의 외래 키도 복합 키다. 따라서 외래 키 매핑 시 여러 컬럼을 매핑해야 하므로 @JoinColumns를 사용하고 각각의 외래 키 컬럼을 @JoinColumn으로 매핑한다. 예제처럼 @JoinColumn의 name 속성과 referencedColumnName 속성의 값이 같으면 referencedColumnName은 생략 가능하다.@EmbededId좀 더 객체지향적인 방법인 @EmbededId를 알아보자.Parent 엔티티에서 식별자 클래스를 직접 사용하고 @Embeded 애노테이션을 적어주면 된다. 식별자 클래스@IdClass와는 다르게 @EmbededId를 적용한 식별자 클래스는 식별자 클래스에 기본 키를 직접 매핑한다.@EmbededId를 적용한 식별자 클래스는 다음 조건을 만족해야 한다. @Embeddable 애노테이션을 붙여주어야 한다. Serializable 인터페이스를 구현해야 한다. equals, hashCode를 구현해야 한다. 기본 생성자가 있어야 한다. 식별자 클래스는 public이어야 한다.@EmbededId를 사용한 코드로 엔티티를 저장해보자.parentId를 직접 생성해서 사용하였다. 조회도 해보자.조회 코드도 식별자 클래스 parentId를 직접 사용한다.복합 키와 equals(), hashCode()복합 키는 equals와 hashCode를 필수로 구현해야 한다.ParentId id1 = new ParentId();id1.setId1(&quot;myId1&quot;);id1.setId2(&quot;myId2&quot;);ParentId id2 = new ParentId();id2.setId1(&quot;myId1&quot;);id2.setId2(&quot;myId2&quot;);id1.equals(id2) -&amp;gt; ??id1, id2 인스턴스 둘 다 같은 값을 가지고 있지만 인스턴스는 다르다.equals()를 적절히 오버라이딩했다면 참이겠지만 자바의 모든 클래스는 Object 클래스를 상속받는데 이 클래스가 제공하는기본 equals()는 인스턴스 참조 값 비교인 ==비교동일성 비교를 하기 때문이다.영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리하는데 이 식별자를 비교할 때 equals()와 hashCode()를사용한다. 따라서 식별자 객체의 동등성equals 비교이 지켜지지 않으면 예상과 다른 엔티티가 조회되거나 엔티티를 찾을 수 없는 등엔티티를 관리하는데에 문제가 발생한다.따라서 복합 키는 equals()와 hashCode()를 필수로 구현해야 한다.@IdClass vs @EmbededId@IdClass와 @EmbededId는 각각 장단점이 있으므로 본인의 취향에 맞는 것을 일관성 있게만 사용하면 된다.@EmbededId가 @IdClass와 비교해서 더 객체지향적이고 중복도 없어서 좋아보이긴 하지만 특정 상황에 JPQL이 조금 더 길어질 수 있다.em.createQuery(&quot;select p.id.id1, p.id.id2 from Parent p&quot;); // @EmbededIdem.createQuery(&quot;select p.id1, p.id2 from Parent p&quot;); // @IdClass 복합 키에는 @GenerateValue를 사용할 수 없다. 복합 키를 구성하는 여러 컬럼 중 하나에도 사용할 수 없다.6.3.3 복합 키: 식별 관계 매핑그림을 보면 부모, 자식, 손자까지 계속 기본 키를 전달하는 식별 관계다.식별 관계에서 자식 테이블은 부모 테이블의 기본 키를 포함해서 복합 키를 구성해야 하므로 @IdClass나 @EmbededId를 사용해서 식별자를 매핑해야 한다.@IdClass와 식별 관계 부모 자식 자식 ID 손자 손자 ID식별 관계는 기본 키와 외래 키를 같이 매핑해야 한다. 따라서 식별자 매핑인 @Id와 연관관계 매핑인 ManyToOne을 같이 사용하면 된다. @Id @ManyToOne @JoinColumn(name = &quot;parent_id&quot;) public Parent parent;Child 엔티티의 parent를 보면 @Id로 기본 키를 매핑하면서 @ManyToOne과 JoinColumn으로 외래 키를 같이 매핑한다.@EmbededId와 식별 관계@EmbededId로 식별 관계를 구성할 때는 @MapsId를 사용해야 한다. 부모 자식 자식 ID 손자 손자 ID@EmbededId는 식별 관계로 사용할 연관관계의 속성에 @MapsId를 사용하면 된다. @MapsId는 외래 키와 매핑한 연관관계를 기본 키에도 매핑하겠다는 뜻이다. @MapsId의 속성 값은 @EmbededId를 사용한 식별자 클래스의 기본 키 필드를 지정하면 된다.6.3.4 비식별 관계로 구현방금 예를 들었던 식별 관계 테이블을 복합 키를 사용하지 않는 비식별 관계로 변경해보자.이렇게 복합 키를 사용하지 않는 비식별 관계로 만든 테이블을 매핑해보자.식별 관계의 복합 키를 사용한 코드와 비교하면 매핑도 쉽고 코드도 단순하다. 그리고 복합 키가 없으므로 복합 키 클래스를 만들지 않아도 된다.6.3.5 일대일 식별 관계 식별관계 일대일일대일 식별 관계는 자식 테이블의 기본 키 값으로 부모 테이블의 기본 키 값만 사용한다. 그래서 부모 테이블의 기본 키가 복합 키가 아니면 자식 테이블의 기본 키는 복합 키로 구성하지 않아도 된다. 부모 자식BoardDetail처럼 식별자가 단순히 컬럼 하나면 @MapsId를 사용하고 속성 값은 비워두면 된다.이때 @MapsId는 @Id를 사용해서 식별자로 지정한 BoardDetail.boardId와 매핑된다.일대일 식별 관계를 사용하는 코드를 보자.6.3.6 식별, 비식별 관계의 장단점데이터베이스 설계 관점에서 보면 다음과 같은 이유로 식별 관계 보다는 비식별 관계를 선호한다. 식별 관계는 부모 테이블의 기본 키를 자식 테이블로 전파하면서 자식 테이블의 기본 키 컬럼이 점점 늘어난다.결국 조인할 때 SQL이 복잡해지고 기본 키 인덱스가 불필요하게 커질 수 있다. 식별 관계는 2개 이상의 컬럼을 합해서 복합 기본 키를 만들어야 하는 경우가 많다. 식별 관계를 사용할 때 기본 키로 비즈니스 의미가 있는 자연 키 컬럼을 조합하는 경우가 많다.반면에 비식별 관계는 대리 키를 주로 사용한다.식별 관계의 자연 키 컬럼들이 자식에 손자까지 전파되면 변경하기 힘들다. 식별 관계는 부모 테이블의 기본 키를 자식 테이블의 기본 키로 사용하므로 비식별 관계보다 테이블 구조가 유연하지 못하다.객체 관계 매핑의 관점에서 보면 다음과 같은 이유로 비식별 관계를 선호한다. 일대일 관계를 제외하고 식별 관계는 2개 이상의 컬럼을 묶은 복합 기본 키를 사용한다.JPA에서 복합 키는 별도의 복합 키 클래스를 만들어서 사용해야 하므로 번거롭다. 비식별 관계의 기본 키는 주로 대리키를 사용하는데 JPA는 대리 키를 생성하기 위한 편리한 방법을 제공한다.물론 식별 관계가 가지는 장점도 있다. 기본 키 인덱스를 활용하기 좋고, 특정 상황에 조인 없이 하위 테이블만으로 검색할 수 있다.기본 키 인덱스를 활용하는 예를 보자. 부모 아이디가 A인 모든 자식 조회SELECT * FROM CHILDWHERE PARENT_ID = &#39;A&#39; 부모 아이디가 A고 자식 아이디가 B인 자식 조회SELECT * FROM CHILDWHERE PARENT_ID = &#39;A&#39; AND CHILD_ID = &#39;B&#39;별도의 인덱스를 생성할 필요 없이 기본 키 인덱스만으로 사용했다.이처럼 식별 관계가 가지는 장점도 있으므로 꼭 필요한 곳에는 적절하게 사용하는 것도 좋다.내용을 정리해보자면,ORM 신규 프로젝트 진행시 추천하는 방법은 될 수 있으면 비식별 관계를 사용하고 기본 키는 Long 타입의 대리키를 사용하는 것이다. 대리 키는 비즈니스와 아무 관련이 없으므로 비즈니스가 변경되어도 유연한 대처가 가능하다는 장점이 있다.그리고 식별자 컬럼이 하나여서 쉽게 매핑할 수 있다.그리고 선택적 비식별 관계보다는 필수적 비식별 관계를 사용하는 것이 좋은데, 선택적인 비식별 관계는 NULL을 허용하므로조인할 때에 외부 조인을 사용해야 한다. 반면에 필수적 관계는 NOT NULL로 항상 관계를 보장하므로 내부조인만 사용해도 된다.6.4 조인 테이블데이터베이스 테이블의 연관관계를 설계하는 방법은 크게 2가지이다. 조인 컬럼 사용외래 키 조인 테이블 사용테이블 사용 조인 컬럼 사용 테이블 간에 관계는 주로 조인 컬럼이라 부르는 외래 키 컬럼을 사용해서 관리한다. 예를 들어 회원과 사물함 관계에서 회원이 사물함을 사용하기 전까지는 둘 사이의 관계가 없으므로 회원의 사물함 컬럼은null을 입력해두어야 한다. 이렇게 외래 키에 null을 허용하는 관계를 선택적 비식별 관계라 한다. 때문에 외부 조인OUTER JOIN을 사용해야 하는데, 내부 조인을 사용하면 사물함과 관계가 없는 회원은 조회가 되지 않는다. 조인 테이블 사용 조인 테이블이라는 별도의 테이블을 사용해서 연관관계를 관리한다. 조인 테이블의 가장 큰 단점은 테이블을 하나 추가해야 한다는 점이다. 따라서 관리해야하는 테이블이 늘어나고 회원과 사물함을 조인하려면 조인 테이블까지 추가로 조인해야 한다. 따라서 기본은 조인 컬럼을 사용하고 필요하다고 판단되면 조인 테이블을 사용하자. 조인 테이블에서 배울 내용은 다음과 같다. 객체와 테이블을 매핑할 때 조인 컬럼은 @JoinColumn으로 매핑하고 조인 테이블은 @JoinTable로 매핑한다. 조인 테이블은 주로 다대다 관계를 풀어내기 위해 사용하지만 일대일, 일대다, 다대일 관계에서도 사용한다.일대일, 일대다, 다대일, 다대다 관계를 조인 테이블로 매핑해보자. 조인 테이블을 연결 테이블, 링크 테이블로도 부른다.6.4.1 일대일 조인 테이블일대일 관계를 만들려면 조인 테이블의 외래 키 컬럼 각각에 총 2개의 유니크 제약조건을 걸어야 한다. 조인 컬럼 조인 테이블 일대일 조인 테이블 매핑부모 엔티티를 보면 @JoinColumn 대신에 @JoinTable을 사용했다.@JoinTable의 속성은 다음과 같다. name: 매핑할 조인 테이블 이름 joinColumns: 현재 엔티티를 참조하는 외래 키 inverseJoinColumns: 반대방향 엔티티를 참조하는 외래 키양방향으로 매핑하려면 다음 코드를 추가하면 된다.public class Child { ... @OneToOne(mappedBy=&quot;child&quot;) private Parent parent;}6.4.2 일대다 조인 테이블일대다 관계를 만들려면 조인 테이블의 컬럼 중 다N와 관련된 컬럼인 child_id에 유니크 제약조건을 걸어야 한다.child_id는 기본 키이므로 유니크 제약조건이 걸려있다. 조인 컬럼 조인 테이블 일대다 단방향 조인 테이블 매핑6.4.3 다대일 조인 테이블다대일은 일대다에서 방향만 반대이므로 조인 테이블 모양은 일대다에서 설명한 그림과 같다.다대일, 일대다 양방향 관계로 매핑해보자. 다대일 양방향 조인 테이블6.4.4 다대다 조인 테이블다대다 관계를 만들려면 조인 테이블의 두 컬럼을 합해서 하나의 복합 유니크 제약조건을 걸어야 한다.parent_id, chilid_id는 복합 기본 키이므로 유니크 제약조건이 걸려 있다. 다대다 조인 테이블 다대다 조인 테이블 매핑 조인 테이블에 컬럼을 추가하면 @JoinTable 전략을 사용할 수 없다. 대신에 새로운 엔티티를 만들어서 조인 테이블과매핑해야 한다.6.5 엔티티 하나에 여러 테이블 매핑잘 사용하지는 않지만 @SecondaryTable을 사용하면 한 엔티티에 여러 테이블을 매핑할 수 있다. 하나의 엔티티에 여러 테이블 매핑Board 엔티티는 @Table을 사용해서 BOARD 테이블과 매핑했다. 그리고 @SecondaryTable을 사용해서 BOARD_DETAIL 테이블을 추가로 매핑했다.@SecondaryTable의 속성은 다음과 같다. @Secondary.name: 매핑할 다른 테이블의 이름이다. @Secondary.pkJoinColumns: 매핑할 다른 테이블의 기본 키 컬럼 속성이다.@Column(table = &quot;board_detail&quot;)private String content;content 필드는 @Column(table = “board_detail”)를 사용해서 board_detail 테이블의 컬럼에 매핑했다.title 필드처럼 테이블을 지정하지 않으면 기본 테이블인 board에 매핑된다.더 많은 테이블을 매핑하려면 @SecondaryTables를 사용하면 된다.@SecondaryTables({ @SecondaryTable(name = &quot;board_detail&quot;), @SecondaryTable(name = &quot;bard_file&quot;)})이 방법은 항상 두 테이블을 조회하므로 최적화가 힘들다. 반면에 일대일 매핑은 원하는 부분만 조회할 수 있고 필요할 때 둘을 함께 조회하면 된다.다음 장에서는 객체 그래프를 자유롭게 탐색할 수 있도록 도와주는 지연 로딩과 프록시에 대해 알아보겠다. 그리고 이 장에서 다룬 객체 연관관계를 더 편리하게 관리할 수 있는 방법들도 알아볼 것이다." }, { "title": "자바 ORM 표준 JPA 프로그래밍(희망편05)", "url": "/posts/JPA-CH05/", "categories": "JPA", "tags": "", "date": "2022-04-11 21:20:01 +0900", "snippet": "다양한 연관관계 매핑이번 장에서는 다양한 연관관계를 다룬다. 그 전에 앞 장의 내용을 정리해보자. 다중성 단방향, 양방향 연관관계의 주인먼저 연관관계가 있는 두 엔티티가 일대일 관계인지 일대다 관계인지 다중성을 고려해야 한다.다음으로 두 엔티티 중 한쪽만 참조하는 단방향 관계인지 서로 참조하는 양방향 관계인지 고려해야 한다.마지막으로 양방향 관계면 연관관계의 주인을 정해야 한다. 다중성 연관관계에는 다음과 같은 다중성이 있다. 다대일@ManyToOne 일대다@OneToMany 일대일@OneToOne 다대다@ManyToMany 다중 성을 판단하기 어려울 떄는 반대방향을 생각해보면 된다. 참고로 일대다의 반대방향은 항상 다대일이고,일대일의 반대방향은 항상 일대일이다.보통 다대일과 일대다 관계를 가장 많이 사용하고 다대다 관계는 실무에서 거의 사용하지 않는다. 단방향, 양방향 테이블은 외래 키 하나로 조인을 사용해서 양방향으로 쿼리가 가능하므로 사실상 방향이라는 개념이 없다.반면에 객체는 참조용 필드를 가지고 있는 객체만 연관된 객체를 조회할 수 있다.객체 관계에서 한 쪽만 참조하는 것을 단방향 관계라 하고, 양쪽이 서로 참조하는 것을 양방향 관계라고 한다. 연관관계의 주인 테이블의 연관관계를 관리하는 포인트는 외래 키다. 반면에 엔티티를 양방향으로 매핑하면 A → B, B → A 2곳에서서로 참조한다. 따라서 객체의 연관관계를 관리하는 포인트는 2곳이다. JPA는 두 객체 연관관계 중 하나를 정해서 데이터베이스 외래 키를 관리하는데 이것을 연관관계의 주인이라 한다.따라서 A → B 또는 B → A 둘 중 하나를 정해서 외래 키를 관리해야 한다.외래 키를 가진 테이블과 매핑한 엔티티가 외래 키를 관리하는게 효율적이므로 보통 이곳을 연관관계의 주인으로 선택한다.주인이 아닌 방향은 외래 키를 변경할 수 없고 읽기만 가능하다. 연관관계의 주인은 mappedBy 속성을 사용하지 않는다. 연관관계의 주인이 아니면 mappedBy 속성을 사용하고연관관계의 주인 필드 이름을 값으로 입력해야 한다. 지금부터 다중성과 단방향, 양방향을 고려한 가능한 모든 연관관계를 하나씩 알아보자. 다대일: 단방향, 양방향 일대다: 단방향, 양방향 일대일: 주 테이블 단방향, 양방향 일대일: 대상 테이블 단방향, 양방향 다대다: 단방향, 양방향참고로 다중성은 왼쪽을 연관관계의 주인으로 정했다. 다대일 양방향이라 하면 다N가 연관관계의 주인이다.6.1 다대일다대일 관계의 반대 방향은 항상 일대다 관계고 일대다 관계의 반대 방향은 항상 다대일 관계다.데이터베이스 테이블의 일, 다 관계에서 외래키는 항상 다쪽에 있다. 따라서 객체 양방향 관계에서 연관관계의 주인은 항상다쪽이다. 예를들어 회원N과 팀1이 있으면 회원 쪽이 연관관계의 주인이다.6.1.1 다대일 단방향 [N:1] 다대일 단방향회원, 팀 엔티티 코드를 통해 다대일 단방향 연관관계를 알아보자. 회원 엔티티```java@Entity@Getter @Setterpublic class Member {@Id@GeneratedValue@Column(name = &quot;MEMBER_ID&quot;)private Long id;private String username;@ManyToOne@JoinColumn(name = &quot;TEAM_ID&quot;)private Team team; } ``` 팀 엔티티```java@Entitypublic class Team {@Id@GeneratedValue@Column(name = &quot;TEAM_ID&quot;)private Long id;private String name; }회원은 Member.team으로 팀 엔티티를 참조할 수 있지만 반대로 팀에는 회원을 참조하는 필드가 없다.따라서 회원과 팀은 다대일 단방향 연관관계이다.```java@ManyToOne@JoinColumn(name = &quot;TEAM_ID&quot;)private Team team;@JoinColumn(name = “TEAM_ID”)를 사용해서 Member.team 필드를 TEAM_ID 외래 키와 매핑했다.따라서 Member.team 필드로 회원 테이블의 TEAM_ID 외래 키를 관리한다.6.1.2 다대일 양방향 [N:1, 1:N]다대일 양방향의 객체 연관관계에서 실선이 연관관계의 주인Member.team이고 점선Team.members은 주인이 아니다. 다대일 양방향 다대일 양방향 회원 엔티티```java@Entity@Getterpublic class Member {@Id@GeneratedValue@Column(name = &quot;MEMBER_ID&quot;)private Long id;private String username;@ManyToOne@JoinColumn(name = &quot;TEAM_ID&quot;)private Team team;public void setTeam(Team team){ this.team = team; if(!team.getMembers().contains(this)){ team.getMembers().add(this); }} }&amp;gt; *다대일 양방향 팀 엔티티*```java@Entity@Getterpublic class Team { @Id @GeneratedValue @Column(name = &quot;TEAM_ID&quot;) private Long id; private String name; @OneToMany(mappedBy = &quot;team&quot;) private List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;&amp;gt;();} 양방향은 외래 키가 있는 쪽이 연관관계의 주인이다. 일대다와 다대일 연관관계는 항상 다N에 외래 키가 있다. 여기서는 다쪽인 MEMBER 테이블이 외래 키를 가지고 있으므로Member.team이 연관관계의 주인이다. JPA는 외래 키를 관리할 때 연관관계의 주인만 사용한다. 주인이 아닌 Team.members는 조회를 위한 JPQL이나 객체 그래프를 탐색할 때 사용한다. 양방향 연관관계에서는 항상 서로를 참조해야 한다. 어느 한 쪽만 참조하면 양방향 연관관계가 성립하지 않는다. 항상 서로를 참조하게 하려면 연관관계 편의 메서드를 작성하는 것이 좋다. 편의 메서드는 한 곳 또는 양쪽 다 작성할 수 있는데, 양쪽에 다 작성할 경우 무한루프에 빠지므로 주의해야 한다. 6.2 일대다일대다 관계는 다대일 관계의 반대 방향이다. 일대다 관계는 엔티티를 하나 이상 참조할 수 있으므로 자바 컬렉션 중에 하나를 사용해야 한다.6.2.1 일대다 단방향 [1:N]팀은 회원들을 참조하지만 반대로 회원은 팀을 참조하지 않으면 둘의 관계는 단방향이다. (JPA 2.0 부터 지원) 일대다 단방향일대다 단방향 관계는 약간 특이한데 팀 엔티티의 Team.members로 회원 테이블의 team_id 외래 키를 관리한다.보통 자신이 매핑한 테이블의 외래 키를 관리하는데, 이 매핑은 반대쪽 테이블에 있는 외래 키를 관리한다. 그럴 수 밖에 없는 것이 일대다 관계에서 외래 키는 항상 다쪽 테이블에 있다. 하지만 다 쪽인 Member 엔티티에는 외래 키를매핑할 수 있는 참조 필드가 없다. 대신에 반대쪽인 Team 엔티티에만 참조 필드인 members가 있다. 따라서 반대편 테이블의 외래 키를 관리하는 특이한 모습이 나타난다. 일대다 단방향 팀 엔티티```java@Entitypublic class Team {@Id @GeneratedValue@Column(name = &quot;TEAM_ID&quot;)private long id;private String name;@OneToMany@JoinColumn(name = &quot;TEAM_ID&quot;) // MEMBER 테이블의 TEAM_IDprivate List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;Member&amp;gt;(); }&amp;gt; *일대다 단방향 회원 엔티티*```java@Entitypublic class Member { public Member() {} public Member(String userName) { this.userName = userName; } public Member(Long id, String userName) { this.id = id; this.userName = userName; } @Id @Column(name = &quot;MEMBER_ID&quot;) @GeneratedValue private Long id; // 타입은 숫자형 @Column(name = &quot;NAME&quot; ) private String userName; private int age;일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 한다. 그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용해서 매핑한다. 조인 테이블은 7장에서 다룬다. 일대다 단방향 매핑의 단점 본인 테이블에 외래 키가 있으면 엔티티의 저장과 연관관계 처리를 INSERT 한 번으로 끝낼 수 있지만, 다른 테이블에 있다면 연관관계 처리를 위한 UPDATE를 추가로 실행해야 한다. Member member1 = new Member(&quot;member1&quot;);Member member2 = new Member(&quot;member2&quot;); Team team1 = new Team(&quot;team1&quot;);team.getMembers().add(member1);team.getMembers().add(member2); em.persist(member1); // INSERT-member1em.persist(member2); // INSERT-member2em.persist(team1); // INSERT-team1, UPDATE-member1.fk, member2.fk transaction.commit(); 위 예제를 실행한 결과 SQL은 다음과 같다. INSERT INTO member (member_id, username) VALUES (null, ?)INSERT INTO member (member_id, username) VALUES (null, ?)INSERT INTO team (team_id, name) VALUES (null, ?)UPDATE member SET team_id=? WHERE member_id=?;UPDATE member SET team_id=? WHERE member_id=?; Member 엔티티는 Team 엔티티를 모르고 연관관계에 대한 정보는 Team.members가 관리하므로 Member 엔티티를 저장할 떄는 MEMBER 테이블의 team_id 외래 키에 아무 값도 저장되지 않는다. 대신 Team 엔티티를 저장할 때 Team.members의 참조 값을 확인해서 회원 테이블에 있는 team_id 외래 키를 업데이트한다. 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자 이 경우 다른 테이블의 외래 키를 관리해야 하므로 성능 문제도 있지만 관리가 어려워진다. 6.2.2 일대다 양방향 [1:N, N:1]일대다 양방향 매핑은 존재하지 않는다. 대신 다대일 양방향 매핑을 사용해야 한다.더 정확히 말하자면 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없다. 관계형 데이터베이스 특성상일대다, 다대일 관계는 항상 다 쪽이 외래 키가 있다. 따라서 연관관계의 주인은 @ManyToOne을 사용한 곳이다.이런 이유로 @ManyToOne에는 mappedBy 속성이 없다.일대다 양방향 매핑이 완전히 불가능한 것은 아니지만 되도록 다대일 양방향 매핑을 사용하자.6.3 일대일 [1:1]일대일 관계는 양쪽이 서로 하나의 관계만 가진다. 예를 들어 회원과 사물함의 관계다.일대일 관계는 다음과 같은 특징이 있다. 일대일 관계는 그 반대도 일대일 관계다. 주 테이블이나 대상 테이블 중 어느 곳이나 외래 키를 가질 수 있다.일대일 관계는 주 테이블이나 대상 테이블 중 누가 외래 키를 가질 지 선택해야 한다. 주 테이블에 외래 키 주객체가 대상 객체를 참조하는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 참조한다.외래 키를 객체 참조와 비슷하게 사용할 수 있어 객체지향 개발자들이 선호하는 방식이다.이 방법의 장점은 주 테이블이 외래 키를 가지고 있으므로 주 테이블만 확인해도 대상 테이블과 관계가 있는지 알 수 있다. 대상 테이블에 외래 키 데이터베이스 개발자들은 보통 대상 테이블에 외래 키를 두는 것을 선호한다. 이 방법의 장점은 테이블 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 그대로 유지할 수 있다. 6.3.1 주 테이블에 외래 키일대일 관계를 구성할 때 객체지향 개발자들은 주 테이블에 외래 키가 있는 것을 선호한다. JPA도 주 테이블에 외래 키가 있으면좀 더 편리하게 매핑할 수 있다. 주 테이블에 외래 키가 있는 단방향 관계를 보고 양방향 관계도 보자.단방향회원과 사물함의 일대일 단방향 관계를 알아보자. 일대일 주 테이블에 외래 키, 단방향@Entitypublic class Member { @Id @GeneratedValue @Column(name = &quot;member_id&quot;) private Long id; private String username; @OneToOne @JoinColumn(name = &quot;locked_id&quot;) private Locker locker; ...}@Entitypublic class Locker { @Id @GeneratedValue @Column(name = &quot;locker_id&quot;) private Long id; private String name; ...}일대일 관계이므로 @OneToOne을 사용했고 데이터베이스에는 locker_id 외래 키에 유니크 제약 조건을 추가했다.이 관계는 다대일 단방향@ManyToOne과 거의 비슷하다.양방향 일대일 주 테이블에 외래 키, 양방향@Entitypublic class Member { @Id @GeneratedValue @Column(name = &quot;member_id&quot;) private Long id; private String username; @OneToOne @JoinColumn(name = &quot;locker_id&quot;) private Locker locker; ...}@Entitypublic class Locker { @Id @GeneratedValue @Column(name = &quot;locker_id&quot;) private Long id; private String name; @OneToOne(mappedby = &quot;locker&quot;) private Member member; ...}일대일 매핑에서 대상 테이블에 외래 키를 두고 싶으면 이렇게 양방향으로 매핑한다. 주 엔티티인 Member 엔티티 대신 대상 엔티티인 Locker를 연관관계의 주인으로 만들어서 LOCKER 테이블의 외래 키를 관리하도록 했다.6.4 다대다관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다. 그래서 보통 다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용한다. 예를 들어 회원들은 상품을 주문한다고 하자. 반대로 상품들은 회원들에 의해 주문될 때 둘은 다대다 관계다.그래서 중간에 연결 테이블을 추가해야 한다. N:M 다대다 연결 테이블그런데 객체는 테이블과 다르게 객체 2개에서 컬렉션을 사용해 다대다 관계를 만들 수 있다.@ManyToMany를 사용하면 이런 다대다 관계를 편리하게 매핑할 수 있다.6.4.1 다대다: 단방향 다대다 단방향 회원 엔티티@Entitypublic class Member { @Id @Column(name = &quot;member_id&quot;) private String id; private String username; @ManyToMany @JoinTable(name = &quot;member_product&quot;, joinColumns = @JoinColumn(name = &quot;member_id&quot;), inverseJoinColumns = @JoinColumn(name = &quot;product_id&quot;)) private List&amp;lt;Product&amp;gt; products = new ArrayList&amp;lt;&amp;gt;(); ...} 다대다 단방향 상품 엔티티@Entitypublic class Product { @Id @Column(name = &quot;product_id&quot;) private String id; private String name; ...}회원, 상품 엔티티를 @ManyToMany와 @JoinTable을 사용해서 연결 테이블을 바로 매핑했다.따라서 회원과 상품을 연결하는 Member_Product 엔티티 없이 매핑을 완료할 수 있다.연결 테이블을 매핑하는 @JoinTable의 속성을 정리해보자. @JoinTable.name: 연결 테이블을 지정한다. @JoinTable.joinColumns: 현재 방향인 회원과 매핑할 조인 컬럼 정보를 지정한다. @JoinTable.inverseJoinColumns: 반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다.@ManyToMany로 매핑한 덕분에 다대다 관계를 사용할 때는 연결 테이블을 신경 쓰지 않아도 된다. 다대다 관계 저장 예제public void save() { Product productA = new Product(); productA.setId(&quot;productA&quot;); productA.setName(&quot;상품A&quot;); em.persist(productA); Member member1 = new Member(); member1.setId(&quot;member1&quot;); member1.setUsername(&quot;회원1&quot;); member1.getProducts().add(productA); // 연관관계 설정 em.persist(member1);}회원1과 상품A의 연관관계를 설정했으므로 회원1을 저장할 때 연결 테이블에도 값이 저장된다. 실행 SQLINSERT INTO PRODUCT ...INSERT INTO MEMBER ...INSERT INTO MEMBER_PRODUCT ... 다대다 관계 탐색 예제public void find() { Member member = em.find(Member.class, &quot;member1&quot;); List&amp;lt;Product&amp;gt; products = member.getProducts(); // 객체 그래프 탐색 products.forEach(p -&amp;gt; System.out.println(&quot;product.name = &quot; + p.getName()));}member.getProducts()를 호출해서 상품 이름을 출력하면 다음 SQL이 실행된다.SELECT * FROM MEMBER_PRODUCT MP, PRODUCT PWHERE MP.PRODUCT_ID = P.PRODUCT_ID AND MP.MEMBER_ID=?실행된 SQL을 보면 연결 테이블인 MEMBER_PRODUCT와 상품 테이블을 조인해서 연관된 상품을 조회한다.@ManyToMany 덕분에 복잡한 다대다 관계를 애플리케이션에서는 아주 단순하게 사용할 수 있다.6.4.2 다대다: 양방향다대다 매핑이므로 역방향도 @ManyToMany를 사용한다. 그리고 양쪽 중에 원하는 곳에 mappedBy로 연관관계의 주인을지정한다. 역방향 추가@Entitypublic class Product { @Id private String id; @ManyToMany(mappedBy = &quot;products&quot;) // 역방향 추가 private List&amp;lt;Member&amp;gt; members; ...}다대다 양방향 연관관계는 다음처럼 설정한다.member.getProducts().add(product);product.getMembers().add(member);양방향 연관관계에서는 연관관계 편의 메서드를 사용하는 것이 편리하다.public void addProduct(final Product product) { ... product.add(product); product.getMembers().add(this); }양방향 연관관계이므로 다음처럼 역방향으로 객체 그래프를 탐색할 수 있다.public void findInverse() { Product product = em.find(Product.class, &quot;productA&quot;); List&amp;lt;Member&amp;gt; members = product.getMembers(); members.forEach(m -&amp;gt; System.out.println(&quot;member = &quot; + member.getUsername()));}6.4.3 다대다: 매핑의 한계와 극복, 연결 엔티티 사용@ManyToMany를 사용하면 연결 테이블을 자동으로 처리해주므로 도메인 모델이 단순해지고 여러 가지로 편리하지만,이 매핑을 실무에서 사용하는데에는 한계가 있다.예를 들어 회원이 상품을 주문하면 보통은 연결 테이블에 주문 수량이나 주문한 날짜 같은 컬럼이 더 필요하다. 연결 테이블에 필드 추가하지만 추가할 경우 더이상 @ManyToMany를 사용할 수 없다. 주문 엔티티나 상품 엔티티에는 추가한 컬럼들을매핑할 수 없기 때문이다.결국 연결 테이블을 매핑하는 연결 엔티티를 만들고 이곳에 추가한 컬럼들을 매핑해야 한다.그리고 엔티티 간의 관계도 테이블처럼 다대다에서 일대다, 다대일 관계로 풀어야 한다. 다대다를 푸는 연결 엔티티연결 테이블에 주문 수량과 주문 날짜 컬럼을 추가했다. 회원 엔티티@Entitypublic class Member { @Id @Column(name = &quot;member_id&quot;) private String id; // 역방향 @OneToMany(mappedBy = &quot;member&quot;) private List&amp;lt;MemberProduct&amp;gt; memberProducts; ...}회원과 회원상품을 양방향 관계로 만들었다. 회원 상품MemberProduct 엔티티 쪽이 외래 키를 가지고 있으므로 연관관계의 주인이다.따라서 주인의 아닌 회원의 Member.memberProducts에는 mappedBy를 사용했다. 상품 엔티티@Entitypublic class Product { @Id @Column(name = &quot;product_id&quot;) private String id; private String name; ...}상품 엔티티에선 회원상품 엔티티로 객체 그래프 탐색이 필요치 않다고 판단하여 연관관계를 만들지 않았다.다음으로 가장 중요한 회원상품 엔티티와 식별자 클래스를 보자. 회원상품 엔티티@Entity@IdClass(MemberProductId.class)public class MemberProduct { @Id @ManyToOne @JoinColumn(name = &quot;member_id&quot;) private Member member; // MemberProductId.member와 연결 @Id @ManyToOne @JoinColumn(name = &quot;product_id&quot;) private Product product; // MemberProductId.product와 연결 private int orderAmount; ... } 회원 상품 식별자 클래스public class MemberProductId implements Serializable { private String member; // MemberProduct.member와 연결 private String product; // MemberProduct.product와 연결 @Override public boolean equals(final Object o) {...} @Override public int hashCode() {...} }회원상품 엔티티를 보면 기본 키를 매핑하는 @Id와 외래 키를 매핑하는 @JoinColumn을 동시에 사용해서 기본 키와 외래 키를 한번에 매핑했다. 그리고 @IdClass를 사용해서 복합 기본 키를 매핑했다. 복합 기본 키 회원상품 엔티티는 기본 키가 member_id와 product_id로 이루어진 복합 기본 키다. JPA에서 복합 키를 사용하려면별도의 식별자 클래스를 만들어야 한다. 엔티티에 @IdClass를 사용해서 식별자 클래스를 지정하면 된다. 복합 키를 위한 식별자 클래스는 다음과 같은 특징이 있다. 복합 키는 별도의 식별자 클래스로 만들어야 한다. equals와 hashCode 메서드를 구현해야 한다. 기본 생성자가 있어야 한다. 식별자 클래스는 public이어야 한다. @IdClass를 사용하는 방법 외에 @EmbeddedId를 사용하는 방법도 있다. 식별 관계 회원상품은 회원과 상품의 기본 키를 받아서 자신의 기본 키로 사용한다. 이렇게 부모 테이블의 기본 키를 받아서 자신의 기본 키 + 외래 키로 사용하는 것을 데이터베이스 용어로 식별 관계라 한다. 이렇게 구성한 관계를 어떻게 저장하는지 보자. 저장 예제public void save() { // 회원 저장 Member member1 = new Member(); member1.setId(&quot;member1&quot;); member1.setUsername(&quot;회원1&quot;); em.persist(member1); // 상품 저장 Product productA = new Product(); productA.setId(&quot;productA&quot;); productA.setName(&quot;상품1&quot;); em.persist(productA); // 회원상품 저장 MemberProduct memberProduct = new MemberProduct(); memberProduct.setMember(member1); //주문 회원 - 연관관계 설정 memberProduct.setProduct(productA); //주문 상품 - 연관관계 설정 memberProduct.setOrderAmount(2); //주문 수량 em.persist(memberProduct);}회원 상품 엔티티는 데이터베이스에 저장될 때 연관된 회원의 식별자와 상품의 식별자를 가져와서 자신의 기본 키 값으로 사용한다. 조회 예제public void find() { // 기본 키 값 생성 MemberProductId memberProductId = new MemberProductId(); memberProductId.setMember(&quot;member1&quot;); memberProductId.setProduct(&quot;productA&quot;); MemberProduct memberProduct = em.find(MemberProduct.class, memberProductId); Member member = memberProduct.getMember(); Product product = memberProduct.getProduct(); System.out.println(&quot;member = &quot; + member.getUsername()); System.out.println(&quot;produdct = &quot; + proudct.getName()); System.out.println(&quot;orderAmount = &quot; + memberProduct.getOrderAmount());}지금까지는 기본 키가 단순해서 기본 키를 위한 객체를 사용하는 일은 없었는데 복합 키가 되면 이야기가 달라진다.복합 키는 항상 식별자 클래스를 만들어야 한다. em.find()를 보면 생성한 식별자 클래스로 엔티티를 조회한다.복합 키를 사용하는 방법은 복잡하다. 식별자 클래스 @IdClass 또는 @EmbeddedId 사용 식별자 클래스 내 equals, hashCode 구현복합 키를 사용하지 않고 간단히 다대다 관계를 구현하는 방법을 알아보자.6.4.4 다대다: 새로운 기본 키 사용추천하는 기본 키 생성 전략은 데이터베이스에서 자동으로 생성해주는 대리 키를 Long 값으로 사용하는 것이다.이것의 장점은 간편하고 거의 영구히 쓸 수 있으며 비즈니스에 의존하지 않는다.그리고 ORM 매핑 시에 복합 키를 만들지 않아도 되므로 간단히 매핑할 수 있다.이번엔 연결 테이블에 새로운 기본 키를 사용해보자. 그리고 회원상품MemberProduct보다는 주문Order가 어울리니 변경하자. ORDER는 일부 데이터베이스postgresql 포함에서 예약어로 잡혀 있으므로 ORDERS를 사용하기도 한다. N:M 다대다 새로운 기본 키​ 새로운 order_id라는 새로운 기본 키를 하나 만들고 member_id, product_id 컬럼은 외래 키로만 사용한다. 주문Orders 예제@Entitypublic class Orders { @Id @GeneratedValue @Column(name = &quot;order_id&quot;) private Long id; @ManyToOne @JoinColumn(name = &quot;member_id&quot;) private Member member; @ManyToOne @JoinColumn(name = &quot;product_id&quot;) private Product product; private int orderAmount; ...}대리 키를 사용함으로써 이전에 보았던 식별 관계에 복합 키를 사용하는 것보다 매핑이 단순하고 이해하기 쉽다.회원 엔티티와 상품 엔티티는 변경 사항이 없다. 회원, 상품 엔티티@Entitypublic class Member { @Id @Column(name = &quot;member_id&quot;) private String id; // 역방향 @OneToMany(mappedBy = &quot;member&quot;) private List&amp;lt;MemberProduct&amp;gt; memberProducts; ...}@Entitypublic class Product { @Id @Column(name = &quot;product_id&quot;) private String id; private String name; ...} 저장, 조회 예제public void save() { // 회원 저장 Member member1 = new Member(); member1.setId(&quot;member1&quot;); member1.setUsername(&quot;회원1&quot;); em.persist(member1); // 상품 저장 Product productA = new Product(); productA.setId(&quot;productA&quot;); productA.setName(&quot;상품1&quot;); em.persist(productA); // 회원상품 저장 Orders orders = new Orders(); orders.setMember(member1); //주문 회원 - 연관관계 설정 orders.setProduct(productA); //주문 상품 - 연관관계 설정 orders.setOrderAmount(2); //주문 수량 em.persist(orders);}public void find() { Long orderId = 1L; Orders orders = em.find(Orders.class, orderId); Member member = orders.getMember(); Producut product = orders.getProduct(); System.out.println(&quot;member = &quot; + member.getUsername()); System.out.println(&quot;produdct = &quot; + proudct.getName()); System.out.println(&quot;orderAmount = &quot; + orders.getOrderAmount());}식별자 클래스를 사용하지 않으므로 코드가 단순해졌다. 이렇게 새로운 기본 키를 사용해서 다대다 관계를 풀어내는 것도 좋은 방법이다.6.4.5 다대다 연관관계 정리다대다 관계를 일대다 다대일 관계로 풀어내기 위해 연결 테이블을 만들 때 식별자를 어떻게 구성할지 선택해야 한다.데이터베이스 설계에서는 다음처럼 분류한다. 식별 관계: 받아온 식별자를 기본 키 + 외래 키로 사용한다. 비식별 관계: 받아온 식별자는 외래 키로만 사용하고 새로운 식별자를 추가한다.객체 입장에서보면 비식별 관계를 사용하는 것이 복합 키를 위한 식별자 클래스를 만들지 않아도 되므로 편리하게 ORM 매핑을 할 수 있다. 이런 이유로 식별 관계보다는 비식별 관계를 추천한다.7장에서 자세히" }, { "title": "자바 ORM 표준 JPA 프로그래밍(희망편04)", "url": "/posts/JPA-CH04/", "categories": "JPA", "tags": "", "date": "2022-03-28 20:28:13 +0900", "snippet": "연관관계 매핑세상에 혼자만 사는 사람이 없듯이 객체 새상에서도 서로 서로 연관이 있다.대부분의 엔티티는 다른 엔티티와 연관관계가 존재한다.RDB에서는 외례키를 이용하여 테이블간의 관계를 정리 한다. 그렇다면 ORM에서는 어떻게 관계를 정리 할까?시작하기 전에 연관관계 매핑의 핵심 키워드들을 확인해보자. 방향Direction: [단방향, 양방향]이 있다. 알기 쉽게 예를 들어보자. 한 연예인이 있다. 너무 유명해서 그 연예인은 모르는 사람이 없다. 그렇다면 그 연예인은 본인을 아는 모든 사람을 알수 있을까?아마도 알기 힘들 것이다. 이러한 한쪽에서만 아는 것은 [단방향], 한쪽이 아닌 양쪽이 모두 안다면 [양방향]이라 칭한다.이러한 방향성은 사실 각 각의 관점에서 보면 [양방향] 이라기 보다는, 두 개의 [단방향]이라 할 수 있다. 다중성Multiplicity: [다대일N:1, 일대다1:N, 일대일1:1, 다대다N:M] 다중성이 있다.위 예를 계속 이용해 보자. 연예인이 한명, 아는 사람이 여러명이라면 [1:N] , 아직은 유명하지 않아 [1:1] 일 수도 있으며, 그룹가수라면 [N:N] 이수도 있다. 연관관계의 주인owner: 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.방향을 설명할 때. 두 새의 단방향이라 할 수 있다고 하였다. 때문에 이러한 관계의 중심이 되는 객체를 선정 해 주어야 한다.이러한 관계의 주인이 되는 객체를 연관관계의 주인 이라 표현한다.5.1 단방향 연관관계연관관계 중에선 다대일N:1 단방향 관계를 가장 먼저 이해해야 한다. 회원과 팀의 관계를 통해 다대일 단방향 연관관계를 알아보자. 회원과 팀이 있다. 회원은 하나의 팀에만 소속될 수 있다. 회원과 팀은 다대일 관계다. *다대일 연관관계 다대일N:1, 단방향* 객체 연관관계 회원 객체는 Member.team 필드로 팀 객체와 연관관계를 맺는다. 회원 객체와 팀 객체는 단방향 관계다. 회원은 Member.team 필드를 통해서 팀을 알 수 있지만반대로 팀은 회원을 알 수 없다.member → team의 조회는 member.getTeam()으로 가능하지만 반대 방향으로 접근하는 필드는 없다. 테이블 연관관계 회원 테이블은 TEAM_ID 외래 키로 팀 테이블과 연관관계를 맺는다. 회원 테이블과 팀 테이블은 양방향 관계다. 회원 테이블의 TEAM_ID 외 키를 통해서 회원과 팀을 조인할 수 있고,반대로 팀과 회원도 조인할 수 있다. 회원과 팀을 조인하는 SQLSELECT *FROM member, teamWHERE member.team_id = team.team_id; 객체 연관관계와 테이블 연관관계의 가장 큰 차이 참조를 통한 연관관계는 언제나 단방향이다. 객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서참조를 보관해야 한다. 결국 연관관계를 하나 더 만들어야 하는 것이다. 이렇게 양쪽에서 서로 참조하는 것을 양방향 연관관계라고 한다. 하지만 정확히 말하면 이것은 양방향 관계가 아니라 서로 다른 단방향 관계 2개다. 반면에 테이블은 외래 키 하나로 양방향으로 조인할 수 있다. 객체 연관관계 vs 테이블 연관관계 정리 객체는 참조로 연관관계를 맺는다. 테이블은 외래 키로 연관관계를 맺는다. 이 둘은 비슷해 보이지만 매우 다른 특징을 가진다. 연관 데이터를 조회할 때 객체는 참조, 테이블은 조인을 사용한다. 참조를 사용하는 객체의 연관관계는 단방향이다. A → B (a.b) 외래 키를 사용하는 테이블의 연관관계는 양방향이다. A JOIN B가 가능하면 B JOIN A도 가능하다. 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다. A → B (a.b) B → A (b.a) 이제 순수한 객체 연관관계 예제와 순수한 테이블 연관관계 예제를 보고 둘을 매핑해보자.5.1.1 순수한 객체 연관관계다음 코드는 JPA를 사용하지 않은 순수하게 객체만 사용한 회원과 팀 클래스의 코드다.public class Member { private String id; private String username; private Team team; // 팀의 참조를 보관 public void setTeam(final Team team) { this.team = team; } // Getter, Setter ... }public class Team { private String id; private String name; // Getter, Setter ... } 동작 코드public static void main(String... args) { // 생성자(id, 이름) Member member1 = new Member(&quot;member1&quot;, &quot;회원1&quot;); Member member2 = new Member(&quot;member2&quot;, &quot;회원2&quot;); Team team1 = new Team(&quot;team1&quot;, &quot;팀1&quot;); member1.setTeam(team1); member2.setTeam(team1); Team findTeam = member1.getTeam();} ` Team findTeam = member1.getTeam();` 처럼 회원1이 속한 팀1을 조회할 수 있다.이처럼 객체는 참조를 사용해 연관관계를 탐색할 수 있는데 이것을 객체 그래프 탐색이라 한다.5.1.2 테이블 연관관계이번에는 데이터베이스 테이블의 회원과 팀의 관계를 살펴보자. 테이블 DDLCREATE TABLE member( member_id varchar(255) primary key, team_id varchar(255), username varchar(255), CONSTRAINT fk_member_team FOREIGN KEY (team_id) REFERENCES team (team_id));CREATE TABLE team( team_id varchar(255) primary key, name varchar(255)); INSERT SQLINSERT INTO team VALUES (&#39;team1&#39;, &#39;팀1&#39;);INSERT INTO member VALUES (&#39;member1&#39;, &#39;team1&#39;, &#39;회원1&#39;), (&#39;member2&#39;, &#39;team1&#39;, &#39;회원2&#39;); 회원 1이 소속된 팀을 조회하는 SQLselect t.*FROM member m, team tWHERE m.team_id = t.team_id and m.member_id = &#39;member1&#39;;이처럼 데이터베이스는 외래 키를 사용해서 연관관계를 탐색할 수 있다.5.1.3 객체 관계 매핑지금까지 객체만 사용한 연관관계와 테이블만 사용한 연관관계를 각각 알아보았으니, 이제 JPA를 사용해서 둘을 매핑해보자. 객체 연관관계: 회원 객체의 Member.team 필드 사용 테이블 연관관계: 회원 테이블의 MEMBER.TEAM_ID 외래 키 컬럼을 사용 @ManyToOne @JoinColumn(name = &quot;team_id&quot;) private Team team; @ManyToOne : 이름 그대로 다대일 관계라는 매핑 정보다. 회원과 팀은 다대일 관계다.연관관계를 매핑할 때 이렇게 다중성을 나타내는 애노테이션을 필수로 사용해야 한다. @JoinColumn(name=”team_id”): 조인 컬럼은 외래 키를 매핑할 때 사용한다.name 속성에는 매핑할 외래 키 이름을 지정한다. 이 애노테이션은 생략할 수 있다.5.1.4 @JoinColumn@JoinColumn은 외래 키를 매핑할 때 사용한다. 속성 기능 기본값 name 매핑할 외래 키 이름 필드명 + _ + 참조하는 테이블의 기본 키 컬럼명 referencedColumnName 외래 키가 참조하는 대상 테이블의 컬럼명 참조하는 테이블의 기본 키 컬럼명 foreignKey(DDL) 외래 키 제약조건을 직접 지정할 수 있다. 이 속성은 테이블을 생성할 때만 사용한다.   uniquenullableinsertableupdatablecolumnDefinition table @Column의 속성과 같다.   @ManyToOne 속성 기능 기본값 optional false로 설정하면 연관된 엔티티가 항상 있어야 한다. true fetch 글로벌 페치 전략을 설정한다8장에서 자세히. @ManyToOne=FetchType.EAGER@OneToMany=FetchType.LAZY cascade 영속성 전이 기능을 사용한다8장에서 자세히.   targetEntity 연관된 엔티티의 타입 정보를 설정한다.이 기능은 거의 사용하지 않는다.컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다.   @OneToManyprivate List&amp;lt;Member&amp;gt; members; // 제네릭으로 타입 정보를 알 수 있다.@OneToMany(targetEntity=Member.class)private List members; // 제네릭이 없으면 타입 정보를 알 수 없다.5.2 연관관계 사용연관관계 매핑 작업이 끝났으니 등록, 수정, 삭제, 조회하는 예제를 통해 어떻게 사용하는지 알아보자.5.2.1 저장 회원과 팀을 저장하는 코드중요한 부분을 분석해보자. member1.setTeam(team1); // 회원 -&amp;gt; 팀 참조 em.persist(member1); // 저장회원 엔티티는 팀 엔티티를 참조하고 저장했다. 이때 실행된 SQL을 보면 회원 테이블의 외래 키 값으로 참조한 팀의 식별자 값이 입력된 것을 알 수 있다.Hibernate: /* insert io.wisoft.daewon.entity.Team */ insert into Team (name, team_id) values (?, ?)Hibernate: /* insert io.wisoft.daewon.entity.Member */ insert into Member (team_id, username, member_id) values (?, ?, ?)Hibernate: /* insert io.wisoft.daewon.entity.Member */ insert into Member (team_id, username, member_id) values (?, ?, ?)5.2.2 조회연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지이다. 객체 그래프 탐색객체 연관관계를 사용한 조회 객체지향 쿼리 사용JPQL 객체 그래프 탐색 member.getTeam()을 사용해서 member와 연관된 team 엔티티를 조회할 수 있다. Member member = em.find(Member.class, &quot;member&quot;);Team teeam = member.getTeam(); // 객체 그래프 탐색System.out.println(&quot;팀 이름 = &quot; + team.getName()); // 출력 결과 : 팀 이름 = 팀1 객체를 통해 연관된 엔티티를 조회하는 것을 객체 그래프 탐색이라 한다8장에서 자세히. 객체지향 쿼리 사용 JPQL도 조인을 지원하므로 연관된 테이블을 조인해서 검색조건을 사용하면 된다. JPQL 조인 탐색 JPQL의 from Member m from m.team t 부분을 보면 회원이 팀과 관계를 가지고 있는 필드m.team를 통해서 Member와 Team을 조인했다. 그리고 where 절에서 t.name을 검색 조건으로 사용해서 팀1에 속한 회원만 검색했다. 참고로 teamName과 같이 :로 시작하는 것은 파라미터를 바인딩받는 문법이다. 이때 실행되는 SQL을 보자. SELECT m.*FROM member minner join team t on m.team_id = t.team_idwhere t.name=&#39;팀1&#39;; SQL과 JPQL을 비교하면 JPQL은 객체엔티티를 대상으로 하고 SQL보다 간결하다. 객체 쿼리는 10장에서 자세히 다룬다. 5.2.3 수정팀1 소속이던 회원을 새로운 팀2에 소속하도록 수정해보자. 연관관계 수정 코드Hibernate: /* update io.wisoft.daewon.entity.Member */ update Member set team_id=?, username=? where member_id=?실행되는 수정 SQL은 위와 같다. 단순히 불러온 엔티티의 값만 변경해두면 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다. 그리고 변경사항을 데이터베이스에 자동으로 반영한다.이것은 연관관계를 수정할 때도 같으므로 참조하는 대상만 변경하면 나머지는 JPA가 자동으로 처리한다.5.2.4 연관관계 제거회원 1을 팀에 소속하지 않도록 변경해보자. 연관관계 제거 코드이 때 실행되는 SQL은 다음과 같다. update Member set team_id=null, ... where member_id=&#39;member1&#39;5.2.5 연관된 엔티티 삭제연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다. 그렇지 않으면 외래 키 제약조건으로 인해데이터베이스에서 오류가 발생한다. 이때 팀1을 삭제하려면 연관관계를 먼저 끊어야 한다.member1.setTeam(null);member2.setTeam(null);em.remove(team);5.3 양방향 연관관계지금까지 회원에서 팀으로만 접근하는 다대일 단방향 매핑을 알아보았다. 이번에는 팀에서 회원으로 접근하는 관계를 추가해보자. 양방향 객체 연관관계먼저 객체 연관관계를 보면 회원과 팀은 다대일 관계다. 반대로 팀에서 회원은 일대다 관계다. 일대다 관계는 여러 건과 연관관계를맺을 수 있으므로 컬렉션을 사용해야 한다. Team.members를 List 컬렉션으로 추가했다. 회원 → 팀 : Member.team 팀 → 회원 : Team.members JPA는 List를 포함한 Collection, Set, Map 같은 다양한 컬렉션을 지원한다.테이블의 관계는 미리 말한 것처럼 데이터베이스 테이블은 외래 키 하나로 양방향으로 조회할 수 있다.따라서 데이터베이스에 추가할 내용은 전혀 없다.5.3.1 양방향 연관관계 매핑회원 엔티티에는 변경할 부분이 없다. 팀의 엔티티를 보자. 매핑한 팀 엔티티팀과 회원은 일대다 관계다. 따라서 members를 추가해주었다. 그리고 일대다 관계를 매핑하기 위해 @OneToMany 매핑 정보를 사용했다. mappedBy 속성은 양방향 매핑일 때 사용하는데반대쪽 매핑의 필드 이름을 값으로 주면 된다.이것으로 양방향 매핑을 완료했으니 팀1에 소속된 모든 회원을 찾아보자.5.3.2 일대다 컬렉션 조회 일대다 방향으로 객체 그래프 탐색실행 결과member.username=회원1member.username=회원25.4 연관관계의 주인@OneToMany는 직관적으로 이해가 가지만 문제는 mappedBy 속성이다. mappedBy는 왜 필요한지 알아보자.객체에서의 양방향 연관관계는 사실 없다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다. 반면에 데이터베이스 테이블은 앞서 설명했듯이 외래 키 하나로 양쪽이 서로 조인할 수 있다. 회원 → 팀 연관관계 1개단방향 팀 → 회원 연관관계 1개단방향테이블은 회원 ↔ 팀 연관관계 1개양방향다시 강조하자면 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리한다.엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로 이 참조로 외래 키를 관리하면 된다.그런데 엔티티를 양방향으로 매핑하면 두 곳에서 서로를 참조하므로 객체의 연관관계를 관리하는 포인트는 2개로 늘어난다.엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 따라서 둘 사이에 차이가 발생한다.이런 차이로 인해 JPA는 두 객체 연관관계 중 하나를 정해 테이블의 외래 키를 관리하는데 이걸 연관관계의 주인Owner이라 한다.5.4.1 양방향 매핑의 규칙: 연관관계의 주인양방향 연관관계 매핑 시 두 연관관계 중 하나를 연관관계의 주인으로 정해야 한다.연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래키를 관리등록, 수정, 삭제할 수 있다. 반면에 주인이 아닌 쪽은 읽기만 가능하다.어떤 연관관계를 주인으로 정할지는 mappedBy 속성을 사용하면 된다. 주인은 mappedBy 속성을 사용하지 않는다. 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야 한다.그렇다면 Member.team, Team.members 중 어떤 것을 연관관계의 주인으로 해야할까?연관관계의 주인을 정한다는 것은 외래 키 관리자를 선택하는 것이다. 만약 회원 엔티티에 있는 Member.team을 주인으로 선택하면 자기 테이블에 있는 외래 키를 관리하면 된다.하지만 Team.members를 주인으로 선택하면 물리적으로 전혀 다른 테이블의 외래 키를 관리해야 한다.5.4.2 연관관계의 주인은 외래 키가 있는 곳따라서 연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다. 여기서는 회원 테이블에 외래 키가 있으므로Member.team이 주인이 된다. 주인이 아닌 Team.members에는 mappedBy=”team” 속성으로 주인이 아님을 설정한다.mappedBy의 값은 연관관계의 주인을 주면 된다. 여기서 “team”은 Member 엔티티의 team 필드를 말한다.정리하면 연관관계의 주인만 데이터베이스 연관관계와 매핑되고 외래 키를 관리할 수 있다.주인이 아닌 반대편inverse, non-owning side은 읽기만 가능하고 외래 키를 변경하지는 못한다. 데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키를 가진다.다 쪽인 @ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없다.따라서 ManyToOne에는 mappedBy 속성이 없다.5.5 양방향 연관관계 저장양방향 연관관계를 사용해서 팀1, 회원1, 회원2를 저장해보자. 양방향 연관관계 저장참고로 이 코드는 단방향 연관관계에서 살펴본 회원과 팀을 저장하는 코드와 완전히 같다.데이터베이스에서 회원 테이블을 조회 해보자.양방향 연관관계에서는 연관관계의 주인이 외래 키를 관리한다. 따라서 주인이 아닌 방향은 값을 설정하지 않아도 데이터베이스에외래 키 값이 정상 입력된다.// 주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않는다.team1.getMembers().add(member1); // 무시(연관관계의 주인이 아님)team1.getMembers().add(member2); // 무시(연관관계의 주인이 아님)// Member.team은 연관관계의 주인이므로 엔티티 매니저는 이곳에 입력된 값을 사용해서 외래 키를 관리한다.member1.setTeam(team1); // 연관관계 설정(연관관계의 주인)member2.setTeam(team1); // 연관관계 설정(연관관계의 주인)5.6 양방향 연관관계의 주의점데이터베이스에 외래 키 값이 정상적으로 저장되지 않으면 주인이 아닌 곳에만 값을 입력하지 않는지 의심해봐야 한다.주인이 아닌 곳에만 값을 설정하면 어떻게 되는지 알아보자.회원1, 회원2를 저장하고 팀의 컬렉션에 담은 후에 팀을 저장했다. 데이터베이스에서 회원 테이블을 조회해보자.연관관계의 주인이 아닌 Team.members에만 값을 저장했으므로 team_id에 null 값이 입력되어 있는 것을 볼 수 있다.5.6.1 순수한 객체까지 고려한 양방향 연관관계정말 연관관계의 주인에만 값을 저장하고 주인이 아닌 곳에는 값을 저장하지 않아도 될까? 사실은 객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전하다. 양쪽 방향 모두 값을 입력하지 않으면 JPA를 사용하지 않는 순수한 객체 상태에서 심각한 문제가 발생할 수 있다.예를 들어 JPA를 사용하지 않고 엔티티에 대한 테스트 코드를 작성한다고 해보자.ORM은 객체와 관계형 데이터베이스 둘 다 중요한데, 데이터베이스와 객체 모두 고려해야 한다. 순수한 객체 연관관계실행 결과members.size = 0Member.team에만 연관관계를 설정하고 반대 방향은 연관관계를 설정하지 않았다. 실행 결과를 보면 우리가 기대하던 양방향 연관관계가 아닌 것을 볼 수 있다.양방향은 양쪽다 관계를 설정해야 한다. 위처럼 회원 → 팀을 설정하면 반대방향인 팀 → 회원도 설정해야 한다.team1.getMembers().add(member1); 양방향 모두 관계를 설정실행 결과members.size = 2양쪽 모두 관계를 설정하니 기대했던 결과 2가 나온다.객체 까지 고려하면 이렇게 양쪽 다 관계를 맺어야 하는 것이다. 이제 JPA를 사용해서 완성한 코드를 보자. JPA로 코드 완성양쪽에 연관관계를 설정했다. 따라서 순수한 객체 상태에서도 동작하고, 테이블의 외래 키도 정상 입력된다.물론 외래 키의 값은 연관관계의 주인인 Member.team 값을 사용한다. Member.team: 연관관계의 주인, 이 값으로 외래 키를 관리한다. Team.members: 연관관계의 주인이 아니다. 따라서 저장 시에 사용되지 않는다.따라서 결론은 객체의 양방향 연관관계는 양쪽 모두 관계를 맺어주자.5.6.2 연관관계 편의 메서드양방향 연관관계는 결국 양쪽 다 신경 써야 한다. 위처럼 양방향 연관관계 코드를 작성하다보면 둘 중 하나만 실수로 놓치게되면양방향이 깨질 수 있다.따라서 양방향 관계에선 두 코드를 하나인 것처럼 사용하는 것이 안전하다.이렇게 리팩토링하면 실수도 줄어들고 좀 더 그럴듯하게 양방향 연관관계를 설정할 수 있다.이렇게 한 번에 양방향 관계를 설정하는 메서드를 연관관계 편의 메서드라 한다.5.6.3 연관관계 편의 메서드 작성 시 주의사항하지만 이전의 setTeam() 메서드에는 사실 버그가 있다.member.setTeam(teamA); // 1member.setTeam(teamB); // 2Member findMember = teamA.getMember(); // member1이 여전히 조회된다.이 시나리오를 그림으로 분석해보자. 1 2(삭제되지 않은 관계)teamB로 변경할 때 teamA → member1 관계를 제거하지 않았다. 따라서 기존 팀과 회원의 연관관계를 삭제하는 코드를 추가해야 한다.이 코드는 서로 다른 단방향 연관관계 2개를 양방향인 것처럼 보이게 하기위해 얼마나 많은 고민과 수고가 필요한지 보여준다.반면에 관계형 데이터베이스는 외래 키 하나로 문제를 단순하게 해결한다. 객체에서 양방향 연관관계를 사용하려면 로직을 견고하게 작성해야 한다." }, { "title": "자바 ORM 표준 JPA 프로그래밍(희망편03)", "url": "/posts/JPA-CH03/", "categories": "JPA", "tags": "", "date": "2022-02-14 00:00:00 +0900", "snippet": "엔티티매핑엔티티에 대하여 자세히 알아보자JPA에서 자주 사용하는 것으로 XML로 작성이 가능하지만 어노테이션이 사용하기 편리하며 다음과 같이 존재한다.객체와 테이블을 매핑 : @Entity, @Table기본 키 매핑 : @Id필드와 컬럼 매핑 : @Column연관관계 매핑 : @ManyToOne, @JoinColumn@Entity가장 기본이 되는 어노테이션으로 RDB의 테이블과 Java 객체를 매핑해준다. 속성명 설명 name JPA에서 사용할 엔티티 이름을 지정한다.&amp;lt;/br&amp;gt;보통 기본값인 클래스 이름을 사용한다.&amp;lt;/br&amp;gt; 만약 다른 패키지 이름이 같은 엔티티 클래스가 있다면 오류가 발생한다. 주의 사항 기본 생성자가 필요하다. Java 에서는 생성를 작성하지 않으면, 기본 생성자가 있는 것으로 간주하지만, 생성자를 따로 만든다면, 기본 생성자를 생성해주어야 한다.(파라미터가 없는 public 또는 protected 생성자) final, enum, interface, inner class에는 사용이 불가능하다. 저장할 필드에 final 사용불가 (당연하게도 사용이 불가능)@Table기본적으로 엔티티명과 같은 테이블과 객체를 매핑하지만, 특정 테이블과 매핑하고 싶은 때 이용한다. 예를 들어 회사에서 특정 prefix를 반드시 테이블에 붙여야 한다면, 이러한 기능은 유용하게 쓰일 수 있다. 속성명 설명 name 매핑할 테이블 명 (default. 엔티티 이름 사용) Catalog catalog 기능이 있는 DB에서 catalog 를 매핑 (default. DB 명) Schema schema 기능이 있는 DB에서 schema를 매핑 uniqueConstraints DDL 생성 시 유니크 제약조건을 만듦 데이터베이스 스키마 자동 생성 (쓰지 말자)이 기능은 여러 문제를 발생 시킬 수 있다. 의도적으로 작성하지 않은 내용이니, 알고 싶다면 구글에 검색해보자.@Id RDB에 고유값(PK)값이 되는 값임을 알려준다. 고유값이기 때문에 영속성 컨텍스트가 관리하는 객체는 무조건 이 값이 존재한다. 아래의 생성전략을 정해주지 않으면, 오류가 난다. 때문에 직접 값을 할당해 주던지, 아니면 생성전략을 선택해야한다. Id는 기본유형과 다음의 참조유형을 사용한다. (java.lang.String, java.util.Date, java.sql.Date, java.math.BigDecimal, java.math.BigInteger)@GeneratedValue 속성명 설명 IDENTITY 기본 키 생성을 데이터베이스에 위임 (= AUTO_INCREMENT) SEQUENCE 데이터베이스 시퀀스를 사용해서 기본 키를 할당,데이터베이스 시퀀스에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장(오라클, PostgreSQL, DB2, H2) TABLE 키 생성 테이블을 사용, 테이블을 사용하므로 모든 데이터베이스에 적용 가능 AUTO 선택한 데이터베이스 방언에 따라 방식을 자동으로 선택(Default) 아래 속성 필요&amp;lt;property name=&quot;hibernate.id.new_generator_mappings&quot; value=&quot;true&quot;&amp;gt;@Column객제 속성을 RDB의 컬럼과 매핑 할 수 있다. 속성명 설명 name 필드와 매핑할 테이블 컬럼 이름 (default. 객체의 필드 이름) insertable   updatable   unique   nullable (DDL) null 값의 허용 여부 설정, false 설정 시 not null (default. true) unique (DDL) @Table 의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 적용 columnDefinition (DDL) 데이터베이스 컬럼 정보를 직접 줄 수 있음, default 값 설정 (default. 필드의 자바 타입과 방언 정보를 사용해 적절한 컬럼 타입을 생성) length (DDL) 문자 길이 제약조건, String 타입에만 사용 (default. 255) percision, scale (DDL) BigDecimal, BigInteger 타입에서 사용. 아주 큰 숫자나 정밀한 소수를 다룰 때만 사용 (default. precision = 19, scale = 2) @Enumeratedenum 타입을 매핑할 때 사용|속성명|설명||:–|:–||value| EnumType.ORDINAL : enum 순서를 데이터베이스에 저장 쓰면 안된다. 나중에 순서가 뒤 바뀌면 엉망이 될 수 있다.&amp;lt;/br&amp;gt; EnumType.STRING : enum 이름을 데이터베이스에 저장 (default. EnumType.ORDINAL) |@Temporal날짜 타입 (java.util.Date, java.util.Calendar)을 매핑할 때 사용 속성명 설명 value TemporalType.DATE : 날짜, 데이터베이스 data 타입과 매핑 (2020-12-18)&amp;lt;/br&amp;gt; TemporalType.TIME : 시간, 데이터베이스 time 타입과 매핑 (23:36:33) &amp;lt;/br&amp;gt; TemporalType.TIMESTAMP : 날짜와 시간, 데이터베이스 timestamp 타입과 매핑 (2020-12-18 23:36:33) (default. TemporalType은 필수로 지정) @Temporal 을 생략하면 자바의 Date와 가장 유사한 timestamp로 정의@Lob데이터베이스 BLOB, CLOB 타입과 매핑 매핑하는 필드 타입이 문자면 CLOB로 나머지는 BLOB로 매핑@Transient이 필드는 매핑하지 않으며, 데이터베이스에 저장하지 않고 조회불가 하다. 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.@AccessJPA가 엔티티 데이터에 접근하는 방식을 지정|속성명|설명||:–|:–| value 필드 접근 : AccessType.FIELD 로 지정, 필드에 직접 접근 (private도 접근 가능) &amp;lt;/br&amp;gt; 프로퍼티 접근: AccessType.PROPERTY 로 지정, 접근자 Getter를 사용 " }, { "title": "자바 ORM 표준 JPA 프로그래밍(희망편02)", "url": "/posts/JPA-CH02/", "categories": "JPA", "tags": "", "date": "2022-01-10 21:54:47 +0900", "snippet": "영속성 컨텍스트영속성 컨텍스트란, java의 GC나 스프링의 빈 팩토리와 같이 DB 데이터관리를 이관하고 더불어 DB를 마치 메모리 DB를 이용하듯 객체화 시켜준다.또한 이러한 정보는 객체와 마찬가지로 생명주기를 가지고 있다. 이런 생명주기는 4가지로 존재한다. 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계 없는 상태 영속(managed) : 영속성 컨텍스트에 저장된 상태 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제(removed) : 삭제된 상태아래의 예제 소스를 보며 다시 확인해 보자// 비영속 상태 (new)Member member = new Member();member.setId(1L);member.setName(&quot;HelloA&quot;);//영속 상태 (managed)em.persist(member);Member findMemeber = em.find(Member.class, 1L);//준 영속상태(detached)em.detach(findMemeber);//삭제 (remove)em.remove(findMemeber);em.remove(member);비영속 상태순수한 객체 상태이며 영속성 컨텍스트나 데이터베이스와 관련없는 상태를 말한다.때문에 JPA에서 지원하는 기능을 전혀 이용 할 수 없다.영속 상태생성한 객체를 연속성 컨텍스트가 관리 할 수 있도록 영속성 컨텍스트에 저장했다.영속성 컨텍스트가 관리한다는 의미는 해당 객체가 변화하면 그에 따라 JPA가 감지하여 DB와 동기화를 진행 할 수 있다는 의미다.준영속영속성 컨텍스트가 관리 중인 객체를 영속성 컨텍스트의 관리 범위에서 제외시킨다는 의미다. 한마디로 영속성 컨텍스트가 관리하지 않으면 이상태라고 할 수 있다.삭제엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.영속성 컨텍스트 특징영속 상태는 식별자 값이 반드시 있어야 한다.트랜젝션을 커밋하는 순간 영속성 컨텍스트는 DB와 동기화 작업을 진행한다.영속성 컨텍스트를 이용하면 아래와 같은 장점이 있다. 1차 캐시 동일성 보장 트랜잭션을 지원하는 쓰기 지연 변경감지 지연로딩엔티티 조회 (1차 캐시, 동일성 보장)영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다. 영속 상태의 엔티티는 모두 이곳에 저장된다. 쉽게 표현해서 영속성 컨텍스트 내부에는 map이 있으며, 키는 @id로 매핑된 식별자이며, 값은 엔티티 인스턴스이다.1차 캐시의 키는 식별자 값이다. 그리고 식별자 값은 데이터베이스 기본 키와 매핑되어 있다. 따라서 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준 은 데이터베이스 기본 키 값이다.1차 캐시의 성능상 이점em.find(Member.class, id)로 엔티티를 조회하면 1차 캐시에서 먼저 조회를 하고 없으면 DB에서 조회를 한다. 바로 DB에서 조회하는것이 아니기 때문에 DB 커넥팅에 따른 비용이 발생하지 않을 수 있다.1차 캐시에 없어서 DB에서 조회할 경우 DB에서 조회된 내용이 영속성 컨텍스트의 1차 캐시에 저장된뒤 엔티티가 반환된다. 다음에 똑같은 엔티티를 호출할 경우 성능상 이점을 누릴 수 있도록 하기 위함이다.public void logic(EntityManager em) { Member member = new Member(); member.setId(101L); member.setName(&quot;HelloJPA&quot;); em.persist(member); Member findMemeber = em.find(Member.class,101L); // 1차 캐시 사용 System.out.println(String.format(&quot;findMemeber.id = %s&quot;,findMemeber.getId())); System.out.println(String.format(&quot;findMemeber.name = %s&quot;,findMemeber.getName())); }1차 캐시의 동일성 보장Jdbc API로 직접 Member 테이블에서 ID 1인 row를 객체화하는 경우를 생각해보자. 총 두번 조회하고 각각을 a, b 라는 참조변수가 참조하도록 하였다. 이때 a == b(동등성 비교) 의 결과값은 어떻게 될까? Jdbc API를 통해 생성되는 인스턴스는 그때마다 서로 다른 주소값을 가진 인스턴스를 반환하기 때문에 false가 반환된다.반면에 EntityManager를 통해 반환하는 객체는 영속성 컨텍스트 내부의 1차 캐시에 저장된 객체를 반환하기 때문에 항상 참조값이 동일한 객체를 반환한다.ppublic void logic(EntityManager em) { Member member = new Member(); member.setId(101L); member.setName(&quot;HelloJPA&quot;); em.persist(member); Member findMemeber1 = em.find(Member.class,101L); // 1차 캐시 사용 Member findMemeber2 = em.find(Member.class,101L); // 1차 캐시 사용 System.out.println(member == findMemeber1); System.out.println(findMemeber1 == findMemeber2); }member를 1차 캐시에 등록하였다. 그리고 1차 캐시에서 값을 가져온 후 두 값을 비교해본다. 신기하게 같은 참조값이 같다.엔티티 등록 (쓰기 지연)엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다. 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)이라 한다.public static void main(String[] args) { //하나만 생성 ( DB당 ) EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;study&quot;); //프랜젝션 단위별로 manager 생성 (쓰레드간에 공유 금지) EntityManager em = emf.createEntityManager(); // 트렌젠션 안에서 데이터 처리 EntityTransaction tx = em.getTransaction(); tx.begin(); try { Member member1 = new Member(150L , &quot;A&quot;); Member member2 = new Member(160L , &quot;B&quot;); em.persist(member1); em.persist(member2); System.out.println(&quot;============이선 이후로 DB에 반영한다===============&quot;); // 쿼리 적용 tx.commit(); } catch (Exception e) { tx.rollback(); } finally { em.close(); } }em.persist(member1)를 하는 순간 member1 영속화 한다. 그리고 동시에 쓰기 지연 SQL 저장소에 INSERT SQL문을 생성하여 저장한다.그리고 tx.commit() 을 한다. 트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시한다. 플러시는 영속성 컨텍스트의 변 경 내용을 데이터베이스에 동기화하는 작업인데 이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다. 좀 더 구체적으로 이야기하면 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다. 이렇게 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다.엔티티 수정 (변경 감지)만약 SQL문을 직접 다룬다면 수정이 필요할 때마다 SQL문을 추가로 작성해줘야하는 번거로움이 있고, 어플리케이션의 복잡성을 증가시키는 요소가 된다. 하지만 JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다.public static void main(String[] args) { //하나만 생성 ( DB당 ) EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;study&quot;); //프랜젝션 단위별로 manager 생성 (쓰레드간에 공유 금지) EntityManager em = emf.createEntityManager(); // 트렌젠션 안에서 데이터 처리 EntityTransaction tx = em.getTransaction(); tx.begin(); try { Member member1 = new Member(150L , &quot;A&quot;); em.persist(member1); em.flush(); em.clear(); System.out.println(&quot;============DB에 반영 완료===============&quot;); Member findMember = em.find(Member.class, 150L); findMember.setName(&quot;zzzzz&quot;); // 쿼리 적용(변경 감지) tx.commit(); } catch (Exception e) { tx.rollback(); } finally { em.close(); } }위와 같이 코드를 실행하고 DB를 조회하면 MEMBER 테이블의 ID 150L인 row의 username는 zzzzz로 변경되어있다.update 메소드 없이 엔티티의 내용만 바꾸면 된다니, 어떻게 가능한 걸까? 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지(dirty checking)라 한다. 변경 감지가 작동하는 매커니즘은 다음과 같다.em.persist(member) 를 호출하면 영속성 컨텍스트 1차 캐시에 저장이 되는데, 이때 최초 상태를 복사해서 저장해두는 스냅샷을 함께 저장한다. 트랙잭션을 커밋 transaction.commit() 하는 시점에 내부 스냅샷과 엔티티를 비교하는 플러시 작업을 한다. 플러시 작업 : 스냅샷과 엔티티를 비교해서 변경된 내용을 찾는다. 변경된 내용에 대한 수정 쿼리(UPDATE SQL)문을 쓰기 지연 SQL 저장소에 저장한다. 쓰기 지연 SQL 저장소와 DB를 플러쉬하여 비교한다. DB에 트랜잭션을 커밋한다.이러한 변경감지는 영속성 컨텍스트가 관리하는 영속 상태인 엔티티에만 적용된다.이러한 변경감지가 엔티티를 변경할 때마다 일어난다고 착각하기 쉽지만, 다시 한번 강조하자면 트랜잭션을 커밋하는 순간에 변경감지가 일어나 내부적으로 플러시 작업이 일어나는 것이다.UPDATE SQL이때 쓰기 지연 SQL 지정소에 생성되는 UPDATE SQL 문이 변경된 내용만 반영하는 SQL문일거라고 생각할 수 있지만 모든 칼럽을 업데이트하는 SQL문이 생성되고, value에 들어가는 인자만이 바뀐 내용을 반영하게끔 되어있다. 이러한 방법을 정적 수정 쿼리라고 한다.정적 수정 쿼리를 사용하는 이유는 다음과 같다. 모든 필드를 사용하면 수정 쿼리가 항상 같기 때문에 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있다. 동적으로 매번 SQL문을 생성하는 것보다 성능상 이점을 얻을 수 있다. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼 리를 재사용할 수 있다. DB 단에서도 성능상 이점을 얻을 수 있다.하지만 매핑된 칼럼이 많은 엔티티라면 모든 칼럼을 업데이트하는 방법은 오히려 성능을 악화시키는 방법일 것이다. 이럴때는 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성하는 전략을 선택하면 된다.하이버네이트 확장 기능을 사용해야 한다. @org.hibernate.annotations.DynamicUpdate이렇게 @org.hibernate.annotations.DynamicUpdate 어노테이션을 사용하면 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성한다. 참고로 데이터를 저장할 때 데이터가 존재하는(null이 아닌) 필드만으로 INSERT SQL을 동적으로 생성하는 @DynamicInsert도 있다.엔티티 삭제엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다.//삭제 대상 엔티티 조회Member memberA = em.find(Member.class, 150L);em.remove(memberA); //엔티티 삭제em.remove()에 삭제 대상 엔티티를 넘겨주면 즉시 엔티티를 삭제하는 것이 아니라 엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록한다.이후 트랜잭션을 커밋해서 플러시를 호출하면 실제 데이터베이스에 삭제 쿼리를 전달한다.반면에 em.remove(memberA)를 호출하는 순간 memberA는 영속성 컨텍스트에서 제거된다. 이렇게 삭제된 엔티티는 재사용하지 말고 자연스럽게 가비지 컬렉션의 대상이 되도록 두는 것이 좋다.플러시 (flush)영속성 컨텍스트의 내용와 DB의 내용을 비교하여 변경 사항을 적용하는 역할을 한다.플러시의 동작플러시는 구체적으로 다음과 같이 동작한다.변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.쓰기지연SQL저장소의 쿼리를 데이터베이스에 전송한다(등록,수정,삭제쿼리).플러시 시행 방법영속성 컨텍스트를 플러시하는 방법은 3가지다.em.flush()를 직접 호출한다.트랜잭션 커밋 시 플러시가 자동 호출된다.JPQL 쿼리 실행 시 플러시가 자동 호출된다.em.flush()직접 엔티티 매니저를 플러시하는 방법은 트랜잭션을 이용하는 의미를 퇴색히키기 때문에 잘 사용하지 않는다. 테스트나 다른 프레임워크와 JPA를 함께 사용할 때나 사용한다.트랜잭션 커밋가장 일반적인 경우다. 영속성 컨텍스트를 플러시 하지 않고 커밋하게 되면 DB에 어떤 변화도 발생하지 않는다. 이러한 일을 방지하고자 자동으로 트랜잭션 커밋시 플러시가 실행 되도록 하였다.JPQL 시행JPQL이나 Criteria같은 객체지향 쿼리를 호출할 때도 플러시가 실행된다.public static void main(String[] args) { //하나만 생성 ( DB당 ) EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;study&quot;); //프랜젝션 단위별로 manager 생성 (쓰레드간에 공유 금지) EntityManager em = emf.createEntityManager(); // 트렌젠션 안에서 데이터 처리 EntityTransaction tx = em.getTransaction(); tx.begin(); try { em.persist(new Member(150L, &quot;A&quot;)); em.persist(new Member(151L, &quot;B&quot;)); em.persist(new Member(152L, &quot;C&quot;)); System.out.println(&quot;====================&quot;); List&amp;lt;Member&amp;gt; member_m = em.createQuery(&quot;select m from TMember m&quot;, Member.class).getResultList(); System.out.println(&quot;member.size = &quot; + member_m.size()); // 쿼리 적용 tx.commit(); } catch (Exception e) { tx.rollback(); } finally { em.close(); emf.close(); }}객체들은 영속성 컨텍스트에 있지만 아직 플러시가 되지 않았기 때문에 DB에는 없는 상태이다. 이때 만약 JPQL로 Member 객체를 모두 조회한다면 플러시가 되지 않은 상태이므로 어떠한 반환값도 얻을 수 없을 것이다. 이러한 일을 방지하기 위해 JPQL을 시행하는 순간에 플러시가 되고, 덕분에 JPQL은 의도한 결과값을 얻을 수 있게 된다.플러시 모드 옵션어떤 경우에 플러시를 할지 설정할 수 있도록 도와주는 옵션이 있다.javax.persistence.FlushModeType를 이용하는데, 옵션은 다음의 두 가지이다. FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시(기본값) FlushModeType.COMMIT: 커밋할 때만 플러시자바 코드에서 설정한다. em.setFlushMode(FlushModeType.COMMIT)플러시 모드를 별도로 설정하지 않으면 AUTO로 동작한다. 따라서 트랜잭션 커 밋이나 쿼리 실행 시에 플러시를 자동으로 호출한다.준영속영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리 된(detached) 것을 준영속 상태라 한다. 따라서 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.영속된 엔티티를 준영속 상태로 만드는 방법은 세가지이다.em.detach(entity): 특정 엔티티만 준영속 상태로 전환한다. em.clear(): 영속성 컨텍스트를 완전히 초기화한다. em.close(): 영속성 컨텍스트를 종료한다.엔티티 삭제와의 차이엔티티 삭제(em.remove()) 와는 차이가 명확하다. 엔티티 삭제는 DELETE SQL문을 지연 쓰기 SQL 저장소에 등록하고 영속성 컨텍스트에서 엔티티를 삭제하는 것이다.반면 엔티티 비영속화는 해당 엔티티 관련 INSERT, UPDATE SQL문을 지연 쓰기 SQL 저장소에서 삭제하고, 영속성 컨텍스트에서 엔티티를 삭제하는 것이다.detach()public void testDetached() {...//회원 엔티티 생성, 비영속 상태Member member = new Member();member.setId(&quot;memberA&quot;);member.setUsername(&quot;회원A&quot;);//회원 엔티티 영속 상태em.persist(member);//회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태em.detach(member);transaction.commit(); //트랜잭션 커밋}엔티티 memberA를 생성한 뒤 영속성하고, 그 다음 준영속 상태로 만들었다.준영속 상태로 만든 순간 영속성 컨텍스트의 1차 캐시와 지연 쓰기 SQL 저장소에서 엔티티 관련 정보가 삭제된다. 이 경우에는 memberA 관련 INSERT SQL문이 삭제되었을 것이다. 그리고 트랜잭션을 커밋했기 때문에 당연히 DB에는 memberA 엔티티 관련 정보가 입력되지 않는다.em.clear() 영속성 컨텍스트를 초기화해서 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다. 이것은 영속성 컨텍스트를 제거하고 새로 만든 것과 같다.em.close() 영속성 컨텍스트 자체를 없애버린다. 관리하고 있던 모든 엔티티를 준영속 상태로 만든다. 이것은 말 그대로 영속성 컨텍스트를 제거하는 것이다.엔티티가 준영속화 되는 것은 보통 영속성 컨텍스트가 종료됐을 때이다. 개발자가 엔티티 개별로 준영속화하는 일은 드물다.준영속 상태의 특징거의비영속상태에가깝다영속성 컨텍스트가 관리하지 않으므로 1차 캐시, 쓰기 지연, 변경 감지, 지연 로 딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.식별자값을가지고있다비영속 상태는 식별자 값이 없을 수도 있지만 준영속 상태는 이미 한 번 영속 상태였으므로 반드시 식별자 값을 가지고 있다.지연로딩을할수없다지연 로딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.준영속 병합준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용하면 된다. merge() 메소드는 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환한다.public class ExamMergeMain {static EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;study&quot;); public static void main(String args[]) { Member member = createMember(1L, &quot;회원1&quot;); member.setUsername(&quot;회원명변경&quot;); mergeMember(member); } static Member createMember(Long id, String username) { EntityManager em1 = emf.createEntityManager(); EntityTransaction tx1 = em1.getTransaction(); tx1.begin(); Member member = new Member(); member.setId(id); member.setUsername(username); em1.persist(member); tx1.commit(); em1.close(); //영속성 컨텍스트1 종료, return member; } static void mergeMember(Member member) { EntityManager em2 = emf.createEntityManager(); EntityTransaction tx2 = em2.getTransaction(); tx2.begin(); Member mergeMember = em2.merge(member); tx2.commit(); System.out.println(&quot;member = &quot; + member.getUsername()); System.out.println(&quot;mergeMember = &quot; + mergeMember.getUsername()); System.out.println(&quot;em2 contains member = &quot; + em2.contains(member)); System.out.println(&quot;em2 contains mergeMember = &quot; + em2.contains(mergeMember)); System.out.println(&quot;mergeMember.equals(member) = &quot; + mergeMember.equals(member)); em2.close(); }}Member member = createMember(“memberA”, “회원1”)하단에 정의된 createMember 함수에 의해 member 참조 변수는 준영속 상태가 된 엔티티 객체를 참조하게 된다. 이때 준영속 상태가 된 엔티티의 내용은 DB에 이미 저장한 상태이다.member.setUsername(“회원명변경”)member 변수의 Username을 ‘회원1’에서 ‘회원명변경’으로 변경한다. member 변수는 준영속 상태이므로 DB에 어떠한 영향고 끼치지 못한다.mergeMember(member)en.merge(member) 로 mergeMember 변수를 만든다. 이때 진행되는 매커니즘은 아래와 같다. 그 결과 mergeMember 엔티티가 갖는 정보는 member 엔티티와 동일해진다. 하지만 엔티티 매니저는 member 변수를 알지 못한다고 하기 때문에, merge에 사용된 엔티티와 반환된 엔티티는 서로 다른 인스턴스가 된다.merge 매커니즘 merge(member)가 실행된다. merge에 사용된 엔티티가 1차 캐시에 있는지 조회한다. 우리는 member 변수를 준영속 상태로 만들었기 때문에 1차 캐시에 member 엔티티는 존재하지 않는다. 따라서 DB에서 조회한다. DB에서 조회된 엔티티 정보를 mergeMember 라는 이름으로 1차 캐시에 저장한다. 인자로 들어온 member의 정보로 mergeMember 엔티티의 정보를 변경한다. mergeMember 변수는 mergeMember 엔티티를 참조하게 된다.비영속 병합tx.begin();Member memberI = new Member(); // 비영속 엔티티 memberMember newMember = em.merge(memberI); // 비영속 병합tx.commit();병합은 비영속 엔티티도 할 수 있는데, 병합을 하기 위해서는 엔티티의 식별자값을 기준으로 1차 캐시에서 조회, 없으면 DB에서 조회, DB에서도 없으면 새로운 엔티티를 생성해서 병합하기 때문이다.참조https://jooha208.medium.com/?p=3d0d9ff439a2" }, { "title": "자바 ORM 표준 JPA 프로그래밍(번외1)", "url": "/posts/JPA-ETC00/", "categories": "JPA", "tags": "", "date": "2021-12-23 00:07:09 +0900", "snippet": "객체 세상객체를 이해할려면 객체가 무엇인지 알아야 한다. 객체란 무엇일까? 컴퓨터 과학에서 객체 또는 오브젝트(object)는 클래스에서 정의한 것을 토대로 메모리(실제 저장공간)에 할당된 것으로 프로그램에서…. - 위키백과위 정의를 보고 한번에 이해하는 특출난 분은 아래의 다른 설명으로 넘어가도 된다.가장 쉽게 생각하자면 현실 세계에서 존재하는 모든 것들을 객체라고 할 수 있다.(엄밀히 말하면 같다고는 할 수 없으며 유사하다 정도로 표현 가능하다.) 하지만 프로그래밍 세상에서는 능동적으로 행동한다. 프로그래밍 세상에서는 편지가 스스로 전달되고 답변도 스스로 할 수 있다." }, { "title": "자바 ORM 표준 JPA 프로그래밍(희망편01)", "url": "/posts/JPA-CH01/", "categories": "JPA", "tags": "", "date": "2021-12-23 00:00:00 +0900", "snippet": "프로젝트 생성프로젝트를 진행하면서 하이버네이트의 사용법을 익혀보자 스프링 프로젝트 생성pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;jap-basic&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ex1-hello-jpa&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- JPA 하이버네이트 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-entitymanager&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.10.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- H2 데이터베이스 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.199&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt; h2 db 설치버전 확인 필요1.4.199구조 설정예제 테이블 생성회원 테이블 생성create table member( id varchar(255) not null, name varchar(255), age integer not null, primary key (id))객체 매핑 시작import javax.persistence.*;@Entity(name = &quot;TMember&quot;)@Table(name = &quot;MEMBER&quot;)public class Member { @Id @Column(name = &quot;ID&quot;) private Long id; // 타입은 숫자형 @Column(name = &quot;NAME&quot; ) private String userName; private int age; /** getter and setter **/}어노테이션 설명 @Entity JPA에서 관리해 달라고 요청하는 어노테이션으로 이런 클래스를 엔티티 클래스라고 부른다. 속성 : name JPA에서 관리하는 엔티티 이름으로 이 이름으로 JPQL 등에서 엔티티를 불러와서 사용한다. 주의사항 : 엔티티 생성을 위해서는 내부적으로 기본 생성자를 요구 하기 때문에 기본생성자가 필수로 필요하다. final 클래스, enum, interface, inner 클래스는 엔티티로 사용할 수 없다. @Table 엔티티 클래스를 매핑할 테이블 정보를 알려준다. 속성 : name 이 속성을 이용하여 특정 테이블에 메핑할 수 있다. 위에서는 “Member” 엔티티를 “MEMBER” 테이블에 매핑하고 있다. @Id 엔티티 클래스 필드를 기본키로 매핑한다. 이런 필드를 ‘식별자 필드’라고 부른다. @Column 필드를 컬럼에 매핑한다. 속성 : name 이 속성을 이용하여 특정 컬럼에 매핑할 수 있다. 위에서는 “username” 필드를 “NAME” 컬럼에 매핑하고 있다. 무설정 필드 어노테이션을 무설정시, 필드명을 사용하여 컬럼명으로 매핑한다. 주의사항 : 대소문자를 구분하는 db라면 (oracle 등) 명시적으로 매핑이 필요하다. persistence.xml 설정JPA를 사용하기 위해서는 관련 설정이 필요하다. 해당 설정의 기본 위치는 META-INF/persistence.xml 이다.JPA는 영속성 유닛을 이용하여 DB와 연결한다. 또한 이름을 부여하여 사용하는데 아래에선 ‘study’라는 이름을 사용하고 있다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;persistence version=&quot;2.2&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; &amp;gt; &amp;lt;persistence-unit name=&quot;study&quot;&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;!-- 필수 속성 --&amp;gt; &amp;lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;org.h2.Driver&quot;/&amp;gt; &amp;lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;sa&quot;/&amp;gt; &amp;lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;&quot;/&amp;gt; &amp;lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:h2:tcp://localhost/~/test&quot;/&amp;gt; &amp;lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&amp;gt; &amp;lt;!-- 옵션 --&amp;gt; &amp;lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;property name=&quot;hibernate.use_sql_comments&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;property name=&quot;hibernate.jdbc.batch_size&quot; value=&quot;10&quot;/&amp;gt; &amp;lt;!-- |:-:|:-| create | 기존 테이블 삭제 후 다시 생성 (개발 초기 단계) creste-drop | crate 과 같으나 종료시점에 테이블 드랍 update | 변경분만 반영 (삭제는 안됨) (테스트 서버) validate | 엔티티와 테이블이 정상 매핑 되었는지만 확인 (테스트 서버 , 스테이징, 운영) none | 사용하지 않음 (스테이징, 운영) --&amp;gt; &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot; /&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/persistence-unit&amp;gt;&amp;lt;/persistence&amp;gt;app 테스트기본적인 준비를 완료했다. 실행해 보자public class JpaMain { public static void main(String[] args) { //하나만 생성 ( DB당 ) EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;study&quot;); //프랜젝션 단위별로 manager 생성 (쓰레드간에 공유 금지) EntityManager em = emf.createEntityManager(); // 트렌젠션 안에서 데이터 처리 EntityTransaction tx = em.getTransaction(); tx.begin(); //insert try { Long id = 1L; Member member = new Member(); member.setId(id); member.setName(&quot;길동&quot;); member.setAge(20); //등록 em.persist(member); //수정 member.setAge(30); //한 건 조회 Member findMember = em.find(Member.class, id); System.out.println(&quot;findMember = &quot; + findMember.getName()); //목록 조회 List&amp;lt;Member&amp;gt; member_m = em.createQuery(&quot;select m from TMember m&quot;, Member.class).getResultList(); System.out.println(&quot;member.size = &quot; + member_m.size()); //삭제 em.remove(member); // 쿼리 적용 tx.commit(); }catch (Exception e){ tx.rollback(); }finally { em.close(); emf.close(); } }}코드는 3부분으로 나눌수 있다. 앤티티 매니저 관리 트랜젝션 관리 로직 관리엔티티 매니저 관리 설정 정보 조회JPA는 영속성 객체를 관리하는 Persistence 클래스를 이용하여 엔티티 매니저 생성을 위한 엔티티 매니저 팩토리를 생성을 위한 준비를 한다.클래스 생성을 위한 정보는 META-INF/persistence.xml의 persistence-unit을 찾아 팩토리를 생성한다. 엔티티 매니저 팩토리 생성팩토리는 DBCP(데이터 커낵션 풀)등 다양한 기능을 가진 인스턴스를 생성한다 때문에 이 매니저 팩토리는 애플리케이션 전체에서 한 번만 생성하고 공유해서 사용해야 한다.(싱글톤) 앤티티 매니저 생성JPA에서 사용하는 기능은 대부분 매니저가 제공한다. 이 매니저는 데이터와 통신하는 하나의 커넥션으로 쓰레드간에 공유하면 문제가 발생한다. 종료사용이 끝난 엔티티 매니저는 종료해야 하며, 어플리케이션을 종료할 때는 팩토리도 종료해야 한다.(왜??)트랜젝션 관리엔티티 매니저는 트랜젝션을 가져와 CRUD 기본 기능을 진행 할 수 있다.비지니스 로직//등록em.persist(member);위 코드는 아래의 코드로 번역된다.insert into Member (age, NAME, ID) values (?, ?, ?)//수정member.setAge(30);update Member set age=?, NAME=? where ID=?//한 건 조회Member findMember = em.find(Member.class, id);System.out.println(&quot;findMember = &quot; + findMember.getName());select member0_.ID as ID1_0_, member0_.age as age2_0_, member0_.NAME as NAME3_0_from Member member0_//삭제em.remove(member);delete from Member where ID=?jpql //목록 조회 List&amp;lt;Member&amp;gt; member_m = em.createQuery(&quot;select m from TMember m&quot;, Member.class).getResultList(); System.out.println(&quot;member.size = &quot; + member_m.size());JPQL은 sql과 비슷하게 생겼지만 엔티티 중심으로 검색이 가능하도록 한다. sql과 유사한 문법을 지원하여 대상은 테이블이 아닌 엔티티 객체다.때문에 from절 뒤에 오는 대상은 테이블 명인 Member가 아닌 객체명인 TMember 이다.참조https://stackoverflow.com/questions/7259273/whats-the-difference-between-the-name-argument-in-entity-and-table-when-using번외 어노테이션 별 미 설명 속성 확인" }, { "title": "전각반각", "url": "/posts/%EC%A0%84%EA%B0%81%EB%B0%98%EA%B0%81/", "categories": "encoding", "tags": "", "date": "2021-12-14 19:49:48 +0900", "snippet": "전각 반각이란 ?아시아권에서 사용하는 문자에는 전각과 반각이라는 개념이 존재한다. 글자를 입력하는 칸을 정사작형 형태라고 정의 했을 경우를 전각,가로를 절반으로 줄인 형태를 반각이라고 한다.어떤것을 사용해야 하는가?아스키 코드에 포함되는 코드(영문자, 숫자)는 반각을 나머지(한글,한자,히라가나 등) 은 전각을 사용한다.왜 구분해서 사용하는가? 세로쓰기반각문자의 경우, 세로쓰기는 가능하지만 방향이 90도 전환된 형태로 표현된다.1이라는 문자가 있을때. 90도 전환된 ㅡ과 같이 표현된다. 파일명 사용제한 회피OS에 따라서는 입력이 불가능한 반각 문자가 있지만, 해당 문제를 회피하여 사용이 필요할 경우 os별로 출력이 안되는 경우가 있다.때문에 가장 유사한 전각문자를 이용할수도 있다.번외 유니코드 정규화잘 정리된 내용이 있어 원본 내용과 링크를 대체한다.링크" }, { "title": "자바 ORM 표준 JPA 프로그래밍(희망편00)", "url": "/posts/JPA-CH00/", "categories": "JPA", "tags": "", "date": "2021-12-05 00:00:00 +0900", "snippet": "JPA란?JPA(java persistence API)는 자바 진영의 ORM(Object Relational Mapping) 기술 표준이다.ORM이란?ORM이란 객체와 관계형 데이터베이스는 매핑해주는 기술이다. ORM 기술은 패러다임의 불일치 문제를 해결해 준다패러다임의 불일치개발을 시작하면 가장 먼저 객체를 접하게 된다. 이후 개발을 진행하여 RDB 즉, 관계형 데이터 베이스를 접한다.이 두가지 패러다임은 차지를 가지고 있다우리가 객체를 생성하려면 먼저 클래스를 만들어야 할것 이다.public class Member{ private String name; private int id;}그런다면 동일한 내용을 RDB는 어떻게 생성하나? 테이블을 생성한다.create table Member( name varchar(10), id int)어떤가? 비슷해보이는가?왜 알아야하지CRUD 기능을 추가한다고 생각해보자. 객체에서 생각하면 생성과 변경은 아래와 같을것이다.Member member = new Member(); //생성List&amp;lt;Member&amp;gt; list = new ArrayList&amp;lt;Member&amp;gt;();list.add(Member); //등록Member.name = &#39;banana&#39;; // 수정이번엔 RDB에서 보자insert into Member(name, id)values (&#39;bean&#39;, 1) // 등록update from Memberset name = &#39;banana&#39;where id = 1 // 수정다를수 있는거 아닌가?맞다 어느것이 우월하다고 할 수는 없다. 하지만 중요한건 변경사항이 생기면 개발자가 패러다임의 불일치를 해결해야 한다는 것이다.쉽게 생각 할 수 있지만, 사람은 기계가 아니다 언제든이 실수 할 수 있다.때문에 둘중에 더 쉬운쪽을 관리하는 것은 선택하고 그 결과가 ORM이다그래서 어떻게 쓰지놀랍게도 우리는 객체관리와 동일하게 사용만하면 JPA를 구현한 라이브러리에서 알아서 처리해준다. 알아서 에는 패러다임의 불일치 뿐 아니라 성능이나 벤더에 독립적으로 사용 할 수 있는 기능도 제공한다.주요 기능은 아래와 같다. 등록 : jpa.persist(객체) 조회 : jpa.find(객체.class , pk) 수정 : 객체 정보 변경번외패러다임의 차이에 대해 좀더 알아보자 상속 연관관계 객체 그래프 탐색 동등성과 동일성사용된 디자인 패턴을 확인해 보자 팩토리 패턴" }, { "title": "elegant object", "url": "/posts/elegantObject/", "categories": "oop", "tags": "", "date": "2021-08-09 00:00:00 +0900", "snippet": "1. 출생1.1 -er로 끝나는 이름을 사용하지 마세요1.2 생성자 하나를 주 생성자로 만드세요1.3 생성자에 코드를 넣지 마세요2장 학습2.1 가능하면 적게 캡슐화하세요2.2 최소한 뭔가는 캡슐화하세요2.3 항상 인터페이스를 사용하세요2.4 메서드 이름을 신중하게 선택하세요2.4.1 빌더는 명사다2.4.2 조정자는 동사다2.4.3 빌더와 조정자 혼합하기2.4.4 Boolean 값을 결과로 반환하는 경우2.5 퍼블리 상수를 사용하지 마세요2.5.1 결합도 증가2.5.2 응집도 저하2.6 불편 객체로 만드세요2.6.1 식별가 가변성2.6.2 실패 원자성2.6.3 시간적 결합2.6.4 부수효과 제거2.6.5 Null 참조 없애기2.6.6 쓰,레드 안전성2.7 문서를 작성하는 대신 테스트를 만드세요 읽기 쉬운 코드를 만들기 위해서는 코드를 읽데 될 사람이 주니어 프로그래머라고 가정해야 합니다. 나쁜 프로그래머는 복잡한 코드를 짜고 풀률한 프로그래머는 단순한 코드를 짭니다. 코드를 문서화하는 대신 코드를 깔끔하게 만드세요 2.8 모의 객체 대신 페이크 객체를 사용하세요 mokito등 mocking 유틸을 사용하는것 보다는 Fake 객체를 만들어 테스트를 진행하세요 2.9 인터페이스를 짧게 유지하고 스마트를 사용하세요 3장 취업3.1 5개 이하의 public 메서드만 노출하세요3.2 정적 메서드를 사용하지 마세요3.3.1 객체 대 컴퓨터 사고3.2.2 선엉형 스타일 대 명령형 스타일3.2.3 유틸리티 클래스3.2.4 싱글톤 패턴3.2.5 함수평 프로그래밍3.2.6 조합 가능한 데코레이터3.3 인자의 값으로 Null 을 절대 사용하지 마세요3.4 충성스러우면서 불변이거나, 아니면 상수이거나3.5 절대 getter와 setter를 사용하지 마세요3.5.1 객체 대 자료구조3.5.2 좋은 의도, 나쁜 결과3.5.3 접두사에 관한 모든 것3.6 부 생성자 밖에서 new를 사용하지 마세요3.7 인트로스펙션과 캐스팅을 피하세요4장 은퇴4.1 절대 Null을 반환하지 마세요4.1.1 빠르게 실해하기 vs. 안전하게 실패하기4.1.2 Null eodks4.2 체크 예외4.2.1. 꼭 필요한 경우가 아니라면 예외를 잡지 마세요4.2.2 항상 예외를 체이닝하세요4.2.3 단 한번만 복구하세요4.2.4 관점-지향 프로그래밍을 사용하세요4.2.5 하나의 예외 타입만으로도 충분합니다4.3 final 이나 abstract이거나4.4 RAII를 사용하세요" }, { "title": "컴퓨터개론 21", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A021/", "categories": "CA", "tags": "", "date": "2021-07-15 00:00:00 +0900", "snippet": "프로세스 명령어 실행과정 컴파일 과정 명령어 인출 과정 " }, { "title": "컴퓨터개론 20", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A020/", "categories": "CA", "tags": "", "date": "2021-07-07 00:00:00 +0900", "snippet": "논리회로 논리회로의 정의 bool 대수를 물리적장치에 구현한 것 하나 이상의 논리적 입력값에 대하여 정의된 연산을 수행하고, 하나의 논리적 출력값을 얻는 전자회로 논리식이나 진리표가 필수적으로 사용됨uuuuu 종류로는 조합회로, 순차회로 등이 있음 조합회로 입력 신호만으로 출력이 결정되는 회로 AND, NOT, OR, XOR 과 같이 기본이 되는 논리연산을 수행하는 회로 조합회로 심화 멀티플렉서(MUX) : 입력 신호중 하나를 선택하여 출력하는 회로 - 디멀티플렉서(DEMUX) : 한 개의 입력신호에 대하여 다수의 데이터 출력선 중 하나를 선택하는 회로 - 가산기(Adder) : 2진수의 덧셈 연산을 수행하는 논리 회로 " }, { "title": "컴퓨터개론 19", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A019/", "categories": "CA", "tags": "", "date": "2021-06-24 00:00:00 +0900", "snippet": "소수의 이진수 변환 소수 소수란 1의 자리보다 작은 자릿값을 가진 수를 의미 0.1, 0.2, 0.5 등 소수표현 방식에는 고정소수점과 부동소수점이 존재 고정 소수점 고정 소수점은 소수점을 이용하여 고정된 자리수의 소수를 표현하는 방식 밑수와 지수값을 미리 결정해두고 사용 정수 자료형에 대해서는 연산이 굉장히 빠름 -3.75 -&amp;gt; 1011.1100 부호를 제외한 나머지 비트를 절대값으로 나타내는 방식 소수부는 첫째자리부터 2^-1로 시작하여 자리수가 늘어날 때마다 그 값이 1/2이 됨 고정 소수점의 문제점 고정된 자리수 때문에 한정된 메모리에서 좁은 번위의 수만 나타낼 수 있음 소수점 고정 문제로 인해 소수를 표현하는 비트가 정수를 침해할 가능성이 존재함 소수를 표현하는데 있어 정밀도가 부족함 부동 소수점 부동소수점 표현방식은 소수를 부호, 가수, 밑수, 지수로 표현하는 방식 132.12234 -&amp;gt; 0.13212234* 10^3 위와 같은 방법을 이용하면 더 많은 수를 표현할 수 있게됨 IEEE 754 정규화 컴퓨터가 처리하는 모든 소수는 가수부 최상단 비트가 1로 표현되는 일관성 있는 현태를 유지하고 있음 이를 정규화 형식(Normalized form)이라고 함. 정규화표현식 : N = (-1)^s*2^(e-127) S: 부호비트, e: 지수 바이어스(bias) 소수의 정규화시 지수부가 음수가 될 가능성이 있음 EX) 0.001 -&amp;gt; 1.0 * 10^-3 지수비트에는 부호비트가 없기 때문에 바이어스 표기법을 사용 (지수 -127부터 128까지 사용가능) 0000 0000 = -127 0111 1111 = 0 정밀도 문제 23바ㅣ트 가수표현은 자리수가 진 소수표현에 적합하지 않음 32비트의 2배인 64비트 레지스터를 사용하는 2배 정빌도 부동소수점 표기방식이 출현 1비트 부호, 11비트 지수, 52비트 가수 표현방식 2배 정밀도 바이어스 : 1023 " }, { "title": "컴퓨터개론 18", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A018/", "categories": "CA", "tags": "", "date": "2021-06-22 00:00:00 +0900", "snippet": "곱셈 곱셈 피승수(multiplicand) : 곱함을 당하는 수 승수(multiplier) : 곱하는 수 곱(product) : 곱셈의 결과 값 MIPS에서는 곱셈의 오버플로우 방지를 위 햐여 32비트 레지스터 2개를 지원함 (총 64비트) 나눗셈 피제수(dividend) : 나누어지는 수(분수의 분자에 해당) 제수(divisor) : 나누는 수(분수의 분모에 해당) 몫(quotient) ; 나눗셈의 결과 나머지(remainder) : 피제수 - (제수 * 몫) " }, { "title": "컴퓨터개론 17", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A017/", "categories": "CA", "tags": "", "date": "2021-06-21 00:00:00 +0900", "snippet": "주소지정방식 MIPS 주소지정 방식 수치 주소지정 : 피연산자는 명령어 내에 있는 상수 (immediate , 16bit) 레지스터 주소지정 : 피연산자는 레지스터 베이스 레지스터 주소지정 : 메모리 주소는 베이스 레지스터의 값과 주소 필드의 변위 값을 더해서 구한다.(lw,sw) PC 상대 주소지정 : PC값과 명령어 내 상수의 합을 더해서 주소를 구한다.(pc + address) 의사직접 주소지정 : 명령어 내의 26비트를 PC의 상위 비트들과 연접하여 점프주소를 구한다. 수치 주소지정 명령어의 주소 필드에 데이터가 들어있으며 상우의 정의나 변수 값의 초기화에 편리하다. 데이터를 얻기위한 기억장치 접근이 필요 없으므로 명령어 사이클 한 개가 적음 사용할 수 있는 수의 크기가 주소필드의 크기로 제한됨. 레지스터 주소지정 CPU내의 레지스터에 데이터가 저장되어 있는 방식 주소 필드가 레지스터 번호를 나타내므로 적은 비트수가 필요함 데이터 저장공간이 CPU 내부 레지스터로 제한 베이스레지스터 주소지정 베이스 레지스터의 값과 주소필드의 변위 값을 더해서 주소를 구함 피연산자가 메모리에 존재하고 있음 메모리 자원을 사용하므로 저장형식이 유연함 상대 주소 지정 PC(Program Counter)의 값에 명령어의 주소 필드의 값을 더해서 유효주소를 구하는 방식 적은 비트를 사용하는 것으로 32비트 분기주소를 만드는 것이 가능함. 조건부 분기명령에 사용됨 의사 직접 주소 지정 명령어 내의 26비트를 PC의 상위 비트들과 연접하여 점프주소를 구한다. 무조건 분기문에서 주로 사용됨. 32비트 상수 operand 프로그램에서 사용하는 상수는 대체로 작은크기 MIPS는 레지스터를 16비트씩 나누어 상수를 저장하는 것이 가능 lui(load upper immediate) : 레지스터 상위 16비트에 상수를 저장 " }, { "title": "컴퓨터개론 16", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A016/", "categories": "CA", "tags": "", "date": "2021-06-20 00:00:00 +0900", "snippet": "프로시저 프로시저란? 프로시저란 제공되는 인수에 따라서 특정 작업을 수행하는 서브루틴 프로시저의 인수(parameter)는 프로시저에 값을 보내고 결과를 받아옴 프로시저나 함수는 재사용 가능하도록 프로그램을 구조화 프로시저 관련 레지스터 $a0~$a3 : 전달할 인수를 가지고 있는 인수 레지스터 $v0~$v1 : 반화뇌는 값을 갖게 되는 값 레지스터 $ra : 복귀주소(return address)를 가지고 있는 레지스터 프로시저를 위한 명령어 jal(jump-and-link instruction) 복귀주소를 $ra에 저장하고 프로시저가 할당된 주소로 점프하는 명령어 $ra의 주소로 복귀할 때 jr(jump register)명령어 를 사용 eg) jal procedure address, jr $ra 프로시저의 실행단계 프로시저가 접근 할 수 있는곳에서 인수를 넣는다. 프로시저로 제어를 넘긴다. 프로시저가 필요로하는 메모리 자원을 획득한다. 필요한 작업을 수행한다. 호출한 프로그램이 접근할 수 있는 레지스터에 결과값을 넘긴다. 호출한 프로그램으로 제어권을 반환한다. 스택 (정적변수 - 컴파일) 정적변수에 이용 (컴파일시 결정) 메모리를 사용 레지스터가 부족한 경우에 사용 후입선출(lifo)로 이루어진 선형 자로구조 push, pop 으로 데이터를 넣고 꺼낼 수 있다. 스택포인터(sp)의 값은 스택에서 데이터가 들어가고 나올때마다 변경된다. 스택은 높은 주소에서 낮은 주소로 생성되기 때문에 스택을 할당 할 때에는 sp에서 사용할 만큼의 값을 감소 시켜야한다. 스택 프레임 각 프로시저는 독립된 스택프레임을 가지고 있음 프로시저이 저장된 레지스터와 지역변수를 가지고 있는 스택영역 프레임포인터(fp)가 프로시저의 첫 번째 워드를 가리키도록 되어있음. fp에는 인수, 지역변수, 복귀주소 등이 저장됨 fp는 베이스레지스터의 역할을 하고 sp는 값이 변경되며 스택의 최하단을 가리킴 재뒤호툴등에서 ra값이 변경될 여지가 있으므로 복귀주소 저장 수단으로 스택프레임을 사용함. 연습문제 메모리 세그먼트 메모리는 각각 다른 값을 저장하는 블록으로 나누어져 있음 stack : 지역변수 선언, 정적할당, 프로그램 종료시 자동소멸 (8mb) heap : 동적으로 할당된 메모리영역, 개발자가 해제를 해줘야함. (링크드리스트) data : 전역변수 text : 기계어 저장 segmentation Fault : 참조할 수 없는 메모리역역을 참조했을 때 발생 에러 " }, { "title": "컴퓨터개론 15", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A015/", "categories": "CA", "tags": "", "date": "2021-06-20 00:00:00 +0900", "snippet": "판단 기능 조건부 분기 컴퓨터와 단순 계산기의 차이점 : 판단기능 입력데이터나 연산 결과에 따라 다른 명령어 실행가능 고급 언어 예시 : if, go to, switch-case switch-case 문은 if-then-else의 반복 MIPS에서 가장 간단하게 switch-case를 구현하는 방법은 if-then-else를 사용하는 것 조건부 분기 명령어 beq register1, register2, L1(임의값) bne register1, register2, L1(임의값) (효율성이 더 좋음) beq(branch if equal) : 비교 레지스터 값이 같을 경우 L1으로 분기 bne(branch if not equal) : 비교 레지스터 값이 다를 경우 L1으로 분기 연습문제 명령어 효율성 반복문 계산의 반복적인 수행을 위하여 instruction의 순환이 반드시 필요함 고급언어 예시: for, while while문 대/소의 비교 Equals, Not Equal외에 변수간 대/소 비교가 존재함 slt, slti 명령어를 이용하여 비교가능 첫번째 근원지 레지스터와 두번째 근원지 레지스터를 비교하여 첫번째가 작을 경우 목적지 레지스터를 1로 아닐경우 0으로 셋팅 부호없는 수(unsigned)끼리의 비교는 sltu, sltiu를 사용 " }, { "title": "컴퓨터개론 14", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A014/", "categories": "CA", "tags": "", "date": "2021-06-19 00:00:00 +0900", "snippet": "논리명령어 논리명령어의 정의 논리명령어란 and, nor, or 등의 논리연산을 하기위한 하기위한 명령어 비트들을 워드로 묶는 packing, 워드를 비트 단위로 나누는 unpacking 작업을 수행 논리명령어의 종류 연산자 고급언어표현 수행동작 sll « 비트를 왼쪽으로 이동시킴 srl » 비트를 오른쪽으로 이동시킴 and, andi &amp;amp; 비트간 and 연산 or, ori | 비트간 or연산 nor ~ Not, Or연산 시프트연산자srl $t2, $s0, 4 비트를 오른쪽으로 4칸 이동시킴0001 0000 &amp;gt; 0000 0001 // srl 41000 1000 &amp;gt; 0000 1000 // srl 4 지정된 비트수를 넘겼을 경우 최하위 비트는 버려짐!! 논리연산자 AND T F T 1 0 F 0 0 OR T F T 1 1 F 1 0 XOR T F T 0 1 F 1 0 NOR T F T 0 0 F 0 1 1010 OR 0101 = 1111 1010 AND 1001 = 1000 1010 NOR 0010 = 0101 1001 XOR 0110 = 1111" }, { "title": "cshap", "url": "/posts/cshap/", "categories": "lang", "tags": "", "date": "2021-04-08 00:00:00 +0900", "snippet": "cshap도입 c++의 연상력과 VB의 평의성을 결합하기 위한 목적으로 개발된 OOP 언어 닷넷 프레임워크에 최적화 되어있음다운로드프로젝트 생성기본구조 파악 컴파일은 무엇인가? c#으로 작성된 소스 파일을 컴파일 c# 컴파일어에 의해 exe(어플리케이션)나 dll(라이브러리) 파일 생성(어셈블리라고 부름) 어셈블리 안에는 CIL(common intermediate Language)와 메타데이터(meta-data),매니페스트(manifest) 정보가 포함 CIL이란 컴퓨터가 해석 가능한 원시 코드가 되지 전 중간 단계의 언어 JIT 컴파일러에 의해 원시코드로 변경 사용메소드 Console.Write() Console.WriteLine() - 라인피드 기능 추가 usingusing System; 네임스페이스를 사용한다는 의미 전체 이름을 참조하지 않고 선언된 네임스페이스 내부 개체들에 접근 가능 자바의 import와 유사 소스에서의 using은 자바의 try-catch-resource와 같이 자원을 회수namespacenamespace sampleName 네임프세이스는 관련된 구조체, 클래스, 델리게이트, 인터페이스 등을 그룹화 한것 java의 패키지와 유사main 프로그램의 최초의 진입점(entry point)이며 , 반드시 존재 메인 메소드가 시작되면 프로그램이 시작되며, 종료되면 프로그램도 같이 종료변수자료형 변수명; 값을 담아두는 상자 선언과 함께 초기화 및 여러개 생성 가능 할당하지 않은 변수를 사용하면 오류 발생자료형 변수명 = 초기값;자료형 변수명 = 초기값, 변수명 = 초기값, 변수명 = 초기값 ;기본 자료형 정수 자료형 자료형 앞에 u가 붙으면 unsigned의 줄임말로 음수의 범위만큼 양수의 범위 확장 실수 자료형 접미사 : float(f), decimal(m) 실수 상수의 기본값 : double 문자, 문자열 자료형 String == string 문자 비교시 Equals 또는 == 사용 가능 논리 자료형 bool == boolean 객체 자료형 최상위 클래스는 object 서식 지정자{인덱스[, 출력 너비][:서식 문자열]}형식 변환 정수와 실수using Systemnamespace ConsoleApplicatino1{ class Program { static void main(string[] args) { int a = 500; float b = a; // 자동 형 변환 Console.WriteLine(&quot;a = {0} ,b = {1}&quot;, a, b); // a = 500, b = 500 double c = 123.13; int d = (int)c; // 명시적 형 변환 Console.WriteLine(&quot;c = {0} ,d = {1}&quot;, c, d); // c = 123.12, d = 123 } }} 숫자와 문자using System;namespace ConsoleApplication1{ class Program { static void Main(string[] args) { int a = 500; float b = 60.44f; string c = a.ToString(); string d = c.ToString(); Console.WriteLine(&quot;a = {0}, b = {1}, c = {2}, d = {3}&quot;, a, b, c, d); string e = &quot;123&quot;; string f = &quot;123.123&quot;; int g = int.Parse(e); float h = float.Parse(f); Console.WriteLine(&quot;e = {0}, f = {1}, g = {2}, h = {3}&quot;, e, f, g, h); } }}상수const 변수타입 변수명;연산자수식 연산자 +, -, *, /, % 증감연산자 ++, – 관계연산자 &amp;lt;, &amp;gt;, ==, !=, &amp;gt;=, &amp;lt;= 할당연산자 =, +=, -=, *=, /=, %= 논리연산자 &amp;amp;&amp;amp; , || , ! 비트연산자 &amp;amp;, |, ^ 시프트연산자 &amp;gt;&amp;gt;, «if~elseif(조건식){}else if(){}else{}switch, breakswitch (조건식){ case 상수 : break; //없으면 예외 발생 case 상수 : break; default : break;}whilewhile (조건식){}do~whiledo {}while (조건식);forfor(초기식; 조건식; 증감식){}foreachforeach (변수 in 배열 또는 컬렉션){}break 루프 탈출continue 조건 점프goto, labelusing System;namespace ConsoleApplication1{ class Program { static void Main(string[] args) { int num = 0; while (num &amp;lt; 100) { if (num == 40) { goto EXIT2; } num++; } EXIT: Console.WriteLine(&quot;num = {0}&quot;, num); } }}메소드 [접근 지정자] 반환형식 메소드명(매개변수 목록){ }Call by value VS Call by Reference Call by valueusing System;namespace ConsoleApplication1{ class Program { static void Main(string[] args) { int a = 1; int b = 2; Console.WriteLine(&quot;a = {0}, b = {1}&quot;, a, b); Swap(a, b); Console.WriteLine(&quot;a = {0}, b = {1}&quot;, a, b); } static void Swap(int a , int b) { int temp = 0; temp = a; a = b; b = temp; } }} swap의 아규먼트는 a 변수의 메모리 주소가 아닌, a 변수의 값을 복제한 메모리 주소가 생성 Call by Reference using System;namespace ConsoleApplication1{ class Program { static void Main(string[] args) { int a = 1; int b = 2; Console.WriteLine(&quot;a = {0}, b = {1}&quot;, a, b); Swap(ref a, ref b); Console.WriteLine(&quot;a = {0}, b = {1}&quot;, a, b); } static void Swap(ref int a ,ref int b) { int temp = 0; temp = a; a = b; b = temp; } }} ref 예약어를 이용하여, 해당 메모리 주소값을 넘길수 있음메소드 오버로딩 시그니처의 차이에 따라 가능ref 메모리 주소를 넘김out 변수 초기화를 하지 않고 전달 가능using System;namespace ConsoleApplication1{ class Program { static void Main(string[] args) { int a = 1; int b; Swap(ref a,out b); Console.WriteLine(&quot;a = {0}, b = {1}&quot;, a, b); } static void Swap(ref int a ,out int b){ b = 100; int temp = 0; temp = a; a = b; b = temp; } }}params 개수가 변동적인 파라미터 처리using System;namespace ConsoleApplication1{ class Program { static void Main(string[] args) { Console.WriteLine(&quot;a = {0}&quot;, total(1,2,3,4,5,6,7)); } static int total(params int[] a) { int total = 0; foreach(int i in a) { total += i; } return total; } }}array자료형[] 배열명 = new 자료형[크기];System.Array 배열 지원 메소드다차원 배열자료형[,] 배열명 = new 자료형[형, 열];using System;namespace ConsoleApplication1{ class Program { static void Main(string[] args) { multiDemetion(); } static void multiDemetion(){ int[,] arr = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } }; for (int i = 0; i &amp;lt; sample.GetLength(0); i++) { for (int y = 0; y &amp;lt; sample.GetLength(1); y++) { if (y != sample.GetLength(1)-1) Console.Write(&quot;[&quot; + i + &quot;][&quot; + y + &quot;]&quot;); else Console.WriteLine(&quot;[&quot; + i + &quot;][&quot; + y + &quot;]&quot;); } } } }}객체(object)클래스(class)[접근 제한자] class 클래스명{}using System;namespace ConsoleApplication1{ class Program { static void Main(string[] args) { Dog dog = new Dog(); dog.name = &quot;얼룩이&quot;; dog.gender = &quot;male&quot;; dog.bark(); } } class Dog { private string _name; public string name { set{_name = value;} get{return _name;} } private string _gender; public string gender { set{_gender = value;} get{return _gender;} } public void bark() { Console.WriteLine(&quot;{0} : 멍{1}&quot;, _name , _gender); } }}접근 제한자|접근제한자 | 설명||:–|:–||public| 어디서든 접근 가능||protected| 파생 클래스에서 접근 가능||internal| 같은 어셈블리에서만 접근가능||protected internal| 같은 어셈블리의 파생클래스에서만 접근 가능||private|클래스 내부에서만 접근 가능|this생성자 자바와 같이 아무것도 적지 않으면 기본 생성자가 생성 클래스명 객체명 = new 생성자; class 클래스명 [접근 제한자] 클래스명(매개변수) { }소멸자 GC에 의해 처리되기 전 실행 호출, 상속, 오버로드 불가class 클래스명{ ~클래스명() { }}상속 private 타입은 비상속class 부모클래스{}class 자식 클래스 : 부모 클래스{}sealed 클래스명 앞에 sealed 사용시 상속 불가set, getpublic class 클래스명{ public 변수형태 변수 { set{} get{} }}virtual, override 자식 메소드에서 부모 메소드를 재정의 하고자 한다면, 반드시 virtual 키워드를 붙여야만 재정의가 가능 private 메서드는 재정의 분가 재정의 하기 위해서는 자식 메서드에서 override 키워드를 붙여 재정의new 자식클래스에 부모 클래스와 같은 필드가 있을 경우, 발생하는 경고 표시를 제거하기 위한 기능 ( 의도적이라는 표현 강조)Upcasting and Downcasting Upcasting : 이슈 없음 Downcasting : 이슈 발생Extension Method 기존 클래스를 직접 수정 불가하며 wapper 패턴으로 처리가 불가할 경우, 해당 메소드의 기능을 확장하고 싶은 경우 확장 메소드의 첫번째 매개변수는 this 한정자가 반드시 존재namespace 네임스페이스명{ public static class 클래스명 { public static 반환형식 메소드명(this 확장대상형식 식별자, 매개변수 ...){ ... } ... }}using System;using Extension;namespace ConsoleApplication1{ class Program { static void Main(string[] args) { Console.WriteLine(&quot;{0}&quot;, 4.Multiplication(2, 3)); // 32 } }}namespace Extension{ public static class ExtensionMethod { public static int Multiplication(this int var, int a, int b) { int result = var; for (int i = 0; i &amp;lt; b; i++) result *= a; return result; } }}partial class 하나의 클래스를 분할using System;namespace ConsoleApplication1{ partial class Nested { public void Test() { Console.WriteLine(&quot;Test()&quot;); } } partial class Nested { public void Test2() { Console.WriteLine(&quot;Test2()&quot;); } } partial class Nested { public void Test3() { Console.WriteLine(&quot;Test3()&quot;); } } class Program { static void Main(string[] args) { Nested nested = new Nested(); nested.Test(); nested.Test2(); nested.Test3(); } }}Nested class 클래스 내부에 클래스를 구현 class 클래스명{class 클래스명{}} using System;namespace ConsoleApplication1{ public class OuterClass { private int a =70; public class InnerClass { OuterClass instance; public InnerClass(OuterClass a_instance) { instance = a_instance; } public void AccessVariable(int num) { this.instance.a = num; } public void ShowVariable() { Console.WriteLine(&quot;a : {0}&quot;, this.instance.a); } } } class Program { static void Main(string[] args) { OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = new OuterClass.InnerClass(outer); inner.ShowVariable(); inner.AccessVariable(60); inner.ShowVariable(); } }}" }, { "title": "php-tutorial", "url": "/posts/php-tutorial/", "categories": "php", "tags": "", "date": "2021-03-22 00:00:00 +0900", "snippet": "본문서는 php 튜토리얼 문서를 요약한 문서입니다.1. PHP 소개 APM : (Apache + php + mysql)2. 출력문 php를 시작하기 위해서는 &amp;lt;?php를 작성하여 시작하고 ?&amp;gt;를 작성하여 끝낸다 &amp;lt;?과 php 사이의 공백이 있는 형태는 정상 작동하지 않는다. 예)&amp;lt;? php hello world를 출력하는 예제 &amp;lt;?php echo &quot;hello world&quot;; ?&amp;gt; echo 는 대소문자를 구분 하지 않는다. 세미콜론(;)은 반드시 필요한 것은 아니다 쌍따옴표(““)가 아닌 따옴표(‘‘)로 표현도 가능하다.3. 주석 다중 주석 /**/ 한줄 주석 // 주석 예제 &amp;lt;?php//echo &quot;hello world&quot;; ?&amp;gt; 4. 변수 유용한 함수 gettype()을 사용하면 데이터형 확인 가능 var_dump()함수는 테이터형과 값을 출력 다른 언어와 달리 변수를 선언할때 $(스트링)을 붙여서 사용 변수 선언시에는 @,#,%,&amp;amp;,- 등의 숫자는 사용 불가 echo “”; 안에서 변수명 출력이 필요한 경우 \\ 를 붙여주면 변수명 출력 (따옴표(‘‘)를 사용시 미적용되며 문자 그대로 표시) php는 변수의 데이터형을 따로 지정해 주지 않으며, 변수에 따라서 데이터형이 자동으로 형 변환 변수 선언은 $변수면 = 초기화 데이터 형태를 사용 에제 &amp;lt;?php$test = &quot;test&quot;;echo &quot;\\$test is $test&quot;; ?&amp;gt; 정수형의 오버플로우 형변환 정수값 표현을 초과하게 되면 정수형이 아닌 실수형으로 넘어감 예제(32bit) &amp;lt;?php $int = 2147483647; echo &quot;\\$int id &quot;; var_dump($int); echo &quot;&amp;lt;br/&amp;gt;&quot;; $int += 1; echo &quot;\\$int id &quot;; var_dump($int); echo &quot;&amp;lt;br/&amp;gt;&quot;; ?&amp;gt; 예제(64bit) &amp;lt;?php $int = 9223372036854775807; echo &quot;\\$int id &quot;; var_dump($int); echo &quot;&amp;lt;br/&amp;gt;&quot;; $int += 1; echo &quot;\\$int id &quot;; var_dump($int); echo &quot;&amp;lt;br/&amp;gt;&quot;; ?&amp;gt; 변수명 입력 주의점 변수명 입력시, 띄어쓰기 또는 {} 로 확실한 구분 필요 예제 &amp;lt;?php $name = &quot;test&quot;; echo &quot;$nameis a test&quot;; echo &quot;$name is a test&quot;; echo &quot;{$name} is a test&quot;; ?&amp;gt; 5. 상수 변수와 달리 $를 미사용 세번째 agument는 대소문자 구분 상수는 최초 할당된 값이 변하지 않음 define(“상수명”,”상수값”,대소문자구별여부(true/false)) 출력시 상수명을 그대로 입력합니다. 예제 &amp;lt;?php define(&#39;test&#39;,&#39;test&#39;,true); echo test ?&amp;gt; " }, { "title": "webhook", "url": "/posts/webhook/", "categories": "it", "tags": "", "date": "2021-03-12 00:00:00 +0900", "snippet": "webhook[웹훅] 웹푹은 새 이벤트가 발생한 경우 서버 측 응용프로그램이 클라이언트 측 응용프로글매에 알리수 있는 메커니즘 역방향 API 라고도 하며, 일반적인 API는 클라이언트가 서버를 호출하는 반면, 웹훅의 경우 서버에 웹훅을 등록하면 특정한 이벤트가 발생시 클라이언트를 호출 합니다. 이러한 웹훅 서버에스는 변조된 클라이언트의 POST 호출을 검증할 수 있도록 다음과 같은 인증을 사용합니다 출발지 IP를 미리 설정하여 인증 HTTP 기본 인증을 사용하여 인증 시크릿 키 또는 서명을 이용하여 인증 HAMC의 서명을 HTTP HEAD에 추가하여 인증 SHA-1을 이용한 서명을 이용하여 인증 TLS를 프로토롤내에서, 인증서를 이용하여 인증" }, { "title": "webhook", "url": "/posts/TIL-webhook/", "categories": "it", "tags": "", "date": "2021-03-12 00:00:00 +0900", "snippet": "webhook[웹훅] 웹푹은 새 이벤트가 발생한 경우 서버 측 응용프로그램이 클라이언트 측 응용프로글매에 알리수 있는 메커니즘 역방향 API 라고도 하며, 일반적인 API는 클라이언트가 서버를 호출하는 반면, 웹훅의 경우 서버에 웹훅을 등록하면 특정한 이벤트가 발생시 클라이언트를 호출 합니다. 이러한 웹훅 서버에스는 변조된 클라이언트의 POST 호출을 검증할 수 있도록 다음과 같은 인증을 사용합니다 출발지 IP를 미리 설정하여 인증 HTTP 기본 인증을 사용하여 인증 시크릿 키 또는 서명을 이용하여 인증 HAMC의 서명을 HTTP HEAD에 추가하여 인증 SHA-1을 이용한 서명을 이용하여 인증 TLS를 프로토롤내에서, 인증서를 이용하여 인증" }, { "title": "bearer Token", "url": "/posts/bearerToken/", "categories": "auth", "tags": "", "date": "2021-03-11 00:00:00 +0900", "snippet": "Stateful 서버클라이언트의 요청을 받을 때 마다, 클라이언트의 상태를 계속해서 유지하고, 그 정보를 서비스 제공에 이용ex) 세션 |유지 서버Stateless 서버상태를 유지하지 않는 서버 ( 확장성이 높아진다)서버 기반 인증의 문제점 세션 유저수 증가에 따른 부하 증가(메모리 또는 기타) 확장성 트래픽 분산을 위한 확장의 어려움 CORS 여러 도매인에서 쿠키 관리의 어려움 Json Web Token(JWT) 용도 회원인증 정보교환 생김새 aaaaaa.bbbbbbb.ccccccccc(header)(payload)(Signature) 해더(header) typ : 토큰 타입 (JWT) alg : 해싱 알고리즘 (HMAC SHA256, RSA) {&quot;typ&quot; : &quot;JWT&quot;&quot;alg&quot; : &quot;HMAC256&quot;} const header = { &quot;typ&quot; : &quot;JWT&quot; &quot;alg&quot; : &quot;HMAC256&quot;}//encode to base64const encodeHeader = new Buffer(JSON.stringify(header)) .toString(&#39;base64&#39;) .replace(&quot;=&quot;,&#39;&#39;); //패딩 제거 정보(payload) 클레임 정보의 한 조각을 클레임(claim)이라고 부름(name/value) 등록된(registered), 공개(public), 비공개(private) 으로 구분 등록된(registered) 클레임 이미 정해진 클레임 모두 선택적(optional) 클레임명 상세내용 iss 토큰발급자 sub 토큰제목 aud 토큰대상자 exp 토큰 만료시간(numbericDate) nbf 토큰 활성시간(Not Before) iat 토큰이 발급된 시간(age파악가능) jti JWT 고유 식별자 공개(public)클레임 충돌 방지된 이름(URI 형식의 이름을 가짐) {&quot;https://linkHub.com&quot; : true} 비공개(private) 클레임 클라이언트와 서버의 형희하에 사용되는 클레임 이름 충돌 가능성이 있음 {&quot;username&quot; : &quot;test&quot;} 예제{ &quot;iss&quot; : &quot;LinkHub.com&quot;, &quot;exp&quot; : &quot;1485300000000&quot;, &quot;https://linkHub.com&quot; : true, &quot;username&quot; : &quot;test&quot;} 서명(Signature) 해더의 인코딩값과, 정보의 인코딩 값을 합친후 비밀키로 해쉬를 생성 hex =&amp;gt; base64 인코딩 HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload) , secret) const crypto = require(&#39;crypto&#39;);const Signature = crypto.createHmac(&#39;sha256&#39;, &#39;secret&#39;) .update(encodeHeader + &#39;.&#39; + encodepayload) .digest(&#39;base64&#39;) .replace(&quot;=&quot;,&#39;&#39;); //패딩 제거 토큰 완성 " }, { "title": "자바스터디 15주차", "url": "/posts/whiteship-study-15week/", "categories": "study", "tags": "", "date": "2021-03-05 00:00:00 +0900", "snippet": "GOAL자바의 람다식에 대해 학습하세요.학습할 것 (필수) 람다식 사용법 함수형 인터페이스 Variable Capture 메소드, 생성자 레퍼런스람다식 사용법자바가 1996년에 처음 등장한 이후로 두 번의 큰 변화가 있었는데, 한번은 JDK 1.5부터 추가된 지네릭스(generics)의 등장이고, 또 한 번은 JDK 1.8부터 추가된 람다식(lambda expression)의 등장이다.특히 람다식의 도입으로 인해, 자바는 객체지향언어인 동시에 함수형 언어가 되었다.자바의 정석 3판람다식이란?오라클 공식 문서에서는 다음과 같이 표현하고 있다.메서드가 하나 뿐인 클래스의 경우 익명 클래스도 약간 과도하고 번거로운 것처럼 보입니다. Lambda 표현식을 사용하면 단일 메서드 클래스의 인스턴스를보다 간결하게 표현할 수 있습니다. 익명클래스는 사용하기 쉽지만 잘못하면 복잡해 질수 있기 때문에, 더 단순화 하는 것이 람다의 주요 목적입니다. 때문에 람다식을 ‘익명 함수(anonymous function)’ 라고도 합니다. 사실상 익명함수의 단축화된 표현이기 때문이다.람다식 작성사용자의 성별을 반환하는 인트페이스를 정의한다.public interface Func { String isMale(String gender);}일반적으로 익명함수는 다음과 같이 사용한다.public class Test { public static void main(String[] args) { Func tes = new Func() { @Override public String isMale(String gender) { return gender; } }; }} 바이트코드public class week15.Test { public week15.Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #7 // class week15/Test$1 3: dup 4: invokespecial #9 // Method week15/Test$1.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: return}이 메서드를 람다식으로 변환하면 다음과 같이 할 수 있다. public class Test { public static void main(String[] args) { Func tes = gender -&amp;gt; gender; } } 바이트코드public class week15.Test { public week15.Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: invokedynamic #7, 0 // InvokeDynamic #0:isMale:()Lweek15/Func; 5: astore_1 6: return}코드가 간결해 지며, 내부 바이트 코드에도 변화가 발생하는것을 볼수 있다.다음은 어떻게 코드가 줄어지는지 순서대로 확인해 보자.람다식은 ‘익명 함수’답게 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통 { } 사이에 -&amp;gt;를 추가한다. 반환타입 메서드이름(매개변수 선언) { 문장들 } &amp;#8681; 반환타입 메서드이름 (매개변수 선언) -&amp;gt; { 문장들 } public class Test { public static void main(String[] args) { Func tes = (String gender) -&amp;gt; { return gender; }; }}반환값이 있는 메서드의 경우, return문 대신 ‘식(expression)’으로 대신 할 수 있다. 식의 연산결과가 자동적으로 반환값이 되고 이 때는 ‘문장(statement)’이 아닌 식이므로 끝에 ;를 붙이지 않는다.public class Test { public static void main(String[] args) { Func tes = (String gender) -&amp;gt; gender; }}람다식에 선언된 매개변수의 타입은 추론이 가능한 경우에 생략할 수 있다. 대부분의 경우 생략이 가능한데 람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다. 한 가지 주의해야 할 점은 매개변수가 두개 이상일 경우 어느 하나의 타입만 생략하는 것은 허용되지 않는다는 점이다. public class Test { public static void main(String[] args) { Func tes = (gender) -&amp;gt; gender; } }선언된 매개변수가 하나뿐인 경우에는 괄호( )를 생략할 수 있다. 단, 매개변수의 타입이 있으면 생략할 수 없다. public class Test { public static void main(String[] args) { Func tes = gender -&amp;gt; gender; } }추가적으로 괄호{ } 안의 문장이 하나일 때는 역시 괄호{ }를 생략할 수 있다. 이 때 문장의 끝에 ;를 붙이지 않아야 한다는 것을 기억해야 한다. (String name, int i) -&amp;gt; { System.out.println(name + &quot; = &quot; + i); } (String name, int i) -&amp;gt; System.out.println(name + &quot; = &quot; + i)그러나 괄호{ } 안의 문장이 return문일 경우 생략할 수 없다. 또한 return문과 식의 차이를 기억해야 한다. (int a, int b) -&amp;gt; { return a &amp;gt; b ? a : b; } // return문 Ok. (int a, int b) -&amp;gt; return a &amp;gt; b ? a : b // return문 error. (int a, int b) -&amp;gt; a &amp;gt; b ? a : b // 식(expression)함수형 인터페이스자바에서 모든 메서드는 클래스 내에 포함되어야 하는데, 람다식은 어떤 클래스에 포함되는 것일까요? 람다식이 메서드와 동등한 것이라고 생각했지만, 사실 람다식은 익명 클래스의 객체와 동등하다.그렇다면 람다식으로 정의된 익명 객체의 메서드를 어떻게 호출할 수 있을까요? 참조변수가 있어야 객체의 메서드를 호출할 수 있으니 익명 객체의 주소를 f라는 참조변수에 저장해 보자. 타입 f = (int a, int b) -&amp;gt; a &amp;gt; b ? a : b;자, 이제 참조변수 f의 타입은 어떤 것이어야 할까? 참조형이니 클래스 또는 인터페이스가 가능하다. 그리고 람다식과 동등한 메서드가 정의되어 있는 것이어야 한다. 그래야 참조변수로 익명 객체(람다식)의 메서드를 호출할 수 있기 때문이다.예를 들어 max()라는 메서드가 정의된 MyFunction 인터페이스가 아래와 같이 정의되어 있다. interface MyFunction { public abstract int max(int a, int b); }그러면 이 인터페이스를 구현한 익명 클래스의 객체는 다음과 같이 생성할 수 있다. MyFunction f = new MyFunction() { public int max(int a, int b) { return a &amp;gt; b ? a : b; } }; int big = f.max(5, 3);MyFunction 인터페이스에 정의된 메서드 max()는 람다식 (int a, int b) -&amp;gt; a &amp;gt; b ? a : b과 메서드의 선언부가 일치한다. 따라서 익명 객체를 람다식으로 대체할 수 있다. MyFunction f = (int a, int b) -&amp;gt; a &amp;gt; b ? a : b; int big = f.max(5, 3);이처럼 MyFunction 인터페이스를 구현한 익명 객체를 람다식으로 대체 가능한 이유는, 람다식도 실제로는 익명 객체이고, MyFunction 인터페이스를 구현한 익명 객체의 메서드 max()와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 때문이다.하나의 메서드가 선언된 인터페이스를 정의하여 람다식을 다루면 기존의 자바 규칙을 어기지 않으면서 자연스럽게 다룰 수 있다. 그래서 인터페이스를 통해 람다식을 다루기로 결정했고, 람다식을 다루기 위한 인터페이스를 ‘함수형 인터페이스(functional interface)’라고 부른다. @FunctionalInterface interface MyFunction { public abstract int max(int a, int b); }단, 함수형 인터페이스에는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다. 애노테이션 @FunctionalInterface를 사용하면 컴파일러가 올바르게 정의되어 있는지 확인해주므로 꼭 사용하도록 하자.함수형 인터페이스 타입의 매개변수와 반환타입함수형 인터페이스 MyFunction이 아래와 같이 정의되어 있다. @FunctionalInterface interface MyFunction { void myMethod(); // 추상 메서드 }메서드의 매개변수가 MyFunction타입이면, 이 메서드를 호출할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야 한다. void aMethod(MyFunction f) { f.myMethod(); // MyFunction에 정의된 메서드 호출 } ... MyFunction f = () -&amp;gt; System.out.println(&quot;myMethod()&quot;); aMethod(f);또는 참조변수 없이 아래와 같이 직접 람다식을 매개변수로 지정하는 것도 가능하다. aMethod(() -&amp;gt; System.out.println(&quot;myMethod()&quot;));메서드의 반환타입이 함수형 인터페이스 타입이라면, 이 함수형 인터페이스의 추상메서드와 동등한 람다식을 가리키는 참조변수를 반환하거나 람다식을 직접 반환할 수 있다. MyFunction myMethod() { MyFunction f = () -&amp;gt; {}; return f; // return () -&amp;gt; {}; }람다식을 참조변수로 다룰 수 있다는 것은 메서드를 통해 람다식을 주고받을 수 있다는 것을 의미한다. 즉, 변수처럼 메서드를 주고받는 것이 가능해진 것이다.▶ 예제▶ MyFunction01.javapackage lambda;public interface MyFunction01 { void run();}&amp;amp;9654; Ex01.javapackage lambda;public class Ex01 { static void execute(MyFunction01 f) { f.run(); } static MyFunction01 getMyFuction() { MyFunction01 f = () -&amp;gt; System.out.println(&quot;f3.run()&quot;); return f; } public static void main(String[] args) { MyFunction01 f1 = () -&amp;gt; System.out.println(&quot;f1.run()&quot;); MyFunction01 f2 = new MyFunction() { @Override public void run() { System.out.println(&quot;f2.run()&quot;); } }; MyFunction01 f3 = getMyFuction(); f1.run(); f2.run(); f3.run(); execute(f1); execute( () -&amp;gt; System.out.println(&quot;run()&quot;) ); }}람다식의 타입과 형변환함수형 인터페이스로 람다식을 참조할 수 있는 것일 뿐이지 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다. 람다식은 익명 객체이고 익명 객체는 타입이 없다.정확히는 타입은 있지만 컴파일러가 임의로 이름을 정하기 때문에 알 수 없는 것이다. 그래서 대입 연산자의 양변의 타입을 일치시키기 위해 형변환이 필요하다. MyFunction f = (MyFunction)( () -&amp;gt; { } );람다식은 MyFunction 인터페이스를 직접 구현하지 않았지만, 이 인터페이스를 구현한 클래스의 객체와 완전히 동일하기 때문에 위와 같은 형변환을 허용한다. 그리고 이 형변환은 생략가능하다.람다식은 이름이 없을 뿐 분명히 객체인데도, Object타입으로 형변환 할 수 없다. 람다식은 오직 함수형 인터페이스로만 형변환이 가능하다. Object obj = (Object)( () -&amp;gt; { } ); // error. 함수형 인터페이스로만 가능굳이 변경하고자 한다면, 함수형 인터페이스로 변환하고 난 후에 가능하다.다음 예제는 컴파일러가 람다식의 타입을 어떤 형식으로 만들어내는지 알아내는 코드이다.▶ MyFunction02.javapackage lambda;public interface MyFunction02 { void myMethod();}▶ Ex02.javapackage lambda;public class Ex02 { public static void main(String[] args) { MyFunction02 f = () -&amp;gt; {}; Object obj = (MyFunction02)(() -&amp;gt; {}); String str = ((Object)(MyFunction02)(() -&amp;gt; {})).toString(); System.out.println(f); System.out.println(obj); System.out.println(str); // System.out.println( () -&amp;gt; {} ); System.out.println((MyFunction02)( () -&amp;gt; {} )); // System.out.println((MyFunction02)( () -&amp;gt; {} ).toString()); System.out.println(((Object)(MyFunction02)(() -&amp;gt; {})).toString()); }}일반적인 익명 객체라면, 객체의 타입이 외부클래스이름$번호와 같은 형식으로 타입이 결정되었을 텐데, 람다식의 타입은 외부클래스이름$$Lambda$번호와 같은 형식으로 되어 있는 것을 확인할 수 있다.Variable Capture멤버 메서드 내부에서 클래스의 객체를 생성해 사용할 경우 다음과 같은 문제가 있다.익명 구현 객체를 포함해 객체를 생성한다는 것은 new라는 키워드를 사용하는데 이 키워드를 사용한다는 의미는 동적 메모리 할당 영역인 heap 영역에 객체를 생성한다는 것이다.이렇게 생성된 객체는 자신을 감싸고 있는 멤버 메서드의 실행이 끝난 후에도 heap 영역에 존재하므로 사용할 수 있다. 하지만 이 멤버 메서드에 정의된 매개변수나 지역변수는 런타임 스택 영역에 할당되어 메서드 실행이 끝나면 사라져 더 이상 사용할 수 없게 된다.따라서 멤버 메서드 내부에서 생성된 객체가 자신을 감싸고 있는 메서드의 매개변수나 지역변수를 사용하려 할 때 문제가 생길 수 있다.정리하면 클래스의 멤버 메서드의 매개변수와 이 메서드 실행 블록 내부의 지역변수는 JVM의 런타임 스택 영역에 생성되고 메서드의 실행이 끝나면 런타임 스택 영역에서 사라진다. new 연산자를 사용해 생성한 객체는 JVM의 heap 영역에 객체가 생성되고 GC에 의해 관리되며, 더 이상 사용하지 않는 객체에 대해 메모리에서 제거한다.heap 영역에 생성된 객체가 스택 영역의 변수를 사용하려고 하는데, 해당 시점에 스택 영역에 더 이상 변수가 존재하지 않을 수 있고, 이 때문에 오류가 발생한다.자바에서는 이 문제를 variable capture라고 하는 값 복사를 사용해 해결한다.컴파일 시점에 멤버 메소드의 매개변수나 지역 변수를 멤버 메서드 내부에서 생성한 객체가 사용할 경우 객체 내부로 값을 복사해 사용한다. 하지만 모든 값을 복사해서 사용할 수 있는 것은 아니고, final 키워드로 작성되거나 final 성격을 가져야 한다는 제약이 있다.로컬 변수 캡쳐 (Local Variable Capture)Local variable은 조건이 final 또는 effectively final이어야 한다. final은 흔히 사용해봐서 알지만 effectively final은 뭘까?effectively final은 Java 8에 추가된 syntatic sugar의 일종으로 초기화된 이후 값이 한번도 변경되지 않았다는 것을 말한다. effectively final 변수는 final 키워드가 붙어 있지 않지만 final 키워드를 붙인 것과 동일하게 컴파일에서 처리한다.한마디로 초기화하고 값이 변경되지 않은 것을 말한다.그렇다면 Local variable에는 왜 이런 조건이 붙어 있을까? 그것은 JVM의 메모리 구조를 보면 알 수 있다.지역 변수는 쓰레드 간에 공유가 불가능하다. 인스턴스 변수는 JVM의 heap 영역에 생성되는데, 지역 변수와 달리 쓰레드 간에 공유가 가능하다. 즉, 지역 변수가 스택에 저장되기 때문에 람다식에서 값을 바로 참조하는데 제약이 있다. 복사된 값을 사용하는데 멀티 쓰레드 환경에서 변경이 되면 동시성에 대한 이슈를 대응하기 힘들기 때문이다.메소드, 생성자 레퍼런스메소드 레퍼런스람다식으로 메서드를 간결하게 표현할 수 있는데, 놀랍게도 람다식을 더욱 간결하게 표현할 수 있는 방법이 있다. 람다식이 하나의 메서드만 호출하는 경우에 ‘메서드 참조(method reference)’라는 방법으로 간략히 할 수 있다.예를 들어 문자열을 정수로 변환하는 람다식은 아래와 같이 작성할 수 있다. Function&amp;lt;String, Integer&amp;gt; f = (String s) -&amp;gt; Integer.parseInt(s);이 람다식을 메서드로 표현하면 다음과 같다. Integer wrapper(String s) { return Integer.parseInt(s); }여기서 wrapper 메서드는 그저 값을 받아서 Integer.parseInt()에게 넘겨주는 일만 한다. 그렇다면 이 메서드를 벗겨내고 직접 호출해보면 어떨까?▶ 람다식 Function&amp;lt;String, Integer&amp;gt; f = (String s) -&amp;gt; Integer.parseInt(s);▶ 메서드 참조 Function&amp;lt;String, Integer&amp;gt; f = Integer::parseInt;메서드 참조에서 람다식의 일부가 생략되었지만, 컴파일러는 생략된 부분을 쉽게 알아낼 수 있다. 우변의 parseInt 메서드의 선언부, 또는 좌변의 Function 인터페이스에 지정된 지네릭 타입으로부터 알아내는 것이다.다음과 같은 람다식을 메서드 참조로 변경해보자. BiFunction&amp;lt;String, String, Boolean&amp;gt; f = (s1, s2) -&amp;gt; s1.equals(s2);참조변수 f의 타입을 보면 람다식이 두 개의 String 타입의 매개변수를 받는다는 것을 알 수 있다. 따라서 람다식의 매개변수들은 없어도 된다. 매개변수들을 제거해서 메서드 참조로 변경하면 다음과 같이 된다. BiFunction&amp;lt;String, String, Boolean&amp;gt; f = String::equals;s1과 s2를 생략하고나면 equals만 남는데, 두 개의 String을 받아서 Boolean으로 반환하는 equals라는 이름의 메서드는 다른 클래스에도 존재할 수 있기 때문에 equals 앞에 클래스 이름이 반드시 필요하다.메서드 참조를 사용할 수 있는 경우가 한 가지 더 있는데, 이미 생성된 객체의 메서드를 람다식에서 사용한 경우에는 클래스 이름 대신 그 객체의 참조변수를 적어줘야 한다. MyClass obj = new MyClass(); Function&amp;lt;String, Boolean&amp;gt; f = (x) -&amp;gt; obj.equals(x); // 람다식 Function&amp;lt;String, Boolean&amp;gt; f2 = obj::equals; // 메서드 참조이렇게 살펴본 메서드 참조를 정리해보면 다음과 같다.▶ static 메서드 참조 메서드 참조는 static 메서드를 직접적으로 가리킬 수 있다.클래스이름::메서드이름(매개변수) -&amp;gt; Class.staticMethod(매개변수)String::valueOfstr -&amp;gt; String.valueOf(str)▶ 인스턴스 메서드 참조클래스이름::메서드이름(obj, 매개변수) -&amp;gt; obj.instanceMethod(매개변수)String::length(value) -&amp;gt; value.length();▶ 특정 객체 인스턴스 메서드 참조 특정 인스턴스의 메서드를 참조할 수 있다. 클래스 이름이 아닌 인스턴스 명을 넣는다.obj::instanceMethod(매개변수) -&amp;gt; obj.instanceMethod(매개변수)object::toString() -&amp;gt; object.toString()생성자의 메서드 참조생성자를 호출하는 람다식도 메서드 참조로 변환할 수 있다. Supplier&amp;lt;MyClass&amp;gt; s = () -&amp;gt; new MyClass(); Supplier&amp;lt;MyClass&amp;gt; s = MyClass::new;매개변수가 필요한 생성자라면, 매개변수의 개수에 따라 알맞은 함수형 인터페이스를 사용하면 된다. 필요에 따라 함수형 인터페이스를 새로 정의해야 한다. Function&amp;lt;Integer, MyClass&amp;gt; f = (i) -&amp;gt; new MyClass(i); Function&amp;lt;Integer, MyClass&amp;gt; f2 = MyClass::new;출처자바의 정석 3판오라클 튜토리얼개발자 한선우" }, { "title": "자바스터디 14주차", "url": "/posts/whiteship-study-14week/", "categories": "study", "tags": "", "date": "2021-02-25 00:00:00 +0900", "snippet": "GOAL자바의 제네릭에 대해 학습하세요.학습할 것 (필수) 제네릭 사용법 제네릭 주요 개념 (바운디드 타입, 와일드 카드) 제네릭 메소드 만들기 Erasure제네릭 사용법제네릭소프트웨어 프로젝트에서 버그 발생은 당연한 사실입니다. 신중한 계획, 프로그래밍 및 테스트는 버그 발생률을 줄이는 데 도움이 될 수 있지만 코드 어딘가에는 버그가 존재할 수 있습니다. 이것은 새로운 기능이 도입되고 코드 기반이 크기와 복잡성이 증가함에 따라 특히 그 빈도가 능가합니다.다행히도 일부 버그는 다른 버그보다 감지하기 쉽습니다. 예를 들어 컴파일 타임 버그는 초기에 발견 할 수 있습니다. 컴파일러의 오류 메시지를 사용하여 문제가 무엇인지 파악하고 즉시 수정할 수 있습니다. 그러나 런타임 버그는 훨씬 더 문제가 될 수 있습니다. 런타입 버그는 바로 발견하기 어려우며, 또한 문제의 실제 원인을 발견하기 어려울 수도 있습니다.제네릭은 이러한 에러를 런타임이 아닌 컴파일 시 검증할 수 있도록 해주며 그로인한 안정성을 추구할 수 있습니다.(JDK 1.5버전 부터 사용 가능합니다.)사용하는 이유제네릭은 클래스, 인터페이스 및 메서드를 정의 할 때 (클래스 및 인터페이스의)매개 변수의 타입을 정의 할수 있습니다. 일반적으로 메서드에 사용하는 파라미터 형식으로 매개변수 타입을 정의 할 수 있습니다.제네릭을 사용하는 코드는 제네릭이 아닌 코드에 비해 많은 이점이 있습니다. 컴파일 타임시, 강력한 타입 체크 Java 컴파일러는 강력한 타입 검사를 수행하며 코드가 타입 안전성(type-safety)을 위반하면 오류를 발생시킵니다. 컴파일 타임 오류를 수정하는 것은 찾기 어려울 수있는 런타임 오류를 수정하는 것보다 쉽습니다. 형변환 제거제네릭을 사용하지 않는 다음코드는 형변환이 필요합니다 List list = new ArrayList();list.add(&quot;hello&quot;);String s = (String) list.get(0); 하지만 제네릭을 사용시 형변환이 필요 없습니다. List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();list.add(&quot;hello&quot;);String s = list.get(0); // 형 변환 필요 없음 프로그래머가 일반 알고리즘을 구현할 수 있도록합니다.프로그래머는 제네릭을 사용하여 다양한 유형의 컬렉션에서 작동하고 사용자 정의 할 수 있으며 타입에 안전(type-safety)하고 읽기 쉬운 제네릭 알고리즘을 구현할 수 있습니다.선언class Box&amp;lt;T1,T2,…&amp;gt; 명칭 내용 T1,T2,… 타입 변수 또는 타입 매개변수 Box 원시타입 비교위의 선언 방식을 이용하여 제네릭이 적용된 클래스와 비적용된 클래스를 비교해 봅니다. 제네릭 비적용public class NoGenericBox { private Object object; public void set(Object object) { this.object = object; } public Object get() { return object; }} 바이트코드public class week14.NoGenericBox { public week14.NoGenericBox(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void set(java.lang.Object); Code: 0: aload_0 1: aload_1 2: putfield #2 // Field object:Ljava/lang/Object; 5: return public java.lang.Object get(); Code: 0: aload_0 1: getfield #2 // Field object:Ljava/lang/Object; 4: areturn} 제네릭 적용public class GenericBox&amp;lt;T&amp;gt; { private T t; public void set(T t) { this.t = t; } public T get() { return t; }} 바이트코드public class week14.GenericBox&amp;lt;T&amp;gt; { public week14.GenericBox(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void set(T); Code: 0: aload_0 1: aload_1 2: putfield #2 // Field t:Ljava/lang/Object; 5: return public T get(); Code: 0: aload_0 1: getfield #2 // Field t:Ljava/lang/Object; 4: areturn}위 코드 보면 제네릭을 사용시 putfield,getfield 함수를 이용하고 있습니다. 두 함수는 참조된 필드의 타입을 확인하며, 해당 타입의 필드가 static일 경우, IncompatibleClassChangeError에러를 발생 시킵니다. 또한 final일 경우, 초기화를 반드시 진행 해야하며, 그렇지 않으면 IllegalAccessError에러를 발생 시킵니다.위 코드를 확인하면, Object는 모두 T로 변환됩니다. 이러한 타입 변수는 원시 타입을 포함한 원시타입 이외의 클래스, 인터페이스, 배열 등올 설정가능합니다.타입변수 명명규칙규칙에 따라 타입 파라미터 이름은 단일 대문자입니다. 이것은 이미 알고 있는 변수 명명 규칙 과는 뚜렷한 대조를 이루며 그럴만 한 이유가 있습니다. 이 규칙이 없으면 유형 변수와 일반 클래스 또는 인터페이스 이름의 차이를 구분하기 어려울 것입니다.가장 일반적으로 사용되는 타입 파라미터 이름은 다음과 같습니다. 변수 내용 E 요소 (Java Collections Framework에서 광범위하게 사용됨) K 키 N 숫자 T 타입 V 값 S, U, V 등 2, 3, 4번때 타입 제네릭 유형 호출 및 인스턴스화코드에서 위 예시의 BOX 클래스를 참조하면, T에 Integer와 같은 구체적인 값을 정의하는 제네릭 타입 호출을 수행하여야 합니다.예) Box &amp;lt;Integer&amp;gt; integerBox;제네릭 타입 선언이 일반 메소드 선언과 유사하다고 생각 할수 있으나, 일수를 메서드에 전달하는 대신 타입 아규먼트(type-argument)를 Box 클래스에 전달합니다.타입 파라미터(Type Parameter)와 타입 아규먼트(type-Argument)의 이해많은 개발자들이 타입 파라미터와 타입 아규먼드를 용어를 같은 의미로 사용하지만 두 용어는 동일하지 않습니다. 타입 파라미터(Type Parameter)는 형식이 확정되지 않은 형태를 말하며, 타입 아규먼트(type-Argument)은 형식이 정의된 형태를 말합니다. 예를들면 foo&amp;lt;T&amp;gt;의 T는 타입 파라미터라고 하며, foo&amp;lt;String&amp;gt;의 String은 타입 아규먼트(type-Argument)라고 합니다. 변수 내용 Type parameter 단순한 자리 표시자 예)”&amp;lt;T&amp;gt;” Type argument 선언시 넘겨주는 타입 파라미터 예), “&amp;lt;String&amp;gt;” Parameterized type (generic) 규격화된 타입 파라미터 예) “List&amp;lt;T&amp;gt;” Parameterized type (concrete) 선언된 타입의 규격화된 파라미터 예) “List&amp;lt;String&amp;gt;” 참고: https://stackoverflow.com/questions/12551674/what-is-meant-by-parameterized-type다른 변수 선언과 마찬가지로 위 코드는 실제로 새 Box 객체를 생성하지 않습니다. 단순히 integerBox 가 “Integer 타입의 Box”에 대한 참조를 보유 할 것이라고 선언하는 것입니다. 이는 Box &amp;lt;Integer&amp;gt; 를 읽는 방법입니다.제네릭 유형의 호출을 일반적으로 매개 변수화된 타입(parameterized type)이라고 합니다.이 클래스를 인스턴스화하려면 평소처럼 new 키워드를 사용 하되 클래스 이름과 괄호 사이에 &amp;lt;Integer&amp;gt; 를 넣으면 됩니다.예) Box &amp;lt;Integer&amp;gt; integerBox = new Box &amp;lt;Integer&amp;gt;();다이아몬드Java SE 7 이상에서는 컴파일러가 문맥에서 타입 아규먼트(type-Argument)를 결정하거나 추론 할 수 있다면 한 일반 클래스의 생성자를 호출하는 데 필요한 타입 아규먼트를 빈 타입 아규먼트 (&amp;lt;&amp;gt;) 세트로 바꿀 수 있습니다. 이 꺾쇠 괄호 쌍 &amp;lt;&amp;gt;은 비공식적으로 다이아몬드 라고 합니다 . 예를 들어 다음 문을 사용하여 Box 의 인스턴스를 만들 수 있습니다 .예) Box integerBox = new Box&amp;lt;&amp;gt;();다중 타입 파라미터제네릭 클래스는 여러 타입 파라미터를 가질 수 있습니다public interface Pair&amp;lt;K,V&amp;gt; { public K getKey(); public V getValue();}public class OrderedPair&amp;lt;K,V&amp;gt; implements Pair&amp;lt;K,V&amp;gt; { private K key; private V value; public OrderedPair(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; }} 바이트코드public interface week14.Pair&amp;lt;K, V&amp;gt; { public abstract K getKey(); public abstract V getValue();}public class week14.OrderedPair&amp;lt;K, V&amp;gt; implements week14.Pair&amp;lt;K, V&amp;gt; { public week14.OrderedPair(K, V); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: aload_0 5: aload_1 6: putfield #2 // Field key:Ljava/lang/Object; 9: aload_0 10: aload_2 11: putfield #3 // Field value:Ljava/lang/Object; 14: return public K getKey(); Code: 0: aload_0 1: getfield #2 // Field key:Ljava/lang/Object; 4: areturn public V getValue(); Code: 0: aload_0 1: getfield #3 // Field value:Ljava/lang/Object; 4: areturn}위에서 언급한 내용처럼 다중의 타입으로 이용가능하며 아래와 같이 유연하게 사용가능합니다.public class TestMain { public static void main(String[] args) { OrderedPair&amp;lt;String, Integer&amp;gt; p1 = new OrderedPair&amp;lt;&amp;gt;(&quot;Even&quot;,8); OrderedPair&amp;lt;String, String&amp;gt; p2 = new OrderedPair&amp;lt;&amp;gt;(&quot;Hello&quot;,&quot;world&quot;); }} 바이트코드public class week14.TestMain { public week14.TestMain(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class week14/OrderedPair 3: dup 4: ldc #3 // String Even 6: bipush 8 8: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 11: invokespecial #5 // Method week14/OrderedPair.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/Object;Ljava/lang/Object;)V 14: astore_1 15: new #2 // class week14/OrderedPair 18: dup 19: ldc #6 // String Hello 21: ldc #7 // String world 23: invokespecial #5 // Method week14/OrderedPair.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/Object;Ljava/lang/Object;)V 26: astore_2 27: return}new OrderedPair &amp;lt;String, Integer&amp;gt; 코드는 K 를 String으로 , V 를 Integer 로 인스턴스화 합니다. 따라서 OrderedPair 생성자 의 매개 변수 유형은 각각 String 및 Integer 입니다. 오토 박싱으로 인해 String 및 int를 클래스에 전달하는 것도 가능합니다.또한 매개 변수화된 타입을 이용하는 것 또한 가능합니다.예) OrderedPair&amp;lt;String, Box&amp;lt;Integer» p = new OrderedPair&amp;lt;&amp;gt;(“primes”, new Box&amp;lt;Integer&amp;gt;(…));원시타입원시타입(raw type)은 타입 어규먼트가 없는 제네릭 클래스를 말합니다. 위에서 이용한 GenericBox&amp;lt;T&amp;gt;를 예로 들어보겠습니다.GenericBox raw = new GenericBox();위 코드와 같이 타입 아규먼트를 사용하지 않은 제네릭 인스턴스를 말하며, 따라서 위 코드의 GenericBox은 GenericBox&amp;lt;T&amp;gt;의 원시 타입입니다. (다만, 제네릭이 아닌 클래스 또는 인터페이스의 경우는 원시타입이라고 하지 않습니다.)원시타입의 존재 이유는 JDK 5.0 이전에 생성된 레거지 코드에는 원시타입의 형태로 표시 됩니다. 때문에 기본적으로 원시 타입을 이용하면, 제네릭 생성 이전에 구현한 상태로 작동합니다. 또한 이전 버전과의 호환성을 위해 매개 변수화된 타입을 원시 타입에 할당 할수 있습니다.GenericBox raw = new GenericBox();GenericBox&amp;lt;String&amp;gt; raw2 = raw;그러나 매개 변수화된 타입에 원시 타입을 할당시 경고가 표시됩니다.GenericBox raw = new GenericBox();GenericBox&amp;lt;String&amp;gt; raw2 = raw;이러한 경고는 런타임시 에러 발생의 가능성을 경고하는 것입니다.따라서, 원시 타입을 사용하지 않아야합니다.제네릭 주요 개념 (바운디드 타입, 와일드 카드)바운디드 타입제네리 타입에서 타입 아규먼트로 사용할 수 있는 타입을 제한하려는 경우가 있을 수 있습니다. 예를 들어 숫자에 대해 작동하는 메서드는 Number또는 해당 하위 클래스의 인스턴스 만 허용하려고 할 수 있습니다. 이것이 바운디드 타입(Bounded Type Parameters)의 용도입니다.바운디드 타입을 선언하려면 타입 파라미터의 이름, extends키워드, 상위 경계(upper bound)를 입력하면됩니다. 여기서 extends는 “상속” 또는 “구현”등의 일반적인 의미로 사용됩니다.public class Box&amp;lt;T&amp;gt; { private T t; public void set(T t) { this.t = t; } public T get() { return t; } public &amp;lt;U extends Number&amp;gt; void inspect(U u){ System.out.println(&quot;T: &quot; + t.getClass().getName()); System.out.println(&quot;U: &quot; + u.getClass().getName()); } public static void main(String[] args) { Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;(); integerBox.set(new Integer(10)); // 오토박싱이 일어납니다. integerBox.inspect(&quot;some text&quot;); // 에러 : 문자열입니다. }} 바이트코드public class week14.Box&amp;lt;T&amp;gt; { public week14.Box(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void set(T); Code: 0: aload_0 1: aload_1 2: putfield #2 // Field t:Ljava/lang/Object; 5: return public T get(); Code: 0: aload_0 1: getfield #2 // Field t:Ljava/lang/Object; 4: areturn public &amp;lt;U extends java.lang.Number&amp;gt; void inspect(U); Code: 0: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: getfield #2 // Field t:Ljava/lang/Object; 7: invokevirtual #4 // Method java/lang/Object.getClass:()Ljava/lang/Class; 10: invokevirtual #5 // Method java/lang/Class.getName:()Ljava/lang/String; 13: invokedynamic #6, 0 // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String; 18: invokevirtual #7 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 21: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 24: aload_1 25: invokevirtual #4 // Method java/lang/Object.getClass:()Ljava/lang/Class; 28: invokevirtual #5 // Method java/lang/Class.getName:()Ljava/lang/String; 31: invokedynamic #8, 0 // InvokeDynamic #1:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String; 36: invokevirtual #7 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: return public static void main(java.lang.String[]); Code: 0: new #9 // class week14/Box 3: dup 4: invokespecial #10 // Method &quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: aload_1 9: new #11 // class java/lang/Integer 12: dup 13: bipush 10 15: invokespecial #12 // Method java/lang/Integer.&quot;&amp;lt;init&amp;gt;&quot;:(I)V 18: invokevirtual #13 // Method set:(Ljava/lang/Object;)V 21: return}위 코드의 main 메소드에서는 범위를 넘어가는 integerBox.inspect(“some text”)코드에 대해 오류를 발생합니다.같은 방식으로 클래스에도 적용이 가능합니다.다중 경계(Multiple Bounds)타입 파라미터는 단일 뿐아니라 다중 경계도 정의 할수 있습니다.경계 중 하나가 클래스 인 경우 먼저 지정해야 하며,클래스는 하나만 인터페이스는 여러개를 사용 가능합니다.(확인필요)예) &amp;lt;T extends B1 &amp;amp; B2 &amp;amp; B3&amp;gt;위 예문에서 B2와 B3는 클래스일수 없으며, 클래스일 경우, 컴파일 에러가 발생합니다.바운디드 타입 알고리즘의 핵심아래의 예제는 바운디드 타입이 이용하는 핵심 알고리즘 중 하나입니다.아래의 코드는 지정된 요소인 elem보다 큰 배열 요소 수를 계산하는 솔루션 입니다.public static &amp;lt;T&amp;gt; int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e &amp;gt; elem) // 컴파일에러 ++count; return count;}위 코드는 구현은 간단하지만 비교연산자(&amp;gt;)가 원시타입에만 적용되기 때문에, 컴파일이 불가능 합니다. 때문에 Comparable &amp;lt;T&amp;gt; 인터페이스로 제한되는 형식 매개 변수를 사용하도록 변경합니다.public interface Comparable&amp;lt;T&amp;gt; { public int compareTo(T o); public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e.compareTo(elem) &amp;gt; 0) ++count; return count; }}와일드 카드제네릭 코드에서 와일드 카드라고하는 물음표 (?) 는 알 수없는 유형을 나타냅니다. 와일드 카드는 다양한 상황에서 사용할 수 있습니다. 매개 변수, 필드 또는 지역 변수의 타입 때때로 리턴 타입으로 사용됩니다. 와일드 카드는 제네릭 메서드 호출, 제네릭 클래스 인스턴스 생성 또는 수퍼 타입의 유형 인수로 사용되지는 않습니다.상한 바운디드(Upper Bounded) 와일드 카드상한 와일드 카드를 사용하여 변수에 대한 제한을 완화 할 수 있습니다. 예를 들어 List&amp;lt;Integer&amp;gt;, List&amp;lt;Double&amp;gt;,List&amp;lt;Number&amp;gt;를 동시에 사용하고 싶을때 이 방법을 사용합니다.예) public static void process(List&amp;lt;? extends Foo&amp;gt; list) { /* … */ }무제한(Unbounded) 와일드 카드 Object 클래스 에서 제공하는 기능을 사용하여 구현할 수있는 메서드를 작성하는 경우 . 코드가 타입 파라미터에 의존하지 않는 제네릭 클래스의 메서드를 사용하는 경우. 예를 들어, List.size 또는 List.clear 입니다.예) public static void process(List&amp;lt;?&amp;gt; list) { /* … */ }하한 바운디드(lower bounded) 와일드 카드하위 경계와일드카드는 알 수 없는 타입을 특정 타입 또는 해당 타입의 부모 타입으로 제한합니다.예) public static void process(List&amp;lt;? super Foo&amp;gt; list) { /* … */ }제네릭,상속,서브타입일반적으로 부모 타입의 변수에는 자식 타입의 인스턴스 할당이 가능합니다Object someObject = new Object();Integer someInteger = new Integer(10);someObject = someInteger; // 가능이러한 형태는 제네릭에서도 가능합니다.public class Box&amp;lt;T&amp;gt; { public void add(T num) { }}public class TestMain { public static void main(String[] args) { Box&amp;lt;Number&amp;gt; box = new Box&amp;lt;Number&amp;gt;(); box.add(new Integer(1)); //가능 box.add(new Double(1.0)); //가능 }}그렇다면 메소드 하나를 추가해 봅니다public class Box&amp;lt;T&amp;gt; { public void add(T num) { } public void boxTest(Box&amp;lt;Number&amp;gt; n){ }}boxTest 메소드의 타입 파라미터 number입니다. 우리가 이전 예제와 같이 number의 하위 타입인 Integer나 Double 가능하다고 생각합니다.하지만 직접적인 Box&amp;lt;number&amp;gt;의 하위타입 예를들어 Box&amp;lt;Integer&amp;gt;라는 타입이 아니기 때문에 사용은 불가능 합니다.public class TestMain { public static void main(String[] args) { Box&amp;lt;Number&amp;gt; box = new Box&amp;lt;Number&amp;gt;(); box.add(new Integer(1)); box.add(new Double(1.0)); box.boxTest(new Integer(1)); //컴파일 에러 box.boxTest(new Double(1)); //컴파일 에러 }}오라클 튜토리얼제네릭과 서브타이핑일반 클래스 또는 인터페이스를 확장(extends)하거나 구현(implements)하여 하위 유형을 지정할 수 있습니다. 클래스 또는 인터페이스의 타입 파라미터와 다른 클래스의 타입 파라미터 간의 관계는 extends 및 implements 절에 의해 결정됩니다.Collections 클래스를 예로 들면 ArrayList &amp;lt;E&amp;gt; 는 List &amp;lt;E&amp;gt;를 구현 하고 List &amp;lt;E&amp;gt;는 Collection &amp;lt;E&amp;gt;을 확장 합니다. 따라서 ArrayList &amp;lt;String&amp;gt; 은 Collection &amp;lt;String&amp;gt; 의 하위 유형 인 List &amp;lt;String&amp;gt; 의 하위 타입입니다. 타입 아규먼트를 변경하지 않는 한 타입간에 하위 타입 관계가 유지됩니다.오라클 튜토리얼PayloadList라는 인터페이스를 정의할 때 P라는 generic 타입을 메서드의 파라메터로 사용한다고했을때, 아래 코드와 같을 것입니다.interface PayloadList&amp;lt;E,P&amp;gt; extends List&amp;lt;E&amp;gt; { void setPayload(int index, P val); ...}List&amp;lt;String&amp;gt;의 서브타입이면서 PayloadList가 타입 아규먼트로 다양하게 변경 할수 있습니다. PayloadList&amp;lt;String,String&amp;gt; PayloadList&amp;lt;String,Integer&amp;gt; PayloadList&amp;lt;String,Exception&amp;gt;오라클 튜토리얼와일드 카드와 서브타이핑위 내용처럼 상속과 제네릭 관의 연관관계는 무관하지만 와일드 카드를 사용함에 따라 그 관계를 생성 할수 있습니다.Integer a = new Integer(0);Number b = a;List&amp;lt;Integer&amp;gt; c = new ArrayList&amp;lt;&amp;gt;();List&amp;lt;Number&amp;gt; d = c; //컴파일 에러위 코드에서 a,b는 정상적으로 작동하지만, c,d는 정상적으로 작동하지 않습니다. 이는 제네릭의 경우 c와 d는 부모 자식 관계가 아니기 때문입니다.공통의 부모는 List&amp;lt;?&amp;gt;입니다오라클 튜토리얼하지만, integer는 number의 하위 타입입니다. 때문에 상한 와일드카드를 이용하여 이 문제를 해결 할수 있습니다.public class TestMain { public static void main(String[] args) { Integer a = new Integer(0); Number b = a; List&amp;lt;? extends Integer&amp;gt; c = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;? extends Number&amp;gt; d = c; // 가능. List&amp;lt;? extends Integer&amp;gt; 는 List&amp;lt;? extends Number&amp;gt; 하위 타입입니다. }}전체 구조는 아래와 같습니다.오라클 튜토리얼와일드 카드 사용지침와일드 카드 사용시 혼한을 가중하는 부분은 상한과 하한을 어떻게 정하는가 입니다.때문에 오라클 문서에서는 몇가지 가이드 라인을 정하고 있습니다. in 변수 : in 변수는 데이터를 제공하는 변수를 말합니다. capy(src , dest) 메소드를 상상해 보면, src는 데이터를 제공하는 in 변수 입니다. out 변수 : out 변수는 데이터의 사용처에 대한 변수 입니다. capy(src , dest) 메소드를 상상해 보면, dest는 데이터를 접근을 허용하는 out 변수 입니다. 위 내용을 기반하여 가이드가 제공되고 있습니다. “in” 변수는 extends 키워드를 사용하여 상한 와일드 카드로 정의합니다. “out”변수는 super 키워드를 사용하여 하한 와일드 카드로 정의합니다. Object 클래스에 정의 된 메서드를 사용하여 “in”변수에 액세스 할 수있는 경우 제한되지 않은 와일드 카드를 사용하십시오. 코드가 “in”및 “out”변수로 변수에 액세스해야하는 경우 와일드 카드를 사용하지 마십시오.자세한 내용은 링크를 참고 주십시오제네릭 메소드 만들기제네릭 메소드제네릭 메서드는 자신만의 타입 파라미터를 이용하는 메서드입니다. 일반적인 제네릭 형식을 선언하는 것과 비슷하지만 타입 파라미터의 범위는 선언 된 메서드로 제한됩니다. 제네릭 클래스 생성자뿐만 아니라 정적 및 비 정적 제네릭 메서드에도 사용가능합니다.제네릭 메서드의 구문에는 메서드의 리턴 타입 앞에 꺾쇠 괄호 넣어 타입 파라미터 목록을 표시합니다. 정적 제네릭 메서드의 경우 타입 파라미터는 메서드의 리턴 타입 앞에 나타나야합니다.public class Util { public static &amp;lt;K, V&amp;gt; boolean compare(Pair&amp;lt;K, V&amp;gt; p1, Pair&amp;lt;K, V&amp;gt; p2) { return p1.getKey().equals(p2.getKey()) &amp;amp;&amp;amp; p1.getValue().equals(p2.getValue()); }} 바이트코드public class week14.Util { public week14.Util(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static &amp;lt;K, V&amp;gt; boolean compare(week14.Pair&amp;lt;K, V&amp;gt;, week14.Pair&amp;lt;K, V&amp;gt;); Code: 0: aload_0 1: invokeinterface #2, 1 // InterfaceMethod week14/Pair.getKey:()Ljava/lang/Object; 6: aload_1 7: invokeinterface #2, 1 // InterfaceMethod week14/Pair.getKey:()Ljava/lang/Object; 12: invokevirtual #3 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z 15: ifeq 40 18: aload_0 19: invokeinterface #4, 1 // InterfaceMethod week14/Pair.getValue:()Ljava/lang/Object; 24: aload_1 25: invokeinterface #4, 1 // InterfaceMethod week14/Pair.getValue:()Ljava/lang/Object; 30: invokevirtual #3 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z 33: ifeq 40 36: iconst_1 37: goto 41 40: iconst_0 41: ireturn}위 메서드는 아래와 같이 사용가능합니다.public class TestMain { public static void main(String[] args) { Pair&amp;lt;Integer,String&amp;gt; p1 = new OrderedPair&amp;lt;&amp;gt;(1,&quot;apple&quot;); Pair&amp;lt;Integer,String&amp;gt; p2 = new OrderedPair&amp;lt;&amp;gt;(2,&quot;berry&quot;); boolean isSame = Util.&amp;lt;Integer,String&amp;gt;compare(p1,p2); boolean isSame2 = Util.compare(p1,p2); }}Util.&amp;lt;Integer,String&amp;gt;compare(p1,p2)과 같이 명시적으로도 사용할 수 있으나, 컴파일러는 타입 추론은 통해서 Util.compare(p1,p2)와 같은 형태로도 이용 가능합니다.타입 추론에 관한 내용은 링크로 대체합니다.유형삭제(Erasure)Java 언어에 Generics가 도입되어 컴파일타임에 보다 엄격한 유형 검사를 제공하고 일반 프로그래밍을 지원합니다. 제네릭을 구현하기 위해 Java 컴파일러는 다음에 유형 삭제를 적용합니다. 제네릭 타입의 모든 타입 파라미터를 해당 범위 또는 타입 파라미터가 제한되지 않은 경우 Object로 바꿉니다. 따라서 생성 된 바이트 코드에는 일반 클래스, 인터페이스 및 메서드 만 포함됩니다. 유형 안전성을 유지하기 위해 필요한 경우 타입 캐스트를 삽입합니다. 확장 된 제네릭 타입에서 다형성을 유지하는 브리지 메서드를 생성합니다.유형 삭제는 매개 변수화 된 유형에 대해 새 클래스가 생성되지 않도록합니다. 결과적으로 제네릭은 런타임 오버 헤드를 발생시키지 않습니다.일반 유형삭제유형 삭제 프로세스는 Java 컴파일러는 모든 타입 파라미터를 지우고 타입 파라미터가 바인드 된 경우 각각을 첫 번째 바인드로 대체하고, 타입 파라미터가 바인드 되지 않은 경우 Object로 대체합니다.public class Node&amp;lt;T&amp;gt; { private T data; private Node&amp;lt;T&amp;gt; next; public Node(T data, Node&amp;lt;T&amp;gt; next) { this.data = data; this.next = next; } public T getData() { return data; }} 바이트코드public class week14.Node&amp;lt;T&amp;gt; { public week14.Node(T, week14.Node&amp;lt;T&amp;gt;); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: aload_0 5: aload_1 6: putfield #7 // Field data:Ljava/lang/Object; 9: aload_0 10: aload_2 11: putfield #13 // Field next:Lweek14/Node; 14: return public T getData(); Code: 0: aload_0 1: getfield #7 // Field data:Ljava/lang/Object; 4: areturn}실제로 Object로 변경된 것을 코드에서 확인 할수 있습니다. 다음은 일반 Node 클래스는 제한된 타입 파라미터를 사용합니다.Java 컴파일러는 바인딩 된 타입 파라미터 T 를 첫 번째 바인딩 된 클래스 인 Comparable로 대체합니다.public class Node&amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; { private T data; private Node&amp;lt;T&amp;gt; next; public Node(T data, Node&amp;lt;T&amp;gt; next) { this.data = data; this.next = next; } public T getData() { return data; }} 바이트코드public class week14.Node&amp;lt;T extends java.lang.Comparable&amp;lt;T&amp;gt;&amp;gt; { public week14.Node(T, week14.Node&amp;lt;T&amp;gt;); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: aload_0 5: aload_1 6: putfield #7 // Field data:Ljava/lang/Comparable; 9: aload_0 10: aload_2 11: putfield #13 // Field next:Lweek14/Node; 14: return public T getData(); Code: 0: aload_0 1: getfield #7 // Field data:Ljava/lang/Comparable; 4: areturn}이러한 바이트코드 변경은 제네릭 메소드에서도 마찬가지로 적용됩니다.유형 삭제의 영향과 브리지 메소드때로는 유형 삭제로 인해 예상치 못한 상황이 발생할 수 있습니다.public class Node&amp;lt;T&amp;gt; { public T data; public Node(T data) { this.data = data; } public void setData(T data) { System.out.println(&quot;Node.setData&quot;); this.data = data; }}public class MyNode extends Node&amp;lt;Integer&amp;gt; { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(&quot;MyNode.setData&quot;); super.setData(data); }}public static void main(String[] args) { MyNode mn = new MyNode(5); Node n = mn; // 원시 타입 -컴파일러는 확인 경고를 표시한다. n.setData(&quot;Hello&quot;); // 에러 : ClassCastException } 바이트코드public class week14.TestMain { public week14.TestMain(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #7 // class week14/MyNode 3: dup 4: iconst_5 5: invokestatic #9 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 8: invokespecial #15 // Method week14/MyNode.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/Integer;)V 11: astore_1 12: aload_1 13: astore_2 14: aload_2 15: ldc #18 // String Hello 17: invokevirtual #20 // Method week14/Node.setData:(Ljava/lang/Object;)V 20: return}위 코드는 아래와 같은 순서로 진행됩니다. n.setData ( “Hello”); MyNode 클래스의 객체에서 부모 클래스의 setData(T) 메서드를 실행 시킵니다. setData(T)는 본문에서 n 이 참조하는 객체의 데이터 필드의 타입은 String에 할당됩니다 . 참조를 통해 mn의 객체의 데이터 필드에 액세스 가능하며, 해당 데이터 필드는 Integer로 할당된다.(Mynode의 경우, Node&amp;lt;Integer&amp;gt;를 상속받았기 때문입니다.) String 을 Integer 에 할당하려고 하면 Java 컴파일러에 의해 할당에 삽입 된 캐스트에서 ClassCastException이 발생합니다 .브릿지 메소드매개 변수화된 클래스를 확장하거나 매개 변수화된 인터페이스를 구현하는 클래스 또는 인터페이스를 컴파일 할 때, 컴파일러는 유형 삭제 프로세스의 일부로 브릿지 메서드 라는 합성 메서드를 생성할 때도 있습니다.일반적으로 브리지 메서드에 대해 걱정할 필요가 없지만 스택 추적시 당황 할 수 있습니다.위의 Node 클래스가 유형삭제가 됬을 경우, 아래와 같은 코드로 변경됩니다.public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) { System.out.println(&quot;Node.setData&quot;); this.data = data; }}public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(&quot;MyNode.setData&quot;); super.setData(data); }}public static void main(String[] args) { MyNode mn = new MyNode(5); Node n = mn; // 원시 타입 -컴파일러는 확인 경고를 표시한다. n.setData(&quot;Hello&quot;); // 에러 미발생 System.out.println(mn.data); // Hello } 바이트코드public class week14.TestMain { public week14.TestMain(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #7 // class week14/MyNode 3: dup 4: iconst_5 5: invokestatic #9 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 8: invokespecial #15 // Method week14/MyNode.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/Integer;)V 11: astore_1 12: aload_1 13: astore_2 14: aload_2 15: ldc #18 // String Hello 17: invokevirtual #20 // Method week14/Node.setData:(Ljava/lang/Object;)V 20: getstatic #26 // Field java/lang/System.out:Ljava/io/PrintStream; 23: aload_1 24: getfield #32 // Field week14/MyNode.data:Ljava/lang/Object; 27: invokevirtual #36 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V 30: return}유형 삭제 후 메서드 시그니처가 일치하지 않습니다. (Node의 setData는 파라미터로 object를 MyNode는 setData의 파라미터로 Integer를 가진다)따라서 MyNode setData 메서드는 Node setData 메서드를 오버라이딩하지 않습니다.이 문제를 해결하고 유형 삭제 후 일반 유형 의 다형성 을 보존하기 위해 Java 컴파일러는 하위 유형이 예상대로 작동하는지 확인하는 브릿지 메소드를 생성합니다.class MyNode extends Node { // 컴파일러에 의해 생성된 브릿지 메소드 public void setData(Object data) { setData((Integer) data); } public void setData(Integer data) { System.out.println(&quot;MyNode.setData&quot;); super.setData(data); } // ...}수정 불가한 타입수정불가한 타입에 관해서는 링크로 대체합니다출처https://docs.oracle.com/javase/tutorial/essential/io/streams.html자바의 정석 3판" }, { "title": "컴퓨터개론 13", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A013/", "categories": "CA", "tags": "", "date": "2021-02-23 00:00:00 +0900", "snippet": "명령어의 컴퓨터 내부표현 명령의 해석방법 명령어도 높고 낮은 전기신호의 연속이므로 숫자로 표현하는 것이 가능 레지스터가 명령어에서 참조 되기 때문에 레지스터 이름을 숫자로 매핑하는 규칙이 존재 $s0 ~ $s7 == 16 ~ 23 $t0 ~ $t7 == 8 ~ 15 어셈블리어의 기계어 변환 add $t0, $s1 $s2 명령어의 각 부분을 필드(field)라고 함 위와 같은 형식을 명령어 형식이라고 함 기계어는 보통 16진수를 사용하여 표현함 op : 명령어가 실행할 연산의 종류로서 연산자(opcode)라고 한다 rs : 첫 번째 근원지(Source) operand 레지스터 (6bit) rt : 두 번째 근원지 operand 레지스터 (5bit) rd : 연산결과가 기억되는 목적지(Destination) 레지스터 shamt : 자리이동(shift)량 shift명령어를 배우기 전까지 0으로 사용 (5bit) funct : op 코드에 표시된 연산의 구체적인 종류 지정 address : 16bit 기계어 코드표 |instruction|format|op|rs|rt|rd|shamt|funct|address| |:–|:–|:–|:–|:–|:–|:–|:–|:–| |add|R|0|reg|reg|reg|0|32|n/a| |sub|R|0|reg|reg|reg|0|34|n/a| |addi|I|8|reg|reg|n/a|n/a|n/a|constant| |lw|I|35|reg|reg|n/a|n/a|n/a|address| |sw|I|43|reg|reg|n/a|n/a|n/a|address| 명령어 타입 R 타입 : 오른쪽 절반 필드가 3개일 경우 I 타입 : 오른쪽 절반 필드가 1개일 경우 address는 16비트 주소 명령어 형식이 여러가지가 되면 복잡해지지만 유사하게 설계하므로써 복잡도를 낮춤 Q) A[300] = h + A[300] A) lw $t0 , 1200($s3) add $t0, $s3, $t0 sw $t0, 1200($s3) " }, { "title": "컴퓨터개론 12", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A012/", "categories": "CA", "tags": "", "date": "2021-02-23 00:00:00 +0900", "snippet": "부호 컴퓨터의 숫자표현 컴퓨터는 높고 낮음만이 존재하는 디지털 신소(클럽 펄스)형태의 2진 숫자체계를 사용 진법을 나타내는 기본수를 기수라고 함 123(기수 10), 1101(기수 2) 모든 정보는 비트(bit)로 구성됨 이진수의 십진수 변환 MIPS WORD 길이는 4byte(32bit)이므로 최대 2^32 -1 까지 표현 가능 Q) 2진수 1000 1100을 10진수로 변환하시오 A) 2^7 + 3^2 + 2^2 = 128 + 8 + 4 = 140 Q) 10진수 67을 2진수로 변환하시오 A) 67 = 2^6 + 2^1 + 2^0 = 1000011 음수의 표현 A &amp;gt; B 일때, A - B은 음수 컴퓨터는 양수와 음수를 전부 사용함 부호를 표현하기 위하여 2의 보수를 사용함 보수(역 부호화) 양수에 대한 음의 값 1의 보수 : NOT(전체 비트) 2의 보수 : 1의 보수 + 1 (1의 보수는 0이 2개 존재) 2의 보수를 취하며 MSB가 부호를 나타냄(부호 비트) 0일 경우 양수 1일 경우 음수 범위 : -2,147,483,648 ~ 2,147,483,647 Q) 8bit10(10)을 역부호화 하고 다시 8bit - 10 (10)을 역부호화 하시오 A) 10(10) = 0000 1010(2) 10(10)의 1의 보수 + 1 = 1111 0110(2) -10(10) = 1111 0110 -10(10)의 2의 보수 = 0000 1010(2) 오버 플로우 덧/뺄셈 연산결과가 처리할 수 있는 최대 비트수를 초과하였을 때 발생 더하거나 빼는 두수의 부호가 동일하며 결과가 반대부호일때 " }, { "title": "자바스터디 13주차", "url": "/posts/whiteship-study-13week/", "categories": "study", "tags": "", "date": "2021-02-17 00:00:00 +0900", "snippet": "GOAL자바의 Input과 Ontput에 대해 학습하세요.학습할 것 (필수) 스트림 (Stream) / 버퍼 (Buffer) / 채널 (Channel) 기반의 I/O InputStream과 OutputStream Byte와 Character 스트림 표준 스트림 (System.in, System.out, System.err) 파일 읽고 쓰기 마감일시스트림 (Stream) / 버퍼 (Buffer) / 채널 (Channel) 기반의 I/O스트림스트림은 일련의 데이터입니다. 단순히 데이터 전달하는 모델이라고 볼수 있습니다.스트림 IO (Stream)스트림IO는 입력 또는 출력 가능합니다. 스트림 기반으로 입출력이 이루어 지기에 스트림 IO 로 표현합니다.스트림에는 디스크 파일, 장치, 기타 프로그램 및 메모리 배열을 포함하여 다양한 종류의 소스가 대상이 될수 있습니다.또한 내부적으로 작동하는 방식에 관계없이 모든 스트림은 이를 사용하는 프로그램에 동일한 단순 모델을 제공합니다.입력 스트림 을 사용하여 한 번에 한 항목 씩 소스에서 데이터를 읽습니다.출처 : oracle tutorials출력 스트림 을 사용하여 한 번에 한 항목 씩 대상에 데이터를 씁니다.출처 : oracle tutorials버퍼버퍼라는 공간을 만들어 일정량이 채워지면, 버퍼만큼에 데이터를 전달합니다.버퍼링 된 IO(Buffered stream)기존의 스트림 기반의 경우 오버해드 비용이 많이 발생합니다. 즉, 각 읽기 또는 쓰기 요청은 기본 OS에서 직접 처리되며, 이러한 각 요청은 디스크 액세스, 네트워크 활동 또는 상대적으로 비용이 많이 드는 다른 작업을 수행하기 때문에 프로그램의 효율성이 훨씬 떨어질 수 있습니다.이러한 종류의 오버 헤드를 줄이기 위해 버퍼링 된 IO 스트림을 지원합니다. 버퍼 된 입력 스트림 은 버퍼 로 알려진 메모리 영역에서 데이터를 읽습니다. 기본 입력 API는 버퍼가 비어있을 때만 호출 됩니다. 마찬가지로 버퍼링 된 출력 스트림 은 버퍼에 데이터를 쓰고 기본 출력 API는 버퍼가 가득 찬 경우에만 호출 됩니다.버퍼링 된 스트림 플러시버퍼가 채워질 때까지 기다리지 않고 중요한 지점에서 버퍼링된 스트림을 실행할 수 있으며. 이를 버퍼 플러시라고 합니다.일부 버퍼링 된 출력 클래스 는 선택적 생성자 인수로 지정된 autoflush를 지원 합니다. 자동 플러시가 활성화되면 특정 키 이벤트로 인해 버퍼가 플러시됩니다. 스트림을 수동으로 플러시하려면 해당 flush메서드를 호출하면 됩니다.채널스트림 방식에 IO는 BLOCKING방식을 사용하고 있습니다. 이는 커널의 상태에 따라 많은 오버해드가 발생할 수 있습니다.때문에 나온 NIO(Non-blocking-IO)방식을 지원하는 방법입니다. 채널은 IO를 지원하는 통로를 만들어 줍니다.때문에 스트림 IO와 같이 매번 스레드를 생성할 필요가 없으며, 더이상 처리 완료시 까지 기다릴 필요가 없습니다.block IOnon block IO채널 기반의 IO스트림 IO에서는 스레드 마다 IO를 발생시키지 때문에 대역폭이 정해져 있는 네트워크의 경우, 정상적인 사용이 불가하고 메인쓰레드가 작업처리시 까지 중단 될수 있습니다.때문에 2002년 New IO라는 이름의 채널 기반의 새로운 입출력 시스템을 도입합니다. 채널과 스트림의 주요 차이점은 다음과 같습니다. 단방향 데이터 전송에 스트림을 사용할 수 있습니다. 채널은 양방향 데이터 전송 기능을 제공합니다.channelInputStream과 OutputStreamnutshellByte와 Character 스트림Byte 스트림스트림은 바이트단위로 데이터를 전송하며 입력 대상에 따라 다양하게 이용합니다.아래는 구현체 중 FIleStream을 이용한 예제 입니다.public class CopyByte { public static void main(String[] args) throws IOException { FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(&quot;xanadu.txt&quot;); out = new FileOutputStream(&quot;outagain.txt&quot;); int c; while ((c = in.read()) != -1) { out.write(c); } } finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } }} 바이트코드public class week13.CopyByte { public week13.CopyByte(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]) throws java.io.IOException; Code: 0: aconst_null 1: astore_1 2: aconst_null 3: astore_2 4: new #7 // class java/io/FileInputStream 7: dup 8: ldc #9 // String xanadu.txt 10: invokespecial #11 // Method java/io/FileInputStream.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V 13: astore_1 14: new #14 // class java/io/FileOutputStream 17: dup 18: ldc #16 // String outagain.txt 20: invokespecial #18 // Method java/io/FileOutputStream.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V 23: astore_2 24: aload_1 25: invokevirtual #19 // Method java/io/FileInputStream.read:()I 28: dup 29: istore_3 30: iconst_m1 31: if_icmpeq 42 34: aload_2 35: iload_3 36: invokevirtual #23 // Method java/io/FileOutputStream.write:(I)V 39: goto 24 42: aload_1 43: ifnull 50 46: aload_1 47: invokevirtual #27 // Method java/io/FileInputStream.close:()V 50: aload_2 51: ifnull 82 54: aload_2 55: invokevirtual #30 // Method java/io/FileOutputStream.close:()V 58: goto 82 61: astore 4 63: aload_1 64: ifnull 71 67: aload_1 68: invokevirtual #27 // Method java/io/FileInputStream.close:()V 71: aload_2 72: ifnull 79 75: aload_2 76: invokevirtual #30 // Method java/io/FileOutputStream.close:()V 79: aload 4 81: athrow 82: return Exception table: from to target type 4 42 61 any 61 63 61 any}내부적으로 아래 이미지와 같은 작업을 반복한다.스트림이 더 이상 필요하지 않을 때 항상 스트림을 닫는 것은 매우 중요 합니다. 오류가 발생하더라도 두 스트림이 모두 닫히도록 finally블록을 사용하는 것 또한 매우 중요 합니다. 이 방법은 심각한 리소스 누출을 방지하는 데 도움이됩니다. (java 7버전 이상인 경우, try-resource-with를 사용하는 것도 좋습니다.)위 예제 소스는 실제로는 사용하면 안되는 일종의 저수준 IO입니다. xanadu.txt문자 데이터가 포함되어 있으므로 가장 좋은 방법은 문자 스트림 을 사용 하는 것입니다.Character 스트림Java에서는 유니 코드 규칙을 사용하여 문자 값을 저장합니다. Character 스트림은 이 내부 형식을 로컬 문자 집합으로 자동으로 변환합니다. 스트림 클래스로 수행 된 입력 및 출력은 로컬 문자 집합과 자동으로 변환됩니다. 하지만 Character 스트림을 사용하는 프로그램은 프로그래머의 추가 노력없이 로컬 문자 집합에 자동으로 적용하고 인코딩(UTF-16)까지 해줍니다.public class CopyCharacters { public static void main(String[] args) throws IOException { FileReader inputStream = null; FileWriter outputStream = null; try { inputStream = new FileReader(&quot;xanadu.txt&quot;); outputStream = new FileWriter(&quot;characteroutput.txt&quot;); int c; while ((c = inputStream.read()) != -1) { outputStream.write(c); } } finally { if (inputStream != null) { inputStream.close(); } if (outputStream != null) { outputStream.close(); } } }} 바이트코드public class week13.CopyCharacters { public week13.CopyCharacters(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]) throws java.io.IOException; Code: 0: aconst_null 1: astore_1 2: aconst_null 3: astore_2 4: new #7 // class java/io/FileReader 7: dup 8: ldc #9 // String xanadu.txt 10: invokespecial #11 // Method java/io/FileReader.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V 13: astore_1 14: new #14 // class java/io/FileWriter 17: dup 18: ldc #16 // String characteroutput.txt 20: invokespecial #18 // Method java/io/FileWriter.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V 23: astore_2 24: aload_1 25: invokevirtual #19 // Method java/io/FileReader.read:()I 28: dup 29: istore_3 30: iconst_m1 31: if_icmpeq 42 34: aload_2 35: iload_3 36: invokevirtual #23 // Method java/io/FileWriter.write:(I)V 39: goto 24 42: aload_1 43: ifnull 50 46: aload_1 47: invokevirtual #27 // Method java/io/FileReader.close:()V 50: aload_2 51: ifnull 82 54: aload_2 55: invokevirtual #30 // Method java/io/FileWriter.close:()V 58: goto 82 61: astore 4 63: aload_1 64: ifnull 71 67: aload_1 68: invokevirtual #27 // Method java/io/FileReader.close:()V 71: aload_2 72: ifnull 79 75: aload_2 76: invokevirtual #30 // Method java/io/FileWriter.close:()V 79: aload 4 81: athrow 82: return Exception table: from to target type 4 42 61 any 61 63 61 any}CopyCharacters는 FileReader하고 FileWriter를 FileInputStream과 FileOutputStream 대신 사용합니다. Character 스트림은 바이트 스트림의 “래퍼”입니다. Character 스트림은 바이트 스트림을 사용하여 물리적 IO를 수행하고, 문자와 바이트 간의 변환을 처리합니다.요구 사항을 충족하는 사전 패키징 된 문자 스트림 클래스가 없을 땐 문자 스트림을 만들 수 있습니다.Character 스트림은 일반적으로 단일 문자보다 더 큰 단위로 발생합니다. 하나의 공통 단위는 줄이며 줄이란 끝에 종결자가있는 문자열입니다. 줄 종결자는 캐리지 리턴 / 줄 바꿈 시퀀스 ( “\\r\\n”), 단일 캐리지 리턴 ( “\\r”) 또는 단일 줄 바꿈 ( “\\n”) 입니다.public class CopyLines { public static void main(String[] args) throws IOException { BufferedReader inputStream = null; PrintWriter outputStream = null; try { inputStream = new BufferedReader(new FileReader(&quot;xanadu.txt&quot;)); outputStream = new PrintWriter(new FileWriter(&quot;characteroutput.txt&quot;)); String l; while ((l = inputStream.readLine()) != null) { outputStream.println(l); } } finally { if (inputStream != null) { inputStream.close(); } if (outputStream != null) { outputStream.close(); } } }} 바이트코드public class week13.CopyLines { public week13.CopyLines(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]) throws java.io.IOException; Code: 0: aconst_null 1: astore_1 2: aconst_null 3: astore_2 4: new #7 // class java/io/BufferedReader 7: dup 8: new #9 // class java/io/FileReader 11: dup 12: ldc #11 // String xanadu.txt 14: invokespecial #13 // Method java/io/FileReader.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V 17: invokespecial #16 // Method java/io/BufferedReader.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/io/Reader;)V 20: astore_1 21: new #19 // class java/io/PrintWriter 24: dup 25: new #21 // class java/io/FileWriter 28: dup 29: ldc #23 // String characteroutput.txt 31: invokespecial #25 // Method java/io/FileWriter.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V 34: invokespecial #26 // Method java/io/PrintWriter.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/io/Writer;)V 37: astore_2 38: iconst_0 39: istore_3 40: aload_1 41: invokevirtual #29 // Method java/io/BufferedReader.readLine:()Ljava/lang/String; 44: dup 45: astore 4 47: ifnull 84 50: iinc 3, 1 53: getstatic #33 // Field java/lang/System.out:Ljava/io/PrintStream; 56: ldc #39 // String %d 58: iconst_1 59: anewarray #2 // class java/lang/Object 62: dup 63: iconst_0 64: iload_3 65: invokestatic #41 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 68: aastore 69: invokestatic #47 // Method java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String; 72: invokevirtual #53 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 75: aload_2 76: aload 4 78: invokevirtual #58 // Method java/io/PrintWriter.println:(Ljava/lang/String;)V 81: goto 40 84: aload_1 85: ifnull 92 88: aload_1 89: invokevirtual #59 // Method java/io/BufferedReader.close:()V 92: aload_2 93: ifnull 124 96: aload_2 97: invokevirtual #62 // Method java/io/PrintWriter.close:()V 100: goto 124 103: astore 5 105: aload_1 106: ifnull 113 109: aload_1 110: invokevirtual #59 // Method java/io/BufferedReader.close:()V 113: aload_2 114: ifnull 121 117: aload_2 118: invokevirtual #62 // Method java/io/PrintWriter.close:()V 121: aload 5 123: athrow 124: return Exception table: from to target type 4 84 103 any 103 105 103 any}호출하면 라인 별로 호출하여 총 4번 while문이 반복됩니다.표준 스트림 (System.in, System.out, System.err)System.in, System.out 및 System.err은 Java VM이 시작될 때 Java 런타임에 의해 초기화되므로 스트림을 직접 인스턴스화 할 필요가 없습니다. (런타임에 스트림을 교환 할수 있습니다.)System.inSystem.in 일반적으로 콘솔 프로그램의 키보드 입력에 연결 되는 InputStream 입니다. 즉, 명령 줄에서 Java 응용 프로그램을 시작하고 CLI 콘솔 (또는 터미널)에 포커스가 있는 동안 키보드에 무언가를 입력하면 일반적으로 해당 Java 응용 프로그램 내부에서 System.in을 통해 키보드 입력을 읽을 수 있습니다. 그러나 System.in을 통해 읽을 수있는 것은 해당 Java 애플리케이션 (애플리케이션을 시작한 콘솔 / 터미널)에 대한 키보드 입력일뿐입니다. 다른 응용 프로그램의 키보드 입력은 System.in을 통해 읽을 수 없습니다. /** * The &quot;standard&quot; input stream. This stream is already * open and ready to supply input data. Typically this stream * corresponds to keyboard input or another input source specified by * the host environment or user. */ public static final InputStream in = null;System.outSystem.out문자를 쓸 수 있는 PrintStream 입니다. System.out은 일반적으로 CLI 콘솔 / 터미널에 기록한 데이터를 출력합니다. System.out은 실행 결과를 사용자에게 표시하는 방법으로 명령 줄 도구와 같은 콘솔 전용 프로그램에서 자주 사용됩니다. 이것은 또한 프로그램에서 디버그 문을 인쇄하는 데 자주 사용됩니다 (보통은 Log를 사용합니다). /** * The &quot;standard&quot; output stream. This stream is already * open and ready to accept output data. Typically this stream * corresponds to display output or another output destination * specified by the host environment or user. * &amp;lt;p&amp;gt; * For simple stand-alone Java applications, a typical way to write * a line of output data is: * &amp;lt;blockquote&amp;gt;&amp;lt;pre&amp;gt; * System.out.println(data) * &amp;lt;/pre&amp;gt;&amp;lt;/blockquote&amp;gt; * &amp;lt;p&amp;gt; * See the {@code println} methods in class {@code PrintStream}. * * @see java.io.PrintStream#println() * @see java.io.PrintStream#println(boolean) * @see java.io.PrintStream#println(char) * @see java.io.PrintStream#println(char[]) * @see java.io.PrintStream#println(double) * @see java.io.PrintStream#println(float) * @see java.io.PrintStream#println(int) * @see java.io.PrintStream#println(long) * @see java.io.PrintStream#println(java.lang.Object) * @see java.io.PrintStream#println(java.lang.String) */ public static final PrintStream out = null;System.errSystem.err입니다 PrintStream. 일반적으로 오류 텍스트를 출력하는 데만 사용된다는 점을 제외하면 System.out과 동일합니다. Eclipse와 같은 일부 프로그램은 출력을 System.err 빨간색 텍스트 로 표시하여 오류 텍스트임을 더 명확 하게 보여줍니다 . /** * The &quot;standard&quot; error output stream. This stream is already * open and ready to accept output data. * &amp;lt;p&amp;gt; * Typically this stream corresponds to display output or another * output destination specified by the host environment or user. By * convention, this output stream is used to display error messages * or other information that should come to the immediate attention * of a user even if the principal output stream, the value of the * variable {@code out}, has been redirected to a file or other * destination that is typically not continuously monitored. */ public static final PrintStream err = null;출처https://docs.oracle.com/javase/tutorial/essential/io/streams.htmlhttps://adrian0220.tistory.com/150?category=775742https://m.blog.naver.com/PostView.nhn?blogId=joebak&amp;amp;logNo=220063974083&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2Fhttps://www.javatpoint.com/java-nio-vs-input-output" }, { "title": "컴퓨터개론 11", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A011/", "categories": "CA", "tags": "", "date": "2021-02-16 00:00:00 +0900", "snippet": "피연산자 개요 연산자의 정의된 연산을 하기위하여 사용되는 레지스터나 상수, 레이블 ,메모리주소 등을 뜻하는 용어 레지스터는 데이터를 저장하는 장치중 속도가 가장 빠른 장소이므로 일부 레지스터만 사용가능. 더 적은 레지스터를 필요호 하는 순서로 연산을 함으로써 더 많은 피연산자를 레지스터에 할당할 수 있게 됨 피연산자 데이터 단위 데이터 단위 크기 word 32bit half word 16bit byte 8bit MIPS 명령어 및 레지스터는 32비트 로 구성되어있음 Q) C언어로 F = (G + H ) - (I + J);를 MIPS로 표현하시오 ($s0 = F, $s1 = G, $s2 = H, $s3 = I, $s4 = J) A) MISP add $t0, $s1, $s2 add $t1, $s3, $s4 sub $s0, $t0, $t1 메모리 피연산자 프로그래밍 언어에는 단순 변수가 아닌 자료형이 존재 (구조체, 배열) 레지스터는 소량의 데이터만 저장할 수 있기 때문에 나무지 데이터는 메모리(Heap, stack) 에 저장 후 주소에 접근하여 사용함 메모리와 레지스터간 데이터를 주고받는 명령어를 데이터 전송 명령어(Data Transfer Instruction)이라고 함 메모리 주소 접근(적재 명령어) 메모리는 주소가 인덱스의 역할을 하는 일차원 구조 메모리에서 레지스터로 데이터를 복사해 오는 데이터 전송 명령어를 적재(Load)라고 함 적재 명령어는 연산자(lw) + 값을 저장할 레지스터 + 메모리 접근에 사용할 상수 및 레지스터로 구성됨 4 ($s3) == [Memory address + 4 ] 출처: fastcampus Q) 다음 문장을 MIPS 명령어로 치환하라 g = h + A[1]; 출처: fastcampus g,h는 각각 $s1, $s2에 할당 배열 A의 시작주소는 $s3에 할당 A) MISP lw $t0, 4($s3) add $s1 , $s2 , $t0 데이터 전송명령어 상수 부분(4)를 offest 이라고 함 자료구조의 시작주소를 가르키는 레지스터($s)를 Base register 라고 함 MIPS에서 시작주소는 항상 4의 배수여야 한다(정렬 제약) 메모리 주소 접근(저장 명령어) 적재와 반대로 레지스터에서 메모리로 데이터를 보내는 명령을 저장(store)이라고 함 적재명령어와 같은 구조 연산자(sw) + 저장할 데이터를 가진 레지스터 + 메모리 주소 레지스터 및 상수(offset)의 조합 출처: fastcampus Q) 다음 MIPS 명령어를 C언어로 치환하라 lw $t0, 8($s3) add $t0, $s1, $t0 sw $t0, 32($s3) h는 $s1에 할당 배열 A의 시작주소는 $s3에 할당 출처: fastcampus A) C언어 A[8] = h + A[2] 배열 A의 인덱스 2에 접근하기 위해서는 2*4 = 8을 $s3에 더해야함 배열 A의 인덱스 2의 값을 임시레지스터 $t0에 저장 $s1에 저장된 h의 값과 add 연산 sw 연산을 이용하여 A[8]에 값을 저장하기 위해서는 베이스 레지스터에 8*4 = 32의 값을 더해야함 수치연산 프로그램 연산에서 레지스터가 아닌 상수를 사용하는 경우 상수 필드를 갖는 산술 명령어를 사용시 메모리에서 적재하는것 보다 효율적 사용빈도가 높으면 상수를 명령어에 포함하는 것이 좋음(Common case fast) 연산자 : addi(add와 같은 구조) Q) A[8] = h + 10을 MIPS로 치환하라 h는 $s1에 저장되어 있다 배열 A의 베이스 레지스터는 $s3이다 A) MISP addi $t0, $s1, 10 sw $t0, 32($s3) " }, { "title": "컴퓨터개론 10", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A010/", "categories": "CA", "tags": "", "date": "2021-02-16 00:00:00 +0900", "snippet": "하드웨어 연산 산술 연산 산술 연산은 사칙연산의 계산을 하는 것 컴퓨터는 레지스터와 ALU를 통해 산술연산을 수행 MIPS 산술 명령어 MIPS 산술명령어는 반드시 한종류의 연산만 지시 MIPS 산술명령어는 항상 변수 세개를 갖는 형식 피연산자가 반드시 3개인 이유 간단하게 설계하기 위해서는 규칙적인 것이 좋음 MIPS 산술 명령어를 통해 b,c,d,e,의 합을 a에 넣는 경우 add a,b,c # b와 c를 더하여 a에 저장 // a = b + c add a,a,d # a와 d를 더하여 a에 저장 // a = a + d add a,a,e # a와 e를 더하여 a에 저장 // a = a + e MIPS 레지스터 연산을 위하여 MIPS 명령어구조에서 제공하는 레지스터 $t 임시값 저장 레지스터는 컴퓨터가 사용하는 변수 $s 값 저장 출처: fastcampus 스택 프레임 함수가 실행될 때마다 자신만의 고유한 stack 영역을 가질수 있다 함수의 스택프레임 시작점은 fp가 가르킨다 함수의 종료시에 해제되고 리턴 주소로 복귀한다 출처: fastcampus 고급언어와의 관계 A = B + C; D = A - E; A~E 는 $s1~$s5에 저장되어있다고 가정 add $s1, $s2, $s3 add $s4, $s1, $s5 " }, { "title": "컴퓨터개론 09", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A009/", "categories": "CA", "tags": "", "date": "2021-02-16 00:00:00 +0900", "snippet": "명령어 명령어의 정의 컴퓨터가 하드웨어에게 일을 시키기위한 수단 명령어는 하향식 접근구조 다음 명령어를 가르키는 레지스터에 따라서 명령어를 실행함 인스트럭션 포인터(Instruction Pointer) 현재 실행되고 있는 프로그램의 실행 코드가 저장된 메모리의 주소를 가르키는 상태 레지스터 프로그램의 실행이 진행됨에 따라 자동으로 증가함 프로그램의 실행 순서가 변경되는 제어문이 실행될 때 자동으로 변경됨 직접접근이 불가한 레지스터 명령어 집합구조(Instruction Set Architecture) 프로세서가 인식해서 기능을 이해하고 실핼할 수 있는 기계어 명령어 집합구조는 1대1 대은되는 어셈블리로 표현 가능함 명령어 집합구조에는 MIPS, ARM, x86, RISC-V 등이 있음 명령어 집합구조(ISA) 설계 명령어 집합 구조는 작성된 프로그램과 그 프로그램을 수행할 컴퓨터 하드웨어 사이의 인터페이스에 대한 완전한 정의 혹은 명세 하드웨어 기술이나 컴퓨터의 구성, 플랫폼이 될 운영체제 등을 고려해야 하는 매우 어려운 작업 연산의 종류 처리연산, 제어연산, 입출력연산 등 데이터 형식 데이터의 의미, 데이터 값 저장방식(정수, 실수, 논리) 등 명령어 형식 명령어 구성부분을 나타내는 양식(연산부로, 피연산자) 피연산자를 위한 주소지정방식(Addressing Mode) 피연산자의 위치를 명시하는 방법(stack,Heap) 메모리 or 레지스터 명령어의 구조 명령어는 크게 두 부분, 실행코드(opcode)와 피연산자(operand)부분으로 구성됨 출처: fastcampus" }, { "title": "컴퓨터개론 08", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A008/", "categories": "CA", "tags": "", "date": "2021-02-16 00:00:00 +0900", "snippet": "CPU 발전과정 CPU 발전과정 단일프로세서 &amp;gt; 멀티코어 프로레서 멀티코어 프로세서란 여러 개의 코어를 집적한 프로세서 파이프라인 구조를 채택하여 병렬성을 높이고 처리량을 최대화함 Intel 8086 최초의 16bit 프로세서 PC가 많이 보급되지 않아 상용화에는 실패 가성비가 떨어져 아케이드판, 콘솔쪽에도 미채용 80386 CPU 386이라는 이름으로 유명한 CPU 32bit 아키텍쳐로 이루어진 최초의 CPU PC의 보급화로 전세계적으로 널리 사용됨 펜티엄 숫자대신 최초로 이름을 갖게된 CPU 클럭속도 : 60MHz - 300MHz 슈퍼스칼라 아키텍쳐 채용 파이프라인 두개를 이용해서 여러 명령어를 실행 코어 2 멀티코어 프로세서 클럭속도: 1GHz - 3.33GHz 코어개수: 1,2,4 암달의 법칙 트랜지스터의 증가로 인한 성능향상에 한계점 도달 코어 개수를 늘리는 방향으로 CPU 진화 멀티코어 &amp;gt; 성능 2배 X 병령화 문제에 기인하여 프로세서 개수만으로는 성능향상에 한계점이 생김 출처: fastcampus i3/i5/i7 i3 - 2코어 4스레드 i5 - 4코어 4스레드 i7 - 4코어 8스레드 하이터 스레딩 오버클럭 " }, { "title": "컴퓨터개론 07", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A007/", "categories": "CA", "tags": "", "date": "2021-02-15 00:00:00 +0900", "snippet": "전력 전력이란 컴퓨터가 동작하는데 오비되는 전기의 힘 전력과 클럭소도는 밀접한 관계가 있음 CPU 온도가 갖아지면 전력소모가 줄어듦 파워서플라이를 통해 전력을 공급받음 전력과 클럭속도 간의 관계출처: fastcampus 전력사용 주 원인 트랜지스터가 0에서 1로 혹은 그 반대로 스위칭하는 동안에 소비 트랜지스터가 소비하는 전력은 스위칭시 소모되는 에너지와 시간당 논리값이 바뀌는 빈도수의 곱 (소비전력의 총량) 전력의 문제점 전압을 낮추면 트랜지스터 누설 전류가 커짐 누설 전류 : 전류가 흘러야 할 곳이 아닌 다른 곳으로 흘러버리는 현상 전력이 너무 높아지면 온도 또한 올라감 (냉각 비용발생) " }, { "title": "컴퓨터개론 06", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A006/", "categories": "CA", "tags": "", "date": "2021-02-15 00:00:00 +0900", "snippet": "CPU 성능 성능의 정의 시간과 시소스에 대응되어 컴퓨터 시스템이 수행하는 작업의 양 상대적인 가치 성능측정척도는 다양하다. 개인사용자: 응답시간 / 데이터센터 관리자: 처리량 응답시간 작업개시에서부터 종료까지의 시간 디스크 접근, 메모리 접근, 입출력 작업, 운영체제 오버헤드, CPU 연산시간 등을 포함 처리량 단위 시간당 처리할 수 있는 테스크의 양 응답시간과 다른 척도로 시스템 성능을 평가할 때 사용 성능과 실행 시간과의 관계 성능x = 1/ 실행시간x 일때, 성능x &amp;gt; 성능y 이면, 1/실행시간x &amp;gt; 1/실행시간y 이며, 실행시간y는 실행시간x보다 크다 성능x/성능y = n 이며, 성능 x = n 성능y이고, x는 y보다 n배 빠르다. 문) 같은 프로그램이 컴퓨터 A에서 10초, B에서 15초라면 A는 B보다 얼마나 빠른가? A) A = 1/10 , b = 1/15 1/10 = n * 1/15 1.5 = n A는 B보다 1.5배 빠르다 클럭(Clock) 하드웨어 이벤트가 발생하는 시점을 결정 클럭 사이클 : 클럭의 시간 간격(전자신호의 호출 간의 간격) 클럭 주기 : 한 클럭 사이클에 걸리는 시간 ( 예 : 1/1000초) 클럭 속도 : 클럭 주기의 역수 ( 예 : 1초에 1번 =&amp;gt; 10Hz(헤르츠는 1초에 100번 진동함을 의미)) 컴퓨터 프로세서의 동작 속도 CPU 성능과 성능인자 궁극적인 CPU 성능 척도는 CPU시간 (입출력시간, 다른 프로그램 실행 시간 미포함) 프로그램의 CPU 실행시간 = 프로그램의 CPU 클럭 사이클 수/클럭 속도 클럭사이클 수 = 명령어수 * 명령어당 평균 클럭 사이클 수 (CPI) 문) 2GHz 클럭의 컴퓨터 A에서 10초에 수행되는 프로그램이 있다. 이 프로그램을 6초 동안에 실행할 컴퓨터 B를 설계하고자 한다. 이 때, A보다 1.2배 많은 클럭 사이클이 필요하게 된다고 할 때, 컴퓨터 B의 클럭 속도는 얼마로 결정해야하는가? A) 10 = 클럭속도A / 2GHz 20GHz = 클럭속도 A 6 = 20GHz * 1.2 / 클럭속도B 클럭속도B = 4GHz CPI CPI = Clock cycle Per Instruction 명령어 하나의 실행에 필요한 평균 클거 사이클 수 CPU 클럭 사이클 수 = 명령어 수 * CPI 프로그램의 CPU 실행시간 = 멸열어수 * CPI / 클럭속도 " }, { "title": "컴퓨터개론 05", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A005/", "categories": "CA", "tags": "", "date": "2021-02-15 00:00:00 +0900", "snippet": "기계어와 어셈블리어 고급언어 프로그램의 형태 프로그램은 무엇인가? 컴퓨터는 어떻게 프로그램을 이해하는가? 프로그램이 구동될때 하드웨어는 어떤 동작을 취하는가? 고급언어 일반적으로 언급되는 프로그래밍 언어 c, java 등 고급언어를 컴파일러가 어셈블리어로 번역 어셈블리어 컴파일러로 부터 생성된 어셈블리어는 기계가 이해할 수 있는 형태로 번역됨 기계사고방식의 언어 어셉를러는 어셈블이어를 기계어로 번역 기계어 기계어는 기수가 2인 숫자로 구성됨 숫자 단위 하나는 비트 컴퓨터가 이해할 수 있는 비트들의 집합 시스템 소프트웨어 공통적으로 필요한 서비스를 제공하는 소프트웨어 운영체제, 컴파일러, 로더, 어셈블러 프로그램 - 하드웨어간의 인터페이스 역할 High Level Language 기계어를 고도로 추상화한 표현으로써 인간이 이해하기 숴운형태 프로그램을 개발한 기종에 상관없이 어느 컴퓨터에서든 실행가능한 형태 컴파일 과정에서 불필요하나 instruction 이 생성되므로 다소 속도가 느림 Low Level Language 컴파일러나 어셈블리어가 생성하는 불필요한 instruction 을 최소화 가능 기계적 사고 방식을 강요하기 때문에 프로그램 구성을 위한 소요가 큼 결론 개발에 있어 고급언어가 효율적 실행속도에 있어 기계어가 효율적 CPU 기술 발전에 의하여 실행속도 차이가 줄어듦 " }, { "title": "컴퓨터개론 04", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A004/", "categories": "CA", "tags": "", "date": "2021-02-10 00:00:00 +0900", "snippet": "컴퓨터의 구성요소 입력(input) 출력(output) 메모리(memory) 데이터패스(data path) 제어유닛(control)출처: fastcampus 컴퓨터 구성요소 구성 요소별 역할 프로세서 메모리로 부터 명령과 데이터를 얻음 제어유닛은 프로그램 명령에 따라서 데이터패스, 메모리, 입/출력의 동작을 결정함. 메모리 실질적으로 데이터 저장되는 공간 입력 데이터를 메모리에 씀 출력 메모리로 부터 데이터를 읽음 출처: fastcampus 컴퓨터 구성요소 프로세서의 역할: CPU 메모리로 부터 명령어를 받아와 제어신호를 생성 컴퓨터 명령어(기계어)를 해석하고 연산함 컴퓨터 기술을 이끄는 원동력 인간의 두뇌와 같은 역할 프로세서의 역할: GPU 픽셀로 이루어진 영상을 처리하는 용도로 탄생 싱글코어는 CPU보다 저성능이지만 병렬적인 구천개의 코어가 연결되어있음 인공지능 기술발전의 선도주자 프로세서의 동작과정 제어유닛 제어신호 생성, 다음 동작 결정 레지스터(범용/특수목적) 산술/논리 연산장치 메모리의 역할 명령어(프로세서) 및 데이터 적재 정보를 저장해 두었다가 필요할 때 읽어들이는 저장소 레지스터의 용량이 너무 작어서 출시됨 RAM, ROM, 캐시 등 입력장치의 역할 데이터를 입력하기 위한 컴퓨터의 외부장치 키보드, 마우스, 스캐너 등이 있음 출력장치의 역할 컴퓨터에서 처리된 결과를 출력해주는 외부 장치 모니터, 프린터, 스피터 등이 있음 " }, { "title": "컴퓨터개론 03", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A003/", "categories": "CA", "tags": "", "date": "2021-02-10 00:00:00 +0900", "snippet": "컴퓨터 구조 분야의 8가지 아이디어8가지 아이디어 무어의 법칙1을 고려한 설계 설계를 단순화 하는 추상화 Common case fast [자주 발생하는 일은 빠르게] 병렬성을 통한 성능개선 파이프라이닝을 통한 성능개선 예측을 통한 성능 개선 메모리 계층구조 여유분을 이용한 신용도 개선 무어의 법칙을 고려한 설계 인텔의 창립자 중 한명인 고든 무어의 예측에서 유래 18~24개월 마다 칩에 집적되는 소자의 수가 2배 가 된다는 법칙 컴퓨터를 설계하는 데에는 수년이 걸리기 때문에 집적되는 소자의 수가 2배 내지 4배 증가함 설계를 단순화하는 추상화 무어의 법칙에 따라 자원의 수가 급격하게 증가함 설계시간이 길어 짐으로써 생산성이 낮아짐 생상성을 높이기 위하여 추상화 개념을 사용 하위 수준의 상세한 사항을 안보이게 함으로써 상위 수준 모델의 단순화 Common case fast [자주 발생하는 일은 빠르게] 자주 발생하는 일은 빠르게 처리하여 성능 향상도모 Common case의 최적화 및 단순화 Common case가 무엇인지 알고 있다는 가정 Common case에 대한 세심한 실험과 측정 필요 병렬성을 통한 성능 개선 컴퓨터 역사 초기부터 설계자들은 병렬성을 높여 성능을 끌어 올렸다. 병렬성이란 큰 문제 를 여러 개의 작은 문제로 나누어서 해결하는 방법 병렬 처리의 예: 쓰레드 파이프라이닝을 통한 성능 개선 파이프라이닝은 병렬성의 특별한 형태 이전 단계 출력 이 다음 단계 입력 으로 이어지는 구조 화재를 진압하기 위해서 많은 사람들이 일렬로 늘어서 양동이를 나르는 것 예측을 통한 성능 개선 수요가 예상되는 부분을 예측 복구비용 낮고, 성공확률 높을 경우, 효과적 정확한 예측을 위한 지표가 필요함 메모리 계층구조 메모리 계층 구조를 통한 문제 해셜 최상위 - 비싸고 제일 빠른 메모리 최하휘 - 느리고 값이 싼 메모리 여유분을 이용한 신용도 개선 컴퓨터는 신뢰할 수 있어야함 장애대처를 위한 여유분 준비 데이터 손실 예방을 위한 백업과 같은 이치 1: Moore" }, { "title": "컴퓨터개론 02", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A002/", "categories": "CA", "tags": "", "date": "2021-02-10 00:00:00 +0900", "snippet": "정지문제란?&quot;프로그램과 초기 입력 값이 주어겼을 때, 이 프로그램에 입력값을 넣고 실행한다면,이 프로그램이 계산을 끝내고 멈출지 아니면 영원히 계속 계산 할지 판정하라&quot;튜링기계적인 방식으로 모든 수학적인 증명이 가능한가? - 결정 문제힐버트튜링머신 테이프에 기록될 수 있는 기호 및 튜링 머신의 상태와 행동표의 새수는 모두 유한해야 하며 서로 구분되어야 한다. 예) 현재 상태가 1인데 기호 A를 읽었다면 C를 기록하고 정지 튜링머신이 유한한 시간안에 모든 문제를 푸는 방법이 있는지 없는지 알아낼수 있는가?정지문제 가정 1 : halt(a,b):임의의 문자열 a와 임의의 프로그램 b에 대해, a를 입력으로 프로그램 b를 실행했을 경우를 계산하여그 실행이 끝나면 참, 영원히 실행되면 거짓을 반환하는 알고리즘.function check(string s) if(halt(s,s) == false) return true else loop foreverwhy ? Q) halt 함수의 두 번째 인자는 프로그램 아닌가요? A) 프로그램으로 받아햐 하지만, 프로그램도 다르게 말하면 문자열 표현중 하나(바이너리 코드) 라고 볼 수 있기 때문에 문자열 또한 입력이 가능합니다.튜링동치 만일 컴퓨터 P와 Q가 있을 때, P가 할 수 있는 일을 Q가 모두할 수 있고, Q가 할 수 있는 일을 모구 P가 흉내낼 수 있다면 두 컴퓨터는 튜링 동치다.튜링완전성 어떤 컴퓨터 P가 있어서 그 컴퓨터와 튜링 머신이 튜링 동치하면 P는 튜링 완전하다.현대 컴퓨터와 튜링 머신 현대 컴퓨터의 모체는 튜링머신이기 때문에 튜링머신은 현대의 모든 컴퓨터가 할 수 있는 일을 할 수 있다. 현대의 컴퓨터와 튜링머신은 튜링 동치이다. 즉, 정지문제는 현대까지 유효하다." }, { "title": "컴퓨터개론 01", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%9C%EB%A1%A001/", "categories": "CA", "tags": "", "date": "2021-02-10 00:00:00 +0900", "snippet": "컴퓨터란? 컴퓨터의 정의 전자 회로를 이용하여 데이터를 처리하는 장치 방대한 데이터를 저장 하고, 자동적으로 계산 입력, 제어, 기억, 연산, 출력 기능 등을 갖추고 있음 인류 역사에 유례가 없는 발명품 컴퓨터는 어떤 일을 할 수 있을까? 복잡한 계산(미적분 , 통계) 초정밀 그래픽 구현 네트워크 통신 컴퓨터의 역사 고대 계산을 하는 도구로서 사장 처음 만들어진 주판 기원전 약 3천년전 고대 메소포타미아에서 사용 17세기에 이르도록 주판이 이용됨 중세 1642년 프랑스 수학자 파스칼이 톱니바퀴를 이요한 계산기 발명 최초의 기계식 계산기 기어로 연결된 바퀴판들로 덧셈과 뺄셈 동작 가능 1671년 독일의 라이프니츠가 이를 개량해 곱셈과 나눗셈도 가능한 계산기 발명(2진법) 근현대 19세기 중반 영국의 찰스 배비지가 차분엔진을 발명 차분엔진은 현대 컴퓨터의 개념을 처음으로 제시함 차분기관과 해석기관을 설계하여 제어, 연산, 기억, 입출력이 가능하였음 프로그램과 데이터로 구성된 입력에는 천공 카드를 사용하였음 1930년대에 들어 앨런 튜링, 알론조 처리 등이 계산 가능성 및 불가능성에 대해 연구1 이를 기반으로 튜링머신 탄생 튜링머신은 긴 테이프에 부호를 기록하여 이를 프로그램처럼 사용 1921년 독일의 콘라드 추제가 z3 발명 1945년 폰 노아만이 stored-program architecture를 제안2 1946년 미국의 애니악 제작 현대 1960년대 초기의 다목적 컴퓨터 IBM시스템/360개발 1970년대 Thompson과 Ritchie가 Unix와 C 개발 Intel 8008 프로세서 개발 1980년대 Interl 프로세서와 MS-DOS를 사용하는 IBM PC 등장 GUI와 마우스를 사용하는 애플 매킨토시 등장 1990년대 Linus Torvalds가 Linux를 개발 Microsoft의 Windows가 등장 인터넷 포털 등장 2000년대 컴퓨터를 활용하여 인간 DNA 30억 염기서열을 밝히는 Genom Project 애플의 iPhone를 필두로 스마트폰이 쏟아져 나옴 빅데이터 인공지능 시대 1: 정지문제 - 입력값을 주었을때, 계산이 가능한지 여부function check(string s) if(halt(s,s) == false) return true else loop forever2: 전선 재배치가 아닌, 소프트웨어 변경으로 통한 범용성 향상" }, { "title": "자바스터디 12주차", "url": "/posts/whiteship-study-12week/", "categories": "study", "tags": "", "date": "2021-02-06 00:00:00 +0900", "snippet": "GOAL 자바의 애노테이션에 대해 학습하세요.학습할 것 (필수) 애노테이션 정의하는 방법 @retention @target @documented 애노테이션 프로세서애노테이션 정의하는 방법어노테이션이란(annotation)?자바 Annotation 은 메타 데이터 를 나타내는 태그입니다. 즉, 자바 컴파일러 및 JVM에서 사용할 수있는 몇 가지 추가 정보를 나타 내기 위해 클래스, 인터페이스, 메서드 또는 필드에 추가하여 사용합니다.자바의 어노테이션은 추가 정보를 제공하는 데 사용되므로 XML 및 자바 마커 인터페이스등으로 대체 가능합니다.자바 내장 어노테이션자바에는 몇가지 내장 객체가 있습니다. 일부 주석은 자바 코드에 쓰이고, 일부는 다른 용도로 사용됩니다.자바 코드에 사용되는 내장 어노테이션 @Override @SuppressWarnings @Deprecated다른 용도로 사용되는 내장 어노테이션 @Target @Retention @Inherited @Documented@Override@Override 어노테이션은 자식클래드가 부모클래스의 메소드를 오버라이딩하고 있다고 단언할 수 있게 해줍니다.때문에, 실제로 오버라이딩되지 않으면, 컴파일 에러를 발생합니다.public class Animal { void eatSomething(){System.out.println(&quot;eating something&quot;);}}public class Dog extends Animal{ @Override void eatSomething() { System.out.println(&quot;eating foods&quot;); }}public class TestAnnotation { public static void main(String[] args) { Animal a = new Dog(); a.eatSomething(); }} 바이트코드오버라이드 어노테이션이 있는 Dog만 확인해 본다public class week12.Dog extends week12.Animal { public week12.Dog(); Code: 0: aload_0 1: invokespecial #1 // Method week12/Animal.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return void eatSomething(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String eating foods 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}어노테이션은 넣는다고 해서 바이트 코드에 영향이 가지 않는다.@SuppressWarnings@SuppressWarnings 어노테이션은 컴파일러가 알려주는 경고를 무시할 수 있도록 해줍니다.아래의 코드에서는 제네릭 타입을 사용하지 않았기 때문에 컴파일 타임에 경고를 표시해 줍니다.public class SuppresTest { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { ArrayList list = new ArrayList(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); for (Object o : list) { System.out.println(o); } }}아래의 사진과 같이 @SuppressWarnings 어노테이션을 주석처리하면 경고를 표시합니다.아래의 사진과 같이 @SuppressWarnings 어노테이션을 추가사면 경고를 표시가 사라집니다.@Deprecated@Deprecated 는 향후에 지원이 중단될 수도 있는 메서드에 대해 경고하는 역할을 합니다.따라서 @Deprecated 어노테이션이 표시된 메서드는 사용하지 않는 것이 좋습니다.public class A { @Deprecated void m(){ System.out.println(&quot;hello&quot;); }}public class DeprecateMain { public static void main(String[] args) { A a= new A(); a.m(); }}자바 커스텀 어노테이션자바 커스텀 어노테이션은 사용자 쉽게 정의하여 사용할수 있는 어노테이션으로, @interface 예약어를 사용합니다.(interface 가 아닙니다.) 커스텀 어노테이션을 만들때 주의할 사항은 아래와 같습니다. 메서드에 throws 절이 없어야 합니다. 메서드는 다음중 하나를 반환해야 합니다 : 기본 데이터 유형, 문자열, 클래스, 열거 형 또는 데이터 유형의 배열 메서드에는 매개 변수가 없어야합니다. 어노테이션을 정의하려면 interface 키워드 바로 앞에 @를 붙여야합니다. 메서드에 기본값을 할당 할 수 있습니다.public @interface MyAnno {} 바이트코드public interface week12.MyAnno extends java.lang.annotation.Annotation {} 사용법public class TestAnnotation { @MyAnno() void test(){ }}어노테이션 유형어노테이션에는 3가지 유형이 있습니다. 마커 어노테이션(Marker Annotation) 단일 값 어노테이션(Single-Value Annotation) 다중 값 어노테이션(Multi-Value Annotation)마커 어노테이션public @interface MyAnno {}메소드가 없는 어노테이션을 마커 어노테이션이라고 합니다.위에 만든 커스텀 어노테이션도 마커 어노테이션이라 할 수 있으며, @Override 및 @Deprecated는 마커 어노테이션입니다.단일 값 어노테이션public @interface MyAnno { int value() default 0;} 바이트코드public interface week12.MyAnno extends java.lang.annotation.Annotation { public abstract int value();} 사용법public class TestAnnotation { @MyAnno(value = 1) void test(){ }}하나의 메서드가 있는 어노테이션을 단일 값 어노테이션이라고 합니다. 바이트코드 확인시 추상 메서드로 생성되는 것을 확인 할 수 있습니다.단일 메서드 명이 value 인 경우에만 특수하게 아래와 같은 코드도 사용 가능합니다.public class TestAnnotation { @MyAnno(1) void test(){ }}다중 값 어노테이션public @interface MyAnno { int value() default 0; String type() default &quot;animal&quot;;} 바이트코드public interface week12.MyAnno extends java.lang.annotation.Annotation { public abstract int value(); public abstract java.lang.String type();}둘 이상의 메소드가 있는 어노테이션을 다중 값 어노테이션이라고 합니다. 사용법public class TestAnnotation { @MyAnno(value = 1,type = &quot;human&quot;) void test(){ }}커스텀 에노테이션에 사용되는 내장 어노테이션 @Retention @Target @Inherited @Documented@Retention@Retention 어노테이션은 해당 주석을 언제 까지 사용 할 수있는지 범위를 정할 수 있습니다. Retention 정책 범위 RetentionPolicy.SOURCE 컴파일처리시까지만 사용됩니다. 컴파일 된 클래스에서는 표시되지 않습니다. RetentionPolicy.CLASS 자바 컴파일러에서까지 사용 가능하지만 JVM에서는 사용이 불가합니다. 클래스 파일에 포함되어 있습니다. RetentionPolicy.RUNTIME 자바 컴파일러 및 JVM에서 사용할 수있는 있습니다. @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation{ int value1(); String value2(); } @target@Target 태그는 어노테이션이 사용되는 유형을 지정하는 데 사용됩니다.java.lang.annotation.ElementType은 열거형으로 TYPE, METHOD, FIELD 등과 같이 어노테이션이 적용될 요소의 유형을 지정하기 위해 많은 상수를 지원합니다. 요소유형 위치 TYPE 클래스, 인터페이스 혹은 열거형 FIELD 필드 METHOD 메소드 CONSTRUCTOR 생성자 LOCAL_VARIABLE 지역 변수 ANNOTATION_TYPE 어노테이션타입 PARAMETER 파라미터 @Target(ElementType.TYPE)public @interface MyAnno { int value() default 0; String type() default &quot;animal&quot;;}@Inherited어노테이션은 상속이 불가능 하지만, @Inherited 이 붙은 어노테이션에 한하여 상속을 가능하도록 해줍니다.@UninheritedAnnotationTypepublic class A {}@InheritedAnnotationTypepublic class B extends A{}public class C extends B{}public class TestAnnotation { public static void main(String[] args) { System.out.println(new A().getClass().getAnnotation(InheritedAnnotationType.class)); System.out.println(new B().getClass().getAnnotation(InheritedAnnotationType.class)); System.out.println(new C().getClass().getAnnotation(InheritedAnnotationType.class)); System.out.println(&quot;_________________________________&quot;); System.out.println(new A().getClass().getAnnotation(UninheritedAnnotationType.class)); System.out.println(new B().getClass().getAnnotation(UninheritedAnnotationType.class)); System.out.println(new C().getClass().getAnnotation(UninheritedAnnotationType.class)); }} 결과null@InheritedAnnotationType()@InheritedAnnotationType()_________________________________@UninheritedAnnotationType()nullnull결과를 보면 @InheritedAnnotationType 어노테이션을 선언하면 해당 어노테이션은 상속받은 어노테이션을 붙이지 않은(위에서 클래스 C)도 해당 어노테이션을 불러오는 것을 확인 할 수 있습니다.@documented@Documented 어노테이션이 지정된 대상을 JavaDoc에 표시하기 위해 사용합니다. @Documented 어노테이션을 이용하여 API 문서를 만들 수 있습니다.JavaDoc 파일 생성은 아래 블로그를 참고하세요JavaDoc애노테이션 프로세서이름에서 유추할 수 있듯이 애노테이션을 이용해서 프로세스를 처리하는것을 의미합니다.특히 애노테이션 프로세서의 특징은 컴파일 단계에서 애노테이션에 정의된 액션을 처리하는데, 이는 우리의 애플리케이션이 실행되기 전 체킹을 해주기 때문에 애노테이션으로 의도한대로 이루어지지 않을 경우 에러나 경고를 보여주기도 하며, 소스코드인 .java와 바이트코드인 .class를 생성해주기도 합니다.출처우리가 사용하는 spring의 컨트롤러나 lombok 도 애노테이션 프로세서라 할 수 있다.아래의 블로그도 참조하세요 Annotation Processor란?참조javatpoint.com/java-annotationstackoverflow.com/questions/23973107/how-to-use-inherited-annotation-in-java" }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A811/", "categories": "php", "tags": "", "date": "2021-02-04 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문12. 즉시 로드와 페이징프로그래머는 항상 극단적인 상황을 고려하며 코드를 작성해야 한다. 웹 개발에서 가장 극단적인 상황 중 하나가 큰 데이터다. 일억 개의 데이터베이스 레코드에 대고 SELECT * FROM big_table where foo LIKE ‘%bar%’ 같은 쿼리를 날렸다거나, 운이 좋아 쿼리 결과가 천건만 나옸는데 이 결롸를 뷰에 바인딩해서 웹 브라우저로 내보낸다고 상상해 보자. 두 경우 모두 컴퓨터 및 네트워크 자원을 많이 사용할 뿐만 아니라, 결과를 얻거나 화면을 출력하는 데 오랜 시간이 걸린다. 문제 해결은 인프라나 데이터페이스 등 어느 한 부분에서만 한다고 다 되는 것이 아니다. 이때 라라벨이 할 수 있는 조치는 즉시 로드와 페이징이다. 극단적인 상황을 머릿속에 그려 보며 개발하는 것은 좋은 습관이다.12.1 즉시 로드천 건의 데이터를 뷰에 표현할 때, 연결된 테이블 값을 가져와야 할 수도 있다. 어떤 시나리오인지 경험해 보자 routes/web.php&amp;lt;?phpRoute::get(&#39;/&#39;, function () { return view(&#39;welcome&#39;);});Auth::routes();Route::get(&#39;/home&#39;, &#39;HomeController@index&#39;);Route::resource(&#39;articles&#39;, &#39;ArticlesController&#39;); app/Http/Controllers/ArticlesController.php&amp;lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use App\\Http\\Requests;class ArticlesController extends Controller{ /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { $articles = \\App\\Article::get(); return view(&#39;articles.index&#39;,compact(&#39;articles&#39;)); }}코드 12-3을 참고해서 포럼 글 목록을 표시할 뷰를 만들자. 9장을 공부할 때, 라라벨이 자동으로 만든 마스터 레이아웃()을 상속한다." }, { "title": "전자정부트렌젝션", "url": "/posts/%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%ED%8A%B8%EB%A0%8C%EC%A0%9D%EC%85%98/", "categories": "troubleshooting", "tags": "", "date": "2021-02-02 00:00:00 +0900", "snippet": " 전자정부에서 트렌젝션 사용시, SQL conn이 끊기는 현상이 있다..(~아오…~), 해당 현상 발생시 참고해보자" }, { "title": "자바스터디 11주차", "url": "/posts/whiteship-study-11week/", "categories": "study", "tags": "", "date": "2021-01-29 00:00:00 +0900", "snippet": "GOAL자바의 열거형에 대해 학습하세요.학습할 것 (필수) enum 정의하는 방법 enum이 제공하는 메소드 (values()와 valueOf()) java.lang.Enum EnumSetenum 정의하는 방법Enum(열거형)이란?자바에서 열거형은 1.5버전부터 적용된 기술로, 이전에 열거형 처리를 위해서는 int Enum 패턴을 사용했습니다.public class EnumTest { // int Enum Pattern-심각한 문제가 있습니다! public static final int SEASON_WINTER = 0; public static final int SEASON_SPRING = 1; public static final int SEASON_SUMMER = 2; public static final int SEASON_FALL = 3;} 바이트코드public class test.EnumTest { public static final int SEASON_WINTER; public static final int SEASON_SPRING; public static final int SEASON_SUMMER; public static final int SEASON_FALL; public test.EnumTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return}위와 같은 패턴에는 다음같은 문제가 발생합니다. 형식이 안전하지 않음(Type-safe) : 위 코드에서 보면 봄,여름,가을,겨울 중 택 1 해야하지만 합연산을 통해 봄이면서 여름 이고, 겨울이며 여름의 표현이 가능합니다. ( 위 예시에서 , 가을은 3으로 , 봄과 여름의 값으로 표현할수 있습니다. ~있을수 없는 일입니다~ 네임스페이스가 없음 : 다른 int enum 타입과 구문하기 위해, SEASON_ 이라는 접두사를 항상 써야합니다. 취성(한계를 넘어서 파괴되는 것) : int enum는 컴파일 타입 상수이기 때문에, 새 상수가 추가되거나, 순서가 변경되면 소스 전체의 재 컴파일이 필요합니다. 그렇지 않으면, 정확한 동작을 보장하기 힘듭니다. 비효과적 정보 : 단순이 int 값만 표기되기에, 의미있는 값이되기 힘듭니다.Typesafe Enum 패턴 ( Effective Java Item 21 참조) 을 사용하여 이러한 문제를 해결할 수 있지만이 해당 패턴사용해야 되는 현상자체에 있습니다. 매우 장황하여 오류가 발생하기 쉬우 며 해당 enum 상수를 switch명령문 에서 사용할 수 없습니다.때문에 1.5 부터 열거 유형에 대해 지원을 하게 되었습니다. 가장 간단한 형식에서 이러한 열거 형은 C, C ++ 및 C # 대응 항목과 비슷합니다.public enum Season { WINTER, SPRING, SUMMER, FALL} 바이트코드public final class test.Season extends java.lang.Enum&amp;lt;test.Season&amp;gt; { public static final test.Season WINTER; public static final test.Season SPRING; public static final test.Season SUMMER; public static final test.Season FALL; public static test.Season[] values(); Code: 0: getstatic #1 // Field $VALUES:[Ltest/Season; 3: invokevirtual #2 // Method &quot;[Ltest/Season;&quot;.clone:()Ljava/lang/Object; 6: checkcast #3 // class &quot;[Ltest/Season;&quot; 9: areturn public static test.Season valueOf(java.lang.String); Code: 0: ldc #4 // class test/Season 2: aload_0 3: invokestatic #5 // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; 6: checkcast #4 // class test/Season 9: areturn static {}; Code: 0: new #4 // class test/Season 3: dup 4: ldc #7 // String WINTER 6: iconst_0 7: invokespecial #8 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 10: putstatic #9 // Field WINTER:Ltest/Season; 13: new #4 // class test/Season 16: dup 17: ldc #10 // String SPRING 19: iconst_1 20: invokespecial #8 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 23: putstatic #11 // Field SPRING:Ltest/Season; 26: new #4 // class test/Season 29: dup 30: ldc #12 // String SUMMER 32: iconst_2 33: invokespecial #8 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 36: putstatic #13 // Field SUMMER:Ltest/Season; 39: new #4 // class test/Season 42: dup 43: ldc #14 // String FALL 45: iconst_3 46: invokespecial #8 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 49: putstatic #15 // Field FALL:Ltest/Season; 52: iconst_4 53: anewarray #4 // class test/Season 56: dup 57: iconst_0 58: getstatic #9 // Field WINTER:Ltest/Season; 61: aastore 62: dup 63: iconst_1 64: getstatic #11 // Field SPRING:Ltest/Season; 67: aastore 68: dup 69: iconst_2 70: getstatic #13 // Field SUMMER:Ltest/Season; 73: aastore 74: dup 75: iconst_3 76: getstatic #15 // Field FALL:Ltest/Season; 79: aastore 80: putstatic #1 // Field $VALUES:[Ltest/Season; 83: return}바이트코드를 보면 단순한 몇줄의 코드가 실제로는 java.lang.Enum 클래스의 제네릭을 이용하여 내부적으로는 구현되어 있음을 알 수 있습니다.또한 위에서 열거한 문제를 해결하는 것 외에도 열거 형 유형에 임의의 메서드와 필드를 추가하고 임의의 인터페이스를 구현하는 등의 작업을 수행 할 수 있으며, Enum 형식은 모든 Object 메서드 구현을 이용 가능하고, 기본적으로는 Thread-safe 합니다.enum이 제공하는 메소드 (values()와 valueOf())values() 열거형의 모든 값을 호출할때 사용한다package week11;public class TestMain { public static void main(String[] args) { for (EnumTest enumTest : EnumTest.values()) { System.out.println(&quot;season =&amp;gt; &quot;+ enumTest); } } enum EnumTest { SPRING,SUMMER,FALL,WINTER; }} 바이트코드final class week11.TestMain$EnumTest extends java.lang.Enum&amp;lt;week11.TestMain$EnumTest&amp;gt; { public static final week11.TestMain$EnumTest SPRING; public static final week11.TestMain$EnumTest SUMMER; public static final week11.TestMain$EnumTest FALL; public static final week11.TestMain$EnumTest WINTER; public static week11.TestMain$EnumTest[] values(); Code: 0: getstatic #1 // Field $VALUES:[Lweek11/TestMain$EnumTest; 3: invokevirtual #7 // Method &quot;[Lweek11/TestMain$EnumTest;&quot;.clone:()Ljava/lang/Object; 6: checkcast #8 // class &quot;[Lweek11/TestMain$EnumTest;&quot; 9: areturn public static week11.TestMain$EnumTest valueOf(java.lang.String); Code: 0: ldc #2 // class week11/TestMain$EnumTest 2: aload_0 3: invokestatic #12 // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; 6: checkcast #2 // class week11/TestMain$EnumTest 9: areturn static {}; Code: 0: new #2 // class week11/TestMain$EnumTest 3: dup 4: ldc #22 // String SPRING 6: iconst_0 7: invokespecial #24 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 10: putstatic #25 // Field SPRING:Lweek11/TestMain$EnumTest; 13: new #2 // class week11/TestMain$EnumTest 16: dup 17: ldc #28 // String SUMMER 19: iconst_1 20: invokespecial #24 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 23: putstatic #30 // Field SUMMER:Lweek11/TestMain$EnumTest; 26: new #2 // class week11/TestMain$EnumTest 29: dup 30: ldc #32 // String FALL 32: iconst_2 33: invokespecial #24 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 36: putstatic #34 // Field FALL:Lweek11/TestMain$EnumTest; 39: new #2 // class week11/TestMain$EnumTest 42: dup 43: ldc #36 // String WINTER 45: iconst_3 46: invokespecial #24 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 49: putstatic #38 // Field WINTER:Lweek11/TestMain$EnumTest; 52: iconst_4 53: anewarray #2 // class week11/TestMain$EnumTest 56: dup 57: iconst_0 58: getstatic #25 // Field SPRING:Lweek11/TestMain$EnumTest; 61: aastore 62: dup 63: iconst_1 64: getstatic #30 // Field SUMMER:Lweek11/TestMain$EnumTest; 67: aastore 68: dup 69: iconst_2 70: getstatic #34 // Field FALL:Lweek11/TestMain$EnumTest; 73: aastore 74: dup 75: iconst_3 76: getstatic #38 // Field WINTER:Lweek11/TestMain$EnumTest; 79: aastore 80: putstatic #1 // Field $VALUES:[Lweek11/TestMain$EnumTest; 83: return}public class week11.TestMain { public week11.TestMain(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: invokestatic #7 // Method week11/TestMain$EnumTest.values:()[Lweek11/TestMain$EnumTest; 3: astore_1 4: aload_1 5: arraylength 6: istore_2 7: iconst_0 8: istore_3 9: iload_3 10: iload_2 11: if_icmpge 38 14: aload_1 15: iload_3 16: aaload 17: astore 4 19: getstatic #13 // Field java/lang/System.out:Ljava/io/PrintStream; 22: aload 4 24: invokedynamic #19, 0 // InvokeDynamic #0:makeConcatWithConstants:(Lweek11/TestMain$EnumTest;)Ljava/lang/String; 29: invokevirtual #23 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 32: iinc 3, 1 35: goto 9 38: return}valueOf() 해당 열거형에 해당하는 값이 있는지 확인한다. 해당하는 값이 없을 경우, 예외(IllegalArgumentException)를 반환한다.package week11;public class TestMain { public static void main(String[] args) { System.out.println(EnumTest.valueOf(&quot;SPRING&quot;)); //SPRING System.out.println(EnumTest.valueOf(&quot;spring&quot;)); //IllegalArgumentException } enum EnumTest { SPRING,SUMMER,FALL,WINTER; }} 바이트코드final class week11.TestMain$EnumTest extends java.lang.Enum&amp;lt;week11.TestMain$EnumTest&amp;gt; { public static final week11.TestMain$EnumTest SPRING; public static final week11.TestMain$EnumTest SUMMER; public static final week11.TestMain$EnumTest FALL; public static final week11.TestMain$EnumTest WINTER; public static week11.TestMain$EnumTest[] values(); Code: 0: getstatic #1 // Field $VALUES:[Lweek11/TestMain$EnumTest; 3: invokevirtual #7 // Method &quot;[Lweek11/TestMain$EnumTest;&quot;.clone:()Ljava/lang/Object; 6: checkcast #8 // class &quot;[Lweek11/TestMain$EnumTest;&quot; 9: areturn public static week11.TestMain$EnumTest valueOf(java.lang.String); Code: 0: ldc #2 // class week11/TestMain$EnumTest 2: aload_0 3: invokestatic #12 // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; 6: checkcast #2 // class week11/TestMain$EnumTest 9: areturn static {}; Code: 0: new #2 // class week11/TestMain$EnumTest 3: dup 4: ldc #22 // String SPRING 6: iconst_0 7: invokespecial #24 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 10: putstatic #25 // Field SPRING:Lweek11/TestMain$EnumTest; 13: new #2 // class week11/TestMain$EnumTest 16: dup 17: ldc #28 // String SUMMER 19: iconst_1 20: invokespecial #24 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 23: putstatic #30 // Field SUMMER:Lweek11/TestMain$EnumTest; 26: new #2 // class week11/TestMain$EnumTest 29: dup 30: ldc #32 // String FALL 32: iconst_2 33: invokespecial #24 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 36: putstatic #34 // Field FALL:Lweek11/TestMain$EnumTest; 39: new #2 // class week11/TestMain$EnumTest 42: dup 43: ldc #36 // String WINTER 45: iconst_3 46: invokespecial #24 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 49: putstatic #38 // Field WINTER:Lweek11/TestMain$EnumTest; 52: iconst_4 53: anewarray #2 // class week11/TestMain$EnumTest 56: dup 57: iconst_0 58: getstatic #25 // Field SPRING:Lweek11/TestMain$EnumTest; 61: aastore 62: dup 63: iconst_1 64: getstatic #30 // Field SUMMER:Lweek11/TestMain$EnumTest; 67: aastore 68: dup 69: iconst_2 70: getstatic #34 // Field FALL:Lweek11/TestMain$EnumTest; 73: aastore 74: dup 75: iconst_3 76: getstatic #38 // Field WINTER:Lweek11/TestMain$EnumTest; 79: aastore 80: putstatic #1 // Field $VALUES:[Lweek11/TestMain$EnumTest; 83: return}public class week11.TestMain { public week11.TestMain(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #13 // String SPRING 5: invokestatic #15 // Method week11/TestMain$EnumTest.valueOf:(Ljava/lang/String;)Lweek11/TestMain$EnumTest; 8: invokevirtual #21 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V 11: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 14: ldc #27 // String spring 16: invokestatic #15 // Method week11/TestMain$EnumTest.valueOf:(Ljava/lang/String;)Lweek11/TestMain$EnumTest; 19: invokevirtual #21 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V 22: return}java.lang.Enum추상 크래스로 구현되어 있으며, 가용가능한 다양항 메소드가 구현되어 있다. ( 그렇기 때문에, 인터페이스가 아닌 추상클래스로 구현되어 있는게 아닌가 싶다)Enum은 3가지 인터페이스를 추가로 상속 받고 있다. ( Constable, Comparable, Serializable )또한 Enum을 통한 set이라 map이 구현되어 있어 효과적으로 이용하도록 권고하고 있다./** * This is the common base class of all Java language enumeration types. * * More information about enums, including descriptions of the * implicitly declared methods synthesized by the compiler, can be * found in section 8.9 of * &amp;lt;cite&amp;gt;The Java&amp;amp;trade; Language Specification&amp;lt;/cite&amp;gt;. * * &amp;lt;p&amp;gt; Note that when using an enumeration type as the type of a set * or as the type of the keys in a map, specialized and efficient * {@linkplain java.util.EnumSet set} and {@linkplain * java.util.EnumMap map} implementations are available. * * @param &amp;lt;E&amp;gt; The enum type subclass * @serial exclude * @author Josh Bloch * @author Neal Gafter * @see Class#getEnumConstants() * @see java.util.EnumSet * @see java.util.EnumMap * @jls 8.9 Enum Types * @jls 8.9.3 Enum Members * @since 1.5 */@SuppressWarnings(&quot;serial&quot;) // No serialVersionUID needed due to // special-casing of enum types.public abstract class Enum&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; implements Constable, Comparable&amp;lt;E&amp;gt;, Serializable { /** * The name of this enum constant, as declared in the enum declaration. * Most programmers should use the {@link #toString} method rather than * accessing this field. */ private final String name; /** * Returns the name of this enum constant, exactly as declared in its * enum declaration. * * &amp;lt;b&amp;gt;Most programmers should use the {@link #toString} method in * preference to this one, as the toString method may return * a more user-friendly name.&amp;lt;/b&amp;gt; This method is designed primarily for * use in specialized situations where correctness depends on getting the * exact name, which will not vary from release to release. * * @return the name of this enum constant */ public final String name() { return name; } /** * The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this field. It is designed * for use by sophisticated enum-based data structures, such as * {@link java.util.EnumSet} and {@link java.util.EnumMap}. */ private final int ordinal; /** * Returns the ordinal of this enumeration constant (its position * in its enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this method. It is * designed for use by sophisticated enum-based data structures, such * as {@link java.util.EnumSet} and {@link java.util.EnumMap}. * * @return the ordinal of this enumeration constant */ public final int ordinal() { return ordinal; } /** * Sole constructor. Programmers cannot invoke this constructor. * It is for use by code emitted by the compiler in response to * enum type declarations. * * @param name - The name of this enum constant, which is the identifier * used to declare it. * @param ordinal - The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). */ protected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } /** * Returns the name of this enum constant, as contained in the * declaration. This method may be overridden, though it typically * isn&#39;t necessary or desirable. An enum type should override this * method when a more &quot;programmer-friendly&quot; string form exists. * * @return the name of this enum constant */ public String toString() { return name; } /** * Returns true if the specified object is equal to this * enum constant. * * @param other the object to be compared for equality with this object. * @return true if the specified object is equal to this * enum constant. */ public final boolean equals(Object other) { return this==other; } /** * Returns a hash code for this enum constant. * * @return a hash code for this enum constant. */ public final int hashCode() { return super.hashCode(); } /** * Throws CloneNotSupportedException. This guarantees that enums * are never cloned, which is necessary to preserve their &quot;singleton&quot; * status. * * @return (never returns) */ protected final Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } /** * Compares this enum with the specified object for order. Returns a * negative integer, zero, or a positive integer as this object is less * than, equal to, or greater than the specified object. * * Enum constants are only comparable to other enum constants of the * same enum type. The natural order implemented by this * method is the order in which the constants are declared. */ public final int compareTo(E o) { Enum&amp;lt;?&amp;gt; other = (Enum&amp;lt;?&amp;gt;)o; Enum&amp;lt;E&amp;gt; self = this; if (self.getClass() != other.getClass() &amp;amp;&amp;amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } /** * Returns the Class object corresponding to this enum constant&#39;s * enum type. Two enum constants e1 and e2 are of the * same enum type if and only if * e1.getDeclaringClass() == e2.getDeclaringClass(). * (The value returned by this method may differ from the one returned * by the {@link Object#getClass} method for enum constants with * constant-specific class bodies.) * * @return the Class object corresponding to this enum constant&#39;s * enum type */ @SuppressWarnings(&quot;unchecked&quot;) public final Class&amp;lt;E&amp;gt; getDeclaringClass() { Class&amp;lt;?&amp;gt; clazz = getClass(); Class&amp;lt;?&amp;gt; zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? (Class&amp;lt;E&amp;gt;)clazz : (Class&amp;lt;E&amp;gt;)zuper; } /** * Returns an enum descriptor {@code EnumDesc} for this instance, if one can be * constructed, or an empty {@link Optional} if one cannot be. * * @return An {@link Optional} containing the resulting nominal descriptor, * or an empty {@link Optional} if one cannot be constructed. * @since 12 */ @Override public final Optional&amp;lt;EnumDesc&amp;lt;E&amp;gt;&amp;gt; describeConstable() { return getDeclaringClass() .describeConstable() .map(c -&amp;gt; EnumDesc.of(c, name)); } /** * Returns the enum constant of the specified enum type with the * specified name. The name must match exactly an identifier used * to declare an enum constant in this type. (Extraneous whitespace * characters are not permitted.) * * &amp;lt;p&amp;gt;Note that for a particular enum type {@code T}, the * implicitly declared {@code public static T valueOf(String)} * method on that enum may be used instead of this method to map * from a name to the corresponding enum constant. All the * constants of an enum type can be obtained by calling the * implicit {@code public static T[] values()} method of that * type. * * @param &amp;lt;T&amp;gt; The enum type whose constant is to be returned * @param enumType the {@code Class} object of the enum type from which * to return a constant * @param name the name of the constant to return * @return the enum constant of the specified enum type with the * specified name * @throws IllegalArgumentException if the specified enum type has * no constant with the specified name, or the specified * class object does not represent an enum type * @throws NullPointerException if {@code enumType} or {@code name} * is null * @since 1.5 */ public static &amp;lt;T extends Enum&amp;lt;T&amp;gt;&amp;gt; T valueOf(Class&amp;lt;T&amp;gt; enumType, String name) { T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(&quot;Name is null&quot;); throw new IllegalArgumentException( &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name); } /** * enum classes cannot have finalize methods. */ @SuppressWarnings(&quot;deprecation&quot;) protected final void finalize() { } /** * prevent default deserialization */ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { throw new InvalidObjectException(&quot;can&#39;t deserialize enum&quot;); } private void readObjectNoData() throws ObjectStreamException { throw new InvalidObjectException(&quot;can&#39;t deserialize enum&quot;); } /** * A &amp;lt;a href=&quot;{@docRoot}/java.base/java/lang/constant/package-summary.html#nominal&quot;&amp;gt;nominal descriptor&amp;lt;/a&amp;gt; for an * {@code enum} constant. * * @param &amp;lt;E&amp;gt; the type of the enum constant * * @since 12 */ public static final class EnumDesc&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; extends DynamicConstantDesc&amp;lt;E&amp;gt; { /** * Constructs a nominal descriptor for the specified {@code enum} class and name. * * @param constantType a {@link ClassDesc} describing the {@code enum} class * @param constantName the unqualified name of the enum constant * @throws NullPointerException if any argument is null * @jvms 4.2.2 Unqualified Names */ private EnumDesc(ClassDesc constantType, String constantName) { super(ConstantDescs.BSM_ENUM_CONSTANT, requireNonNull(constantName), requireNonNull(constantType)); } /** * Returns a nominal descriptor for the specified {@code enum} class and name * * @param &amp;lt;E&amp;gt; the type of the enum constant * @param enumClass a {@link ClassDesc} describing the {@code enum} class * @param constantName the unqualified name of the enum constant * @return the nominal descriptor * @throws NullPointerException if any argument is null * @jvms 4.2.2 Unqualified Names * @since 12 */ public static&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumDesc&amp;lt;E&amp;gt; of(ClassDesc enumClass, String constantName) { return new EnumDesc&amp;lt;&amp;gt;(enumClass, constantName); } @Override @SuppressWarnings(&quot;unchecked&quot;) public E resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException { return Enum.valueOf((Class&amp;lt;E&amp;gt;) constantType().resolveConstantDesc(lookup), constantName()); } @Override public String toString() { return String.format(&quot;EnumDesc[%s.%s]&quot;, constantType().displayName(), constantName()); } }}EnumSetEnum의 Typesafe를 지원하며, 내부 구현은 비트 벡터로 구현하고/** * A specialized {@link Set} implementation for use with enum types. All of * the elements in an enum set must come from a single enum type that is * specified, explicitly or implicitly, when the set is created. Enum sets * are represented internally as bit vectors. This representation is * extremely compact and efficient. The space and time performance of this * class should be good enough to allow its use as a high-quality, typesafe * alternative to traditional {@code int}-based &quot;bit flags.&quot; Even bulk * operations (such as {@code containsAll} and {@code retainAll}) should * run very quickly if their argument is also an enum set. * * &amp;lt;p&amp;gt;The iterator returned by the {@code iterator} method traverses the * elements in their &amp;lt;i&amp;gt;natural order&amp;lt;/i&amp;gt; (the order in which the enum * constants are declared). The returned iterator is &amp;lt;i&amp;gt;weakly * consistent&amp;lt;/i&amp;gt;: it will never throw {@link ConcurrentModificationException} * and it may or may not show the effects of any modifications to the set that * occur while the iteration is in progress. * * &amp;lt;p&amp;gt;Null elements are not permitted. Attempts to insert a null element * will throw {@link NullPointerException}. Attempts to test for the * presence of a null element or to remove one will, however, function * properly. * * &amp;lt;P&amp;gt;Like most collection implementations, {@code EnumSet} is not * synchronized. If multiple threads access an enum set concurrently, and at * least one of the threads modifies the set, it should be synchronized * externally. This is typically accomplished by synchronizing on some * object that naturally encapsulates the enum set. If no such object exists, * the set should be &quot;wrapped&quot; using the {@link Collections#synchronizedSet} * method. This is best done at creation time, to prevent accidental * unsynchronized access: * * &amp;lt;pre&amp;gt; * Set&amp;amp;lt;MyEnum&amp;amp;gt; s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class)); * &amp;lt;/pre&amp;gt; * * &amp;lt;p&amp;gt;Implementation note: All basic operations execute in constant time. * They are likely (though not guaranteed) to be much faster than their * {@link HashSet} counterparts. Even bulk operations execute in * constant time if their argument is also an enum set. * * &amp;lt;p&amp;gt;This class is a member of the * &amp;lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&amp;gt; * Java Collections Framework&amp;lt;/a&amp;gt;. * * @author Josh Bloch * @since 1.5 * @see EnumMap */public abstract class EnumSet&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; extends AbstractSet&amp;lt;E&amp;gt; implements Cloneable, java.io.Serializable{ // declare EnumSet.class serialization compatibility with JDK 8 private static final long serialVersionUID = 1009687484059888093L; /** * The class of all the elements of this set. */ final transient Class&amp;lt;E&amp;gt; elementType; /** * All of the values comprising E. (Cached for performance.) */ final transient Enum&amp;lt;?&amp;gt;[] universe; EnumSet(Class&amp;lt;E&amp;gt;elementType, Enum&amp;lt;?&amp;gt;[] universe) { this.elementType = elementType; this.universe = universe; } /** * Creates an empty enum set with the specified element type. * * @param &amp;lt;E&amp;gt; The class of the elements in the set * @param elementType the class object of the element type for this enum * set * @return An empty enum set of the specified type. * @throws NullPointerException if {@code elementType} is null */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; noneOf(Class&amp;lt;E&amp;gt; elementType) { Enum&amp;lt;?&amp;gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + &quot; not an enum&quot;); if (universe.length &amp;lt;= 64) return new RegularEnumSet&amp;lt;&amp;gt;(elementType, universe); else return new JumboEnumSet&amp;lt;&amp;gt;(elementType, universe); } /** * Creates an enum set containing all of the elements in the specified * element type. * * @param &amp;lt;E&amp;gt; The class of the elements in the set * @param elementType the class object of the element type for this enum * set * @return An enum set containing all the elements in the specified type. * @throws NullPointerException if {@code elementType} is null */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; allOf(Class&amp;lt;E&amp;gt; elementType) { EnumSet&amp;lt;E&amp;gt; result = noneOf(elementType); result.addAll(); return result; } /** * Adds all of the elements from the appropriate enum type to this enum * set, which is empty prior to the call. */ abstract void addAll(); /** * Creates an enum set with the same element type as the specified enum * set, initially containing the same elements (if any). * * @param &amp;lt;E&amp;gt; The class of the elements in the set * @param s the enum set from which to initialize this enum set * @return A copy of the specified enum set. * @throws NullPointerException if {@code s} is null */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; copyOf(EnumSet&amp;lt;E&amp;gt; s) { return s.clone(); } /** * Creates an enum set initialized from the specified collection. If * the specified collection is an {@code EnumSet} instance, this static * factory method behaves identically to {@link #copyOf(EnumSet)}. * Otherwise, the specified collection must contain at least one element * (in order to determine the new enum set&#39;s element type). * * @param &amp;lt;E&amp;gt; The class of the elements in the collection * @param c the collection from which to initialize this enum set * @return An enum set initialized from the given collection. * @throws IllegalArgumentException if {@code c} is not an * {@code EnumSet} instance and contains no elements * @throws NullPointerException if {@code c} is null */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; copyOf(Collection&amp;lt;E&amp;gt; c) { if (c instanceof EnumSet) { return ((EnumSet&amp;lt;E&amp;gt;)c).clone(); } else { if (c.isEmpty()) throw new IllegalArgumentException(&quot;Collection is empty&quot;); Iterator&amp;lt;E&amp;gt; i = c.iterator(); E first = i.next(); EnumSet&amp;lt;E&amp;gt; result = EnumSet.of(first); while (i.hasNext()) result.add(i.next()); return result; } } /** * Creates an enum set with the same element type as the specified enum * set, initially containing all the elements of this type that are * &amp;lt;i&amp;gt;not&amp;lt;/i&amp;gt; contained in the specified set. * * @param &amp;lt;E&amp;gt; The class of the elements in the enum set * @param s the enum set from whose complement to initialize this enum set * @return The complement of the specified set in this set * @throws NullPointerException if {@code s} is null */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; complementOf(EnumSet&amp;lt;E&amp;gt; s) { EnumSet&amp;lt;E&amp;gt; result = copyOf(s); result.complement(); return result; } /** * Creates an enum set initially containing the specified element. * * Overloadings of this method exist to initialize an enum set with * one through five elements. A sixth overloading is provided that * uses the varargs feature. This overloading may be used to create * an enum set initially containing an arbitrary number of elements, but * is likely to run slower than the overloadings that do not use varargs. * * @param &amp;lt;E&amp;gt; The class of the specified element and of the set * @param e the element that this set is to contain initially * @throws NullPointerException if {@code e} is null * @return an enum set initially containing the specified element */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; of(E e) { EnumSet&amp;lt;E&amp;gt; result = noneOf(e.getDeclaringClass()); result.add(e); return result; } /** * Creates an enum set initially containing the specified elements. * * Overloadings of this method exist to initialize an enum set with * one through five elements. A sixth overloading is provided that * uses the varargs feature. This overloading may be used to create * an enum set initially containing an arbitrary number of elements, but * is likely to run slower than the overloadings that do not use varargs. * * @param &amp;lt;E&amp;gt; The class of the parameter elements and of the set * @param e1 an element that this set is to contain initially * @param e2 another element that this set is to contain initially * @throws NullPointerException if any parameters are null * @return an enum set initially containing the specified elements */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; of(E e1, E e2) { EnumSet&amp;lt;E&amp;gt; result = noneOf(e1.getDeclaringClass()); result.add(e1); result.add(e2); return result; } /** * Creates an enum set initially containing the specified elements. * * Overloadings of this method exist to initialize an enum set with * one through five elements. A sixth overloading is provided that * uses the varargs feature. This overloading may be used to create * an enum set initially containing an arbitrary number of elements, but * is likely to run slower than the overloadings that do not use varargs. * * @param &amp;lt;E&amp;gt; The class of the parameter elements and of the set * @param e1 an element that this set is to contain initially * @param e2 another element that this set is to contain initially * @param e3 another element that this set is to contain initially * @throws NullPointerException if any parameters are null * @return an enum set initially containing the specified elements */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; of(E e1, E e2, E e3) { EnumSet&amp;lt;E&amp;gt; result = noneOf(e1.getDeclaringClass()); result.add(e1); result.add(e2); result.add(e3); return result; } /** * Creates an enum set initially containing the specified elements. * * Overloadings of this method exist to initialize an enum set with * one through five elements. A sixth overloading is provided that * uses the varargs feature. This overloading may be used to create * an enum set initially containing an arbitrary number of elements, but * is likely to run slower than the overloadings that do not use varargs. * * @param &amp;lt;E&amp;gt; The class of the parameter elements and of the set * @param e1 an element that this set is to contain initially * @param e2 another element that this set is to contain initially * @param e3 another element that this set is to contain initially * @param e4 another element that this set is to contain initially * @throws NullPointerException if any parameters are null * @return an enum set initially containing the specified elements */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; of(E e1, E e2, E e3, E e4) { EnumSet&amp;lt;E&amp;gt; result = noneOf(e1.getDeclaringClass()); result.add(e1); result.add(e2); result.add(e3); result.add(e4); return result; } /** * Creates an enum set initially containing the specified elements. * * Overloadings of this method exist to initialize an enum set with * one through five elements. A sixth overloading is provided that * uses the varargs feature. This overloading may be used to create * an enum set initially containing an arbitrary number of elements, but * is likely to run slower than the overloadings that do not use varargs. * * @param &amp;lt;E&amp;gt; The class of the parameter elements and of the set * @param e1 an element that this set is to contain initially * @param e2 another element that this set is to contain initially * @param e3 another element that this set is to contain initially * @param e4 another element that this set is to contain initially * @param e5 another element that this set is to contain initially * @throws NullPointerException if any parameters are null * @return an enum set initially containing the specified elements */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; of(E e1, E e2, E e3, E e4, E e5) { EnumSet&amp;lt;E&amp;gt; result = noneOf(e1.getDeclaringClass()); result.add(e1); result.add(e2); result.add(e3); result.add(e4); result.add(e5); return result; } /** * Creates an enum set initially containing the specified elements. * This factory, whose parameter list uses the varargs feature, may * be used to create an enum set initially containing an arbitrary * number of elements, but it is likely to run slower than the overloadings * that do not use varargs. * * @param &amp;lt;E&amp;gt; The class of the parameter elements and of the set * @param first an element that the set is to contain initially * @param rest the remaining elements the set is to contain initially * @throws NullPointerException if any of the specified elements are null, * or if {@code rest} is null * @return an enum set initially containing the specified elements */ @SafeVarargs public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; of(E first, E... rest) { EnumSet&amp;lt;E&amp;gt; result = noneOf(first.getDeclaringClass()); result.add(first); for (E e : rest) result.add(e); return result; } /** * Creates an enum set initially containing all of the elements in the * range defined by the two specified endpoints. The returned set will * contain the endpoints themselves, which may be identical but must not * be out of order. * * @param &amp;lt;E&amp;gt; The class of the parameter elements and of the set * @param from the first element in the range * @param to the last element in the range * @throws NullPointerException if {@code from} or {@code to} are null * @throws IllegalArgumentException if {@code from.compareTo(to) &amp;gt; 0} * @return an enum set initially containing all of the elements in the * range defined by the two specified endpoints */ public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; range(E from, E to) { if (from.compareTo(to) &amp;gt; 0) throw new IllegalArgumentException(from + &quot; &amp;gt; &quot; + to); EnumSet&amp;lt;E&amp;gt; result = noneOf(from.getDeclaringClass()); result.addRange(from, to); return result; } /** * Adds the specified range to this enum set, which is empty prior * to the call. */ abstract void addRange(E from, E to); /** * Returns a copy of this set. * * @return a copy of this set */ @SuppressWarnings(&quot;unchecked&quot;) public EnumSet&amp;lt;E&amp;gt; clone() { try { return (EnumSet&amp;lt;E&amp;gt;) super.clone(); } catch(CloneNotSupportedException e) { throw new AssertionError(e); } } /** * Complements the contents of this enum set. */ abstract void complement(); /** * Throws an exception if e is not of the correct type for this enum set. */ final void typeCheck(E e) { Class&amp;lt;?&amp;gt; eClass = e.getClass(); if (eClass != elementType &amp;amp;&amp;amp; eClass.getSuperclass() != elementType) throw new ClassCastException(eClass + &quot; != &quot; + elementType); } /** * Returns all of the values comprising E. * The result is uncloned, cached, and shared by all callers. */ private static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; E[] getUniverse(Class&amp;lt;E&amp;gt; elementType) { return SharedSecrets.getJavaLangAccess() .getEnumConstantsShared(elementType); } /** * This class is used to serialize all EnumSet instances, regardless of * implementation type. It captures their &quot;logical contents&quot; and they * are reconstructed using public static factories. This is necessary * to ensure that the existence of a particular implementation type is * an implementation detail. * * @serial include */ private static class SerializationProxy&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; implements java.io.Serializable { private static final Enum&amp;lt;?&amp;gt;[] ZERO_LENGTH_ENUM_ARRAY = new Enum&amp;lt;?&amp;gt;[0]; /** * The element type of this enum set. * * @serial */ private final Class&amp;lt;E&amp;gt; elementType; /** * The elements contained in this enum set. * * @serial */ private final Enum&amp;lt;?&amp;gt;[] elements; SerializationProxy(EnumSet&amp;lt;E&amp;gt; set) { elementType = set.elementType; elements = set.toArray(ZERO_LENGTH_ENUM_ARRAY); } /** * Returns an {@code EnumSet} object with initial state * held by this proxy. * * @return a {@code EnumSet} object with initial state * held by this proxy */ @SuppressWarnings(&quot;unchecked&quot;) private Object readResolve() { // instead of cast to E, we should perhaps use elementType.cast() // to avoid injection of forged stream, but it will slow the // implementation EnumSet&amp;lt;E&amp;gt; result = EnumSet.noneOf(elementType); for (Enum&amp;lt;?&amp;gt; e : elements) result.add((E)e); return result; } private static final long serialVersionUID = 362491234563181265L; } /** * Returns a * &amp;lt;a href=&quot;{@docRoot}/serialized-form.html#java.util.EnumSet.SerializationProxy&quot;&amp;gt; * SerializationProxy&amp;lt;/a&amp;gt; * representing the state of this instance. * * @return a {@link SerializationProxy} * representing the state of this instance */ Object writeReplace() { return new SerializationProxy&amp;lt;&amp;gt;(this); } /** * @param s the stream * @throws java.io.InvalidObjectException always */ private void readObject(java.io.ObjectInputStream s) throws java.io.InvalidObjectException { throw new java.io.InvalidObjectException(&quot;Proxy required&quot;); }}" }, { "title": "Java_Interview_Questions", "url": "/posts/JavaInterviewQuesions/", "categories": "interview", "tags": "", "date": "2021-01-21 00:00:00 +0900", "snippet": " 아래 내용은 해당 페이지를 번역한 내용입니다. Java Interview Questions자바 개발자 인터뷰에서 물어보는 질문 37가지1. String, StringBuffer , StringBuilder 간의 차이를 설명하시오String 은 (기본적으로) 불변 객체이기 때문에 수정한다고 하여도 해당 객체가 변경 되는 것이 아닌 새로운 객체로 변경 됩니다. 그렇기에 구버전 jdk의 경우, StringBuffer 를 사용하여 해당 문제를 해결하였습니다. 하지만 StringBuffer 의 경우, 동기화에 따른 추가 비용이 발생하기 때문에, 동기화 비용이 발생하지 않는 StringBuilder 를 사용하는 것을 권장하고 있습니다.요약 String 불변객체이므로 수정에 따른 비용 발생 StringBuffer 로 해당 현상을 해결하지만, 동기화 비용 발생 StringBuilder 는 동기화 처리 비용이 발생하지 않기에 StringBuilder 사용을 권장추가 최근 jdk의 경우, String 도 수정시, 내부적으로 빌더를 통한 변경이 이루어짐2. CLI에서 classpath 를 여러개 설저하는 방법은 설명하시오java -cp /dev/myapp.jar:/dev/mydependency.jar com.codementor.MyApp3. final, finalize, finally 간의 차이를 설명하시오final 는 클래스의 경우, 오버라이드나 재정의를 할수 없게 만들며, 필드의 경우, 수정을 불가하게 만듭니다.finalize 는 GC(가비지 콜렉터)가 실행될때, 실행되는 메서드로 해당 객체가 사용하는 메모리가 정리될때, 수행해야 되는 프로세스를 정의할 수 있습니다.finally 는 try/catch 문에 사용하여, 반드시 실행되어야 하는 프로세스를 정의할 수 있습니다.4. GC(가비지 컬렉터)가 메모리 부족을 예방하는 방법을 설명하시오가비지 컬렉터(GC)는 함수 스코프를 벗어나서 더이상 메모리에서 사용하지 않는 객체를 초기화합니다.때문에 어플리케이션에서 사용하는 대량의 객체를 위와 같은 방식으로 처리하여, 메모리부족(OutOfMemory)를 방지 합니다.5. ClassNotFoundException 와 NoClassDefFoundError 의 차아점은 무엇인가요?ClassNotFoundException : 클래스 로더가 클래스 패스에서 해당 클래스를 못 찾으면 발생한다. 이 에러가 발생하면 기본적으로 클래스 패스와 그 패스에 해당 클래스가 존재하는지 확인해야한다.NoClassDefFoundError :이것이 발생하면 이유를 찾기가 꽤나 골치아퍼 지는데, 이것은 컴파일타임때 요구되는 클래스가 존재하지만 런타임때 클래스들이 바뀌거나, 제거되거나, 클래스의 스태틱 초기화가 예외를 던지면 이것이 발생한다. 먼 소리냐하면 클래스패스에 클래스가 존재하더라도, 이 클래스에 요구되는 클래스들중 하나에 문제가 생겼다는 이야기이다. 따라서 이 클래스와 의존관계를 맺는 모든것들을 살펴봐야한다.출처: https://hamait.tistory.com/348 [HAMA 블로그] 출처: https://blog.naver.com/ac7979/1401172222436. String.length ()가 정확 하지 않은 이유는 무엇 입니까?문자열 내의 문자 수만 고려하므로 정확하지 않습니다. 즉, BMP (Basic Multilingual Plane)라고 부르는 것 이외의 코드 포인트, 즉 값 U+10000이상을 가진 코드 포인트(이집트 상형문자 등의 특수문자)를 설명하지 못합니다 .그 이유는 Java가 처음 정의되었을 때 목표 중 하나는 모든 텍스트를 유니 코드로 처리하는 것이 었습니다. 그러나 현재 상용 유니 코드외의 BMP 외부의 코드 포인트(특수문자)를 정의하지 않았습니다. 유니 코드가 이러한 코드 포인트를 정의 할 때까지 기다리며 변경하기에는 너무 오래 걸렸습니다.자바에서는 , BMP 외부의 코드 포인트는 Java에서 서로 게이트 쌍 이라고하는 두개의 문자로 표시됩니다 . 기술적으로 Java의 문자는 UTF-16 코드 단위입니다.문자열 내의 실제 문자 수, 즉 코드 포인트 수를 계산하는 올바른 방법은 다음 중 하나입니다.someString.codePointCount(0, someString.length())또는 Java 8 이상 :someString.codePoints().count()7. 아래의 두 double 값을 결과를 신뢰 할 수 없는 이유는 무엇인가요?d1 == d2자바언어에서는 숫자가 아니면 원시타입이 아니기 때문에 동등연산사(==) 사용이 올바른 값을 반환하지 않는다. 때문에 아래와 같은 방법으로 비교해야한다. 예제final double d1 = Double.NaN;final double d2 = Double.NaN;System.out.println(d1 == d2); //falseSystem.out.println(Double.compare(d1,d2)); //0출처 : https://wikibook.co.kr/article/java-coding-with-pmd-badcomparison/8. 다음코드의 문제점을 설명 하시오final byte[] bytes = someString.getBytes();두 가지 문제점이 있다. JVM은 각 OS의 기본 문자셋(charset)에 의존 한다 해당 기본 문자셋이 모든 문자를 처리 할수 있다는 보장이 없다.(특수문자 등)2번 문제가 되지 않는다고 한다면, 1번의 경우 windows의 기본 기본 문자셋은 CP1252 이며 리눅스는 UTF-8이다. 때문에, é와 같은 문자의 경우, OS에 따른 처리가 다를 수 있다.때문에 문자셋을 정하는 코드를 사용하는 것이 좋다final byte[] bytes = someString.getBytes(StandardCharsets.UTF_8);9. JIT는 무엇입니까?간단하게 말해 JAVA에서 컴파일러의 수행 시간을 단축하기위한 메커니즘으로JAVA는 인터프리터언어와 컴파일언어의 특성을 둘 다 가지고 있다.컴파일러는 바이트코드를 기계어로 바꿀때, JTL 저장소를 생성하여, 반복되는 코드는 해석기를 통하지 않고 저장소에서 가져와 이용한다. 때문에 반복돠는 중복 코드 발생시, 처리속도를 단축할 수 있다.출처 : https://catch-me-java.tistory.com/11출처 : https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-2/10. 아래 코드에서 0.5가 출력되지 않는 이유를 설명하시오final double d = 1 / 2;System.out.println(d);JAVA에서는 상위 범위로 오토박싱(정확한 표현이 아닐수도 있습니다.)되며, 애매한 범위보다는 좁은 범위로 해석하게 됩니다. 때문에 위 코드는 double로 표현되어 있어도, int형으로 변환되어 표기됩니다. 따라서, 위 코드는 아래의 코드로 변경이 필요합니다final double d = 1.0 / 2;System.out.println(d);또는final double d = 1 / 2.0;System.out.println(d);11. 아래의 코드에서 System.out::println 가 참조하는 타입은 무엇인가요?IntStream.range(0, 10).forEach(System.out::println);IntStream.range(0, 10)은 IntStream을 반환하고 IntStream의 foreach 메소드는 IntConsumer 아규머트로 받아 , System.out 의 PrintStream으로 넘셔준다. 때문에 정답은 IntConsumer 이다.12. 아래 코드의 문제점은 무엇인가?final Path path = Paths.get(...);Files.lines(path).forEach(System.out::println);위 코드의 문제점은 Files.lines(path)이 닫히지 않았다는 것이다. Stream 은 BaseStream을 상속받는데, BaseStream은 AutoCloseable 상속 받고 있다. 때문에 try/catch 문을 이용하여, 처리해주면 된다.try ( final Stream&amp;lt;String&amp;gt; stream = Files.lines(path);) { stream.forEach(System.out::println);}13. 아래의 코드 결과에 대해 설명하시오final List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();list.add(1);list.add(2);list.add(3);list.remove(2);System.out.println(list); //[1,2]리스트의 remove() 메소드는 두가지로 구현되어 있다. remove(int index) remove(Object obj)JVM은 가장 명확한 표현을 찾는다. 때문에 remove(Object obj)가 아닌 remove(int index)의 메소드를 실행 되기 때문에, 위와 같은 결과가 나온다. 2를 삭제 하기 위해서는 아래와 같은 코드로 변경 해야 한다.final List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();list.add(1);list.add(2);list.add(3);list.remove(Integer.valueOf(2));System.out.println(list);14. 두 문장이 애너그램 여부를 확인하는 함수를 구현하라.(애너그램이란 어순이 바뀐 단어를 말한다. 예: HAVE &amp;gt; VAHE)public static boolean isAcronymMoreBetter(String s1, String s2) { char[] s1Chars = s1.toCharArray(); char[] s2Chars = s2.toCharArray(); Arrays.sort(s1Chars); Arrays.sort(s2Chars); return Arrays.equals(s1Chars, s2Chars);}15. equals() 와 hashCode()의 객체 접근방식의 차이점을 설명 하시오 equals()두 객체의 내용이 같은지 확인하는 Method입니다. hashCode()두 객체가 같은 객체인지 확인하는 Method입니다.출처 : https://nesoy.github.io/articles/2018-06/Java-equals-hashcode16. enum은 상속이 가능한가요?불가능 합니다.17. enum 은 Threadsafe한가요?[check]기본 구조는 Threadsafe하지만, 추가하는 작업에 메소드를 이용한다면 Threadsafe하지 않습니다.출처 : https://stackoverflow.com/questions/2531873/how-thread-safe-is-enum-in-java18. JVM이 로컬변수와 객체를 저장하는 방법에 대해 설명하시오로컬 변수는 stack영역에, 객체는 heap영역에 저장되며 해당 변수는 heap영역의 객체에 대한 참조값입니다.19. 아래 코드의 문제점에 대해 설명하시오public class Foo { public Foo() { doSomething(); } public void doSomething() { System.out.println(&quot;do something acceptable&quot;); }}public class Bar extends Foo { public void doSomething() { System.out.println(&quot;yolo&quot;); Zoom zoom = new Zoom(this); }}Bar 객체가 생성되기전 부모생상자(super()메소드는 명시적으로 정의하지 않아도 자동으로 호출 합니다.) Foo 의 생성자를 호출하면, 생성자는 doSomething()메소드를 호출 하고 해당 메소드는 오버라이딩된 Bar 객체의 doSomething()를 호출합니다. 때문에 new Zoom(this);의 this는 부모 생성자가 완전히 초기화 되지 않은 객체가 들어오기 때문에 이슈가 발생할 수 있습니다.20. volatile 변수는 언제 사용하나요?volatile keyword는 Java 변수를 Main Memory에 저장하겠다라는 것을 명시하는 것입니다.자바에서는 속도향상을 위해, 초기 메모리에서 값을 가져와 CPU 캐시의 저장 후, 해당 값을 각 Thread에서 사용합니다. 때문에 메모리에서 값을 가져와 변경 후 메모리에 값을 변경하기 전에 다른 Thread에서 값을 가져갈 경우, 해당 값을 다를수 있습니다. volatile이용하면 항상 메모리 값의 최신화 할 수 있으나, 원자성이 보장되지 않으면, 이슈가 발생할 수 있습니다. 출처 : https://nesoy.github.io/articles/2018-06/Java-volatile21. synchronized 메소드나 블록을 사용해야 하는 이유가 뭔가요?Thread 가 사용되고 있고 여러 Thread가 동기화 된 코드 섹션을 거쳐야하는 경우 한 번에 하나만 실행될 수 있습니다. 이것은 공유 변수가 여러 스레드에 의해 업데이트되지 않도록하는 데 사용됩니다.22. HashMap ConcurrentHashMapConcurrentHashMap는 Thread-safe 하며, HashMap는 Thread-safe 하지 않습니다.ConcurrentHashMap는 NULL을 허용하지 않으며, HashMap는 NULL을 허용합니다.23. equals() 와 hashCode() 는 언제 재정의 해야 할까요?hash-based 컬렉션의 성능 향상을 위해 사용 가능합니다.출처 : https://nesoy.github.io/articles/2018-06/Java-equals-hashcode24. 서비스랑 무엇인가요?서비스는 잘 정의되고 독립적이며 다른 서비스의 컨텍스트나 상태에 의존하지 않는 함수입니다.25. System.gc()의 가장 좋은 활용법은 무엇일까요?System.gc() 메모리 누수 분석에 사용하면 좋습니다. 대부분의 프로파일러는 해당 메소드 호출을 통해 메모리 스냅샷을 생성합니다.26. 마커인터페이스란 무엇인가요?마커인터페이스는 필드나 메서드가 없는 인터페이스를 말합니다. 이러한 마커인터페이스는 JVM에게 특정한 정보를 알리기 위한 용도로 사용되며, Serializable, Clonable, Remote 인터페이스 등이 있습니다.27. 마커인터페이스보다 어노태이션이 좋은 이유는 무엇인가요?어노테이션을 사용하면 별도의 유형을 만들지 않고도 클래스에 대한 메타 데이터를 소비자에게 전달하는 동일한 목적을 달성 할 수 있습니다. 또한, 프로그래머가 더 정교한 정보를 “소비”하는 클래스에 전달할 수 있습니다.28. checked 와 unchecked exceptions은 무엇이며, 언제 사용하나요?checked exception은 반드시 처리해아 하는 예외 이며, 컴파일러에 의해 처리 됩니다.unchecked exception은 반드시 잡아야 하는 예외는 아니며, 런타임시에 발생 합니다.회복 가능한 상황일 경우, checked exception을 사용하는 것이 좋습니다.참고 : https://yadon079.github.io/2021/java%20study%20halle/week-09#runtimeexception%EA%B3%BC-re%EA%B0%80-%EC%95%84%EB%8B%8C-%EA%B2%83%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%9429. int a = 1L; 는 컴파일이 불가능 하고, int b = 0; b += 1L; 컴파일이 가능합니다. 이유가 뭘까요?+=사용시, 직접문은 복합문으로 변경되어 컴파일러는 내부적으로 오토캐스팅을 진행합니다. 때문에 컴파일에러가 발생하지 않습니다. 하지만 단순 1L와 같은 직접문의 경우, 오토케스팅이 진행되지 않아 컴파일어에서 타입에러를 발생 시킨다.30. 자바에서 다중상속을 인터페이스에서는 허용하지만, 클래스에서는 허용하지 않는 이유는 무엇인가요?클래스를 확장하면 모호성 문제가 발생할 수 있습니다. 반면에 인터페이스 측면에서 한 클래스의 단일 메서드 구현은 둘 이상의 인터페이스를 제공 할 수 있습니다.31. 아래 코드에서 인스턴스가 null이지만, NullPointerException 이 발생하지 않는 이유는 무엇인가요?Test t = null;t.someMethod(); public static void someMethod() { ...}해당 코드는 인스턴스가 필요없는 정적 메소드이기 때문입니다. 정적 메소드는 인스턴스가 아닌 클래스에 속하기 때문에 null예외를 발생하지 않습니다.32. 아래코드에서 첫번째는 true 두번째는 false가 출력되는 이우는 무엇인가요?public class Test{ public static void main(String[] args) { Integer a = 1000, b = 1000; System.out.println(a == b); //false Integer c = 100, d = 100; System.out.println(c == d); //true }}해당 현상은 JVM의 캐시때문에 발생하는 현상입니다. JVM은 Integer가 범위(-128에서 127) 내에 있을 경우, 새로운 인스턴스 생성하지 않으며, 기존의 생성된 인스턴스의 참조 값을 이용합니다.때문에, 위 코드에서 d를 위한 참조는 생성되지 않으며, c의 참조 값을 이용합니다. 그렇기에 두 번째 출력은 true가 됩니다.33. 두 개의 문장이 아나그램인지 확인하시오String s1=&quot;home&quot;;String s2=&quot;mohe&quot;;boolean result = new String(Arrays.sort(s1.toCharArray())) .equals(new String(Arrays.sort(s2.toCharArray())));34. String(“Java Programming”)을 반복문과 재귀를 사용하지 않고 반전시키시오.System.out.println(&quot;reverse = &quot; + new StringBuilder(givenString).reverse());35. ArrayList를 사용하는 경우와 LinkedList를 사용하는 경우를 논하시오.ArrayList는 검색시 LinkedList보다 빠르기 때문에 검색이 빈번한 경우, 더 유용하며 O(1)삭제나 삽입 시에는, LinkedList가 더 유리합니다. O(1)36. Iterator 와 ListIterator 의 차이점이 무엇인가요?Iterator는 set,list에 시용가능하며, 단반향이동만 지원하며, ListIterator는 list에만 사용가능하며, 양방향이동이 가능하고 메소드를 통해서 인덱스를 가져올수 있다.출처 : http://www.tcpschool.com/java/java_collectionFramework_iterator37. 제네릭의 사용 이점이 뭔가요?컴파일 타임에 강력한 타입체크 기능을 지원하여, 런타임시 오류보다 더 쉬운 오류체크를 가능하도록 합니다.참고 : https://namjackson.tistory.com/18" }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A808/", "categories": "php", "tags": "", "date": "2021-01-20 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문9. 사용자 인증9.1 HTTP의 무상태 특성웹에서는 같은 사용자가 동일한 서버에 여러번 접근 하였더라도, 연속된 접근이 같은 사람으로 부터 왔다는것은 구분할 수 없다. 이런 무상태(stateless)는 HTTP 프로토콜의 가장 큰 특징이다.웹에서는 사용자가 로그인 하면 서버에서는 세션(session)이라 부르는 이름표를 하나 만들고, HTTP 쿠리(cookie) 메커니즘을 이용해서 세션이 만료되거나 사용자가 명시적으로 로그아웃할때까지 클라이언트와 이름표를 계속 주고받는다. 이 방법으로 서버는 클라이언트를 식별하고, 상태를 우지한다. 라라벨은 web 미들웨어 그룹에 속한 모든 라우트에서 세션을 유지한다.9.2 기본다지기로그인 종작 원리를 익히자9.2.1 User 모델User 모델과 마이그레이션은 라라벨에 기본적으로 포함되어 있다. app/models/User.php&amp;lt;?phpnamespace App\\Models;use Illuminate\\Contracts\\Auth\\MustVerifyEmail;use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;use Illuminate\\Foundation\\Auth\\User as Authenticatable;use Illuminate\\Notifications\\Notifiable;class User extends Authenticatable{ use HasFactory, Notifiable; /** * The attributes that are mass assignable. * * @var array */ protected $fillable = [ &#39;name&#39;, &#39;email&#39;, &#39;password&#39;, ]; /** * The attributes that should be hidden for arrays. * * @var array */ protected $hidden = [ &#39;password&#39;, &#39;remember_token&#39;, ]; /** * The attributes that should be cast to native types. * * @var array */ protected $casts = [ &#39;email_verified_at&#39; =&amp;gt; &#39;datetime&#39;, ];}name, email, password 열은 대량 할당이 가능하다. $hidden 프로터피에는 조회 쿼리에서 제외할 열을 정의한다. App\\Models\\User::get() 쿼리를 하면 password , remember_token 값은 표시되지 않는다.다른 클래스에서도 접근하기 위해 public 가시성을 가진다. public으로 선언된 모델 프로퍼티 값을 은익하는 방법이 $hidden이다. 물론 App\\Models\\User::find(1)-&amp;gt;password와 같이 직접 접근하면 값을 읽거나 쓸 수 있다. database/migrations/2014_10_12_000000_create_users_table.php&amp;lt;?phpuse Illuminate\\Database\\Migrations\\Migration;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Support\\Facades\\Schema;class CreateUsersTable extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::create(&#39;users&#39;, function (Blueprint $table) { $table-&amp;gt;id(); $table-&amp;gt;string(&#39;name&#39;); $table-&amp;gt;string(&#39;email&#39;)-&amp;gt;unique(); $table-&amp;gt;timestamp(&#39;email_verified_at&#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&#39;password&#39;); $table-&amp;gt;rememberToken(); $table-&amp;gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(&#39;users&#39;); }}rememberToken()은 string(‘remember_token’,100)-&amp;gt;nullable()의미를 가진 도우미 메서드다. users.remember_token 열은 사용자 로그인을 기억할 때 사용된디.팅커 콘솔로 사용자를 만들어 본다 새로운 사용자 만들기$ php artisan tinker&amp;gt;&amp;gt;&amp;gt; $user = App\\Models\\User::create([&#39;name&#39;=&amp;gt; &#39;John&#39;,&#39;email&#39;=&amp;gt;&#39;test@test.com&#39;,&#39;password&#39; =&amp;gt; bcrypt(&#39;test&#39;)]);=&amp;gt; App\\Models\\User {#4296 name: &quot;John&quot;, email: &quot;test@test.com&quot;, updated_at: &quot;2021-01-20 13:52:27&quot;, created_at: &quot;2021-01-20 13:52:27&quot;, id: 1, }&amp;gt;&amp;gt;&amp;gt; 9.2.2 사용자 인증 구현라우팅 파일만으로 사용자 인증을 구현 routes/web.php```php&amp;lt;?phpuse Illuminate\\Support\\Facades\\Route;Route::get(‘/’, ‘WelcomeController@index’);Route::get(‘auth/login’, function () { $credentials = [ ‘email’ =&amp;gt; ‘test@test.com’, ‘password’=&amp;gt;’test’ ];if (! auth()-&amp;gt; attempt($credentials)){ return &#39;로그인 정보가 올바르지 않습니다.&#39;;}return redirect(&#39;protected&#39;); });Route::get(‘protected’, function () { dump(session()-&amp;gt;all());if(!auth()-&amp;gt;check()){ return &quot;누구세요&quot;;}return &#39;어서 오세요&#39;.auth()-&amp;gt;user()-&amp;gt;name; });Route::get(‘auth/logout’, function () { auth()-&amp;gt;logout();return &quot;안녕히가세요&quot;; });- GET auth/login 라우트credentials 변수에 사용자 로그인에 필요한 정보를 하드코드로 담았다. auth()는 도우미 함수다. 사용자를 인증할 때는 attempt(array $credentials = [] , bool $remember = false)메서드를 이용한다. 메서드의 두 번째 인자에 true를 주면, 마이그레이션에서 봤던 remember_token 열과 같이 동작해서 사용자 로그인을 기억할 수 있다.auth() 도우미 대신 Auth::attempt()와 같이 파사드를 이용할 수도 있다. attempt() 메서드는 넘겨 받은 $credentials 정보를 데이터베이스 조회를 하기 전에 미리 해싱해서 비교할 준비를 한다. 로그인에 성공하면 세션에 사용자 정보를 기록한다.이 로직은 사용자 정보가 정확하지 않으면 오류 메세지를 표시한다. 로그인에 성공하면 /protected 로 사용자를 리디렉션 한다.- GET protected 라우트check() 메서드는 URL을 요청한 브라우저(사용자)가 로그인 상태명 true를 반환한다. user() 메서드는 로그읺나 사용자의 클래스 인스탄스를 반환한다. 그러므로 auth()-&amp;gt;uset()-&amp;gt;name과 같이 쓸수 있다.check() 메서드가 로그인 했는지 어떻게 알았을까? 이는 앞서 배운 쿠키 메커니즘으로 알 수 있다. 크롬 개발자 도구에서 HTTP 요청 해더에서 laravel_session 키와 값을 찾아보자.이 키의 값은 직전의 요청에 HTTP 응답 헤더로 받은 값이다. 참고로 전역 미들웨어인 App\\Http\\Middleware\\EncyptCookies가 이 값을 암복호화한다. 쿠키 변조를 막으려는 조치다.dump(session()-&amp;gt;all()) 은 세션에 저장된 값을 덤프하는 코드다. 로그인했을 때와 로그인하지 안았을 때의 차이점을 찾아보자. 덤프 결과에서 login_web_RANDOM_NUMBER 키에 사용자에 해당하는 기본 키 값이 담겨 있다. 이 키는 로그인했을 때만 존재한다.정리하면 라라벨은 laravle_ssesion 키를 가진 쿠키와 login_web_RANDOM_NUMBER 세션 키를 이용해서 사용자 로그인 여부를 핀단한다. 쿠키에 사용할 키는 config/session.php에서 변경할 수 있다.- GET auth/logout로그아웃은 logout()메서드를 사용한다. 로그아웃하면 세션을 폐기한다.#### 9.2.3 auth 미들웨어protected 에 if(!auth()-&amp;gt;check()) 블락이 없으면, auth()-&amp;gt;user() 값이 null이기 때문에, 오류가 발생한다. (null-&amp;gt;name은 불가능)auth() 미들웨어를 사용하면 if절을 사용하지 않고 다른 위치로 이동시킬 수 있다.&amp;gt; routes/web.php```php&amp;lt;?phpuse Illuminate\\Support\\Facades\\Route;Route::get(&#39;/&#39;, &#39;WelcomeController@index&#39;);Route::get(&#39;auth/login&#39;, function () { $credentials = [ &#39;email&#39; =&amp;gt; &#39;test@test.com&#39;, &#39;password&#39;=&amp;gt;&#39;test1&#39; ]; if (! auth()-&amp;gt; attempt($credentials)){ return &#39;로그인 정보가 올바르지 않습니다.&#39;; } return redirect(&#39;protected&#39;);});Route::get(&#39;protected&#39;, [&#39;middleware&#39;=&amp;gt;&#39;auth&#39;, function () {}]);Route::get(&#39;auth/logout&#39;, function () { auth()-&amp;gt;logout(); return &quot;안녕히가세요&quot;;}); myapp/vendor/laravel/framework/src/Illuminate/Auth/Middleware/Authenticate.php&amp;lt;?phpnamespace Illuminate\\Auth\\Middleware;use Closure;use Illuminate\\Auth\\AuthenticationException;use Illuminate\\Contracts\\Auth\\Factory as Auth;use Illuminate\\Contracts\\Auth\\Middleware\\AuthenticatesRequests;class Authenticate implements AuthenticatesRequests{ /** * The authentication factory instance. * * @var \\Illuminate\\Contracts\\Auth\\Factory */ protected $auth; /** * Create a new middleware instance. * * @param \\Illuminate\\Contracts\\Auth\\Factory $auth * @return void */ public function __construct(Auth $auth) { $this-&amp;gt;auth = $auth; } /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string[] ...$guards * @return mixed * * @throws \\Illuminate\\Auth\\AuthenticationException */ public function handle($request, Closure $next, ...$guards) { $this-&amp;gt;authenticate($request, $guards); return $next($request); } /** * Determine if the user is logged in to any of the given guards. * * @param \\Illuminate\\Http\\Request $request * @param array $guards * @return void * * @throws \\Illuminate\\Auth\\AuthenticationException */ protected function authenticate($request, array $guards) { if (empty($guards)) { $guards = [null]; } foreach ($guards as $guard) { if ($this-&amp;gt;auth-&amp;gt;guard($guard)-&amp;gt;check()) { return $this-&amp;gt;auth-&amp;gt;shouldUse($guard); } } $this-&amp;gt;unauthenticated($request, $guards); } /** * Handle an unauthenticated user. * * @param \\Illuminate\\Http\\Request $request * @param array $guards * @return void * * @throws \\Illuminate\\Auth\\AuthenticationException */ protected function unauthenticated($request, array $guards) { throw new AuthenticationException( &#39;Unauthenticated.&#39;, $guards, $this-&amp;gt;redirectTo($request) ); } /** * Get the path the user should be redirected to when they are not authenticated. * * @param \\Illuminate\\Http\\Request $request * @return string|null */ protected function redirectTo($request) { // }} myapp/app/Http/Middleware/Authenticate.php&amp;lt;?phpnamespace App\\Http\\Middleware;use Illuminate\\Auth\\Middleware\\Authenticate as Middleware;class Authenticate extends Middleware{ /** * Get the path the user should be redirected to when they are not authenticated. * * @param \\Illuminate\\Http\\Request $request * @return string|null */ protected function redirectTo($request) { if (! $request-&amp;gt;expectsJson()) { return &#39;auth/login&#39;; } }}9.3 라라벨 내장 사용자 인증콘솔레어 라티즌 명령을 실행한다. 라라벨 내장 사용자 인증 기능 초기화8버전에서 실패…" }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A810/", "categories": "php", "tags": "", "date": "2021-01-19 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문11. 데이터베이스 시딩데이터베이스 테이블에 데이터를 심는 행위를 시딩이라고 한다.시딩은 서비스 구성에 필요한 기본 데이터, 개발 중에 필요한 데이터, 테스트를 위한 데이터를 빠르게 준비할 때 사용한다. 그리고 라라벨은 클래스 문법으로 데이터 시딩을 자동화할 수 있는 방법을 제공한다.11.1 시더 만들기 시더 클래스 뼈대 코드 만들기$ php artisan make:seeder UsersTableSeederSeeder created successfully.방금 만든 시더 클래스는 database/seeds 디렉터리 아래에 있다. 파일을 열어서 내용을 채워보자 database/seeds/UsersTableSeeder.php&amp;lt;?phpuse Illuminate\\Database\\Seeder;class UsersTableSeeder extends Seeder{ /** * Run the database seeds. * * @return void */ public function run() { App\\User::create([ &#39;name&#39; =&amp;gt; sprintf(&#39;%s %s&#39;,str_random(3),str_random(4)), &#39;email&#39; =&amp;gt; str_random(10).&#39;@example.com&#39;, &#39;password&#39; =&amp;gt; bcrypt(&#39;password&#39;), ]); }}시더 클래스의 이름은 자유롭게 지을 수 있다. 아티즌의 시딩 명령이 시더 클래스의 run() 메서드를 실행한다. 따라서 시딩 로직을 run() 안에 넣어야 한다. str_random(int $length = 16)라라벨 도우미 함수. $length 바이트짜리 랜덤 문자열을 반환한다. sprintf(string $format, mixed $args = null)php 내장함수. sprintf 함수 대신 str_random(3).’ ‘.str_random(4)와 같이 바꾸어 쓸 수 있다.이제 아티즌 멸령줄로 시딩을 하고, 데이터베이스에서 결과를 확인한다. 데이터베이스 시더 실행$ php artisan db:seed --class=UsersTableSeederDatabase seeding completed successfully.11.2 모델 팩토리모델 팩토리는 더미 데이터를 빠르게 만들기 위한 도구다. 팅커 콘솔로 모델 팩토리를 이용해 보자. 모델 팩토리 맛보기$ php artisan tinkerPsy Shell v0.9.12 (PHP 7.3.11 — cli) by Justin Hileman&amp;gt;&amp;gt;&amp;gt; factory(App\\User::class)-&amp;gt;make();=&amp;gt; App\\User {#3198 name: &quot;Jefferey Pouros&quot;, email: &quot;helga.will@example.net&quot;, email_verified_at: Illuminate\\Support\\Carbon @1612358212 {#3194 date: 2021-02-03 13:16:52.342677 UTC (+00:00), }, }&amp;gt;&amp;gt;&amp;gt; factory(App\\User::class)-&amp;gt;make([&#39;name&#39;=&amp;gt;&#39;Foo&#39;]);=&amp;gt; App\\User {#3207 name: &quot;Foo&quot;, email: &quot;brad.schowalter@example.com&quot;, email_verified_at: Illuminate\\Support\\Carbon @1612358244 {#3208 date: 2021-02-03 13:17:24.870220 UTC (+00:00), }, }&amp;gt;&amp;gt;&amp;gt; 위 명령은 실행할 때마다 다른 값을 출력한다.factory(string $class, int $amount = 1)는 도우미 함수다. $amount 인자는 생략할 수 있다. $amount 인자를 쓰면 지정된 수 만큼의 $class 인스턴스를 만든다.make(array $attributes = []) 메서드는 모델 팩토리가 임의로 채운 값을 이용해서 새로운 모델 인스턴스를 만든다. $attributes 인자를 넘기면 임의 값을 오버라이드할 수 있다11.2.1 시더 수정make() 메서드는 모델 인스턴스를 만들기만 한다. 모델을 데이터베이스에 저장하려면 create(array $attributes = []) 메서드를 사용한다. 모델 팩토리를 이용하여 앞서 만든 시더 클래스를 수정하다. database/seeds/UsersTableSeeder.php```php&amp;lt;?phpuse Illuminate\\Database\\Seeder;class UsersTableSeeder extends Seeder{ /** * Run the database seeds. * * @return void */ public function run() { factory(App\\User::class, 5)-&amp;gt;create(); }}아티즌 명령줄로 시딩을 하면(php artisan db:seed) users 테이블에 다섯 명의 새로운 사용자가 만들어진다.#### 11.2.2 모델 팩토리 추가모덾 팩토리는 users 테이블 스키마를 어떻게 알았을까? 프레임워크 어딘가에서 모델 팩토리를 선언하고 있지는 않을까? 혹 여러분의 모델 팩토리가 아래와 다르다면 반드시 수정하기 바란다.&amp;gt; database/factories/UserFactory.php```php&amp;lt;?php/** @var \\Illuminate\\Database\\Eloquent\\Factory $factory */use App\\User;use Illuminate\\Support\\Str;use Faker\\Generator as Faker;/*|--------------------------------------------------------------------------| Model Factories|--------------------------------------------------------------------------|| This directory should contain each of the model factory definitions for| your application. Factories provide a convenient way to generate new| model instances for testing / seeding your application&#39;s database.|*/$factory-&amp;gt;define(User::class, function (Faker $faker) { return [ &#39;name&#39; =&amp;gt; $faker-&amp;gt;name, &#39;email&#39; =&amp;gt; $faker-&amp;gt;safeEmail, &#39;password&#39; =&amp;gt; bcrypt(&#39;password&#39;), // password &#39;remember_token&#39; =&amp;gt; Str::random(10), ];}); ModelFactory.php, $factory이 파일은 라우팅 정의처럼 다른 클래스가 참조하기 위해 사용하는 파일이다. 이 파일에는 $factory라 변수가 이미 선언되어 있다. 이 변수는 Illuminate\\Database\\Eloquent\\Factory 클래스의 인스턴스라 define(string $class, callable $attribute ) 메서드를 쓸 수 있다. define() 메서드의 첫 번째 인자는 모델 이름이며, 두 번쩨 인자는 콜백이다. $faker콜백은 Faker\\Generator $faker 인스턴스를 인자로 받고 배열을 반환한다. 콜백 안에서는 인자로 받은 $faker 변수의 메서드를 이용해서 모델 프로퍼티에 채울 임의의 값을 연관 배열로 만들어 반환한다. $faker 의 메서드들은 fzaninotto/faker 문서에서 확인할 수 있다(이 컴포넌트는 composer.json에 의존성으로 선언되어 있다.) Article 모델 팩토리를 정의하고 새로운 시더를 만들자. user_id 열이 없다는 점을 눈여겨보자. 아래의 코드를 보면 $faker-&amp;gt;dateTimeThisMonth;는 그 뜻을 직관적으로 알 수 있다. database/factories/UserFactory.php &amp;lt;?php/** @var \\Illuminate\\Database\\Eloquent\\Factory $factory */use App\\User;use Illuminate\\Support\\Str;use Faker\\Generator as Faker;/*|--------------------------------------------------------------------------| Model Factories|--------------------------------------------------------------------------|| This directory should contain each of the model factory definitions for| your application. Factories provide a convenient way to generate new| model instances for testing / seeding your application&#39;s database.|*/$factory-&amp;gt;define(User::class, function (Faker $faker) { return [ &#39;name&#39; =&amp;gt; $faker-&amp;gt;name, &#39;email&#39; =&amp;gt; $faker-&amp;gt;safeEmail, &#39;password&#39; =&amp;gt; bcrypt(&#39;password&#39;), // password &#39;remember_token&#39; =&amp;gt; Str::random(10), ];});$factory-&amp;gt;define(App\\Article::class, function (Faker $faker) { $date = $faker-&amp;gt;dateTimeThisMonth; return [ &#39;title&#39; =&amp;gt; $faker-&amp;gt;sentence(), &#39;content&#39; =&amp;gt; $faker-&amp;gt;paragraph(), &#39;created_at&#39; =&amp;gt; $date, &#39;updated_at&#39; =&amp;gt; $date, ];}); articles 테이블 시더 뼈대 코드 만들기$ php artisan make:seeder ArticlesTableSeederSeeder created successfully. database/seeds/ArticlesTableSeeder.php&amp;lt;?phpuse Illuminate\\Database\\Seeder;class ArticlesTableSeeder extends Seeder{ /** * Run the database seeds. * * @return void */ public function run() { $users = App\\User::all(); $users-&amp;gt;each(function($user){ $user-&amp;gt;articles()-&amp;gt;save( factory(App\\Article::class)-&amp;gt;make() ); }); }} $users-&amp;gt;each( … );모델 팩토리에 user_id 정의가 없으므로 사용자와의 관계를 이용해서 포럼 글을 만든다. $users 변수에 사용자 컬렉션을 담고, 컬렉션을 순회하면서 포럼 글을 만드는 식으로 짰다. 엘로퀀트 컬렉션에서 쓸 수 있는 each 메서드를 이용했는데, foreach($users as $user){ … } 를 사용해도 무방하다. $user-&amp;gt;articles()-&amp;gt;save( … );make() 메서드는 새로운 모델 인스턴스를 반환하고 데이터베이스에 저장하지는 않는다. 방금 만든 모델 인스턴스는 sava(\\Illuminate\\Database\\Eloquent\\Model $model) 메서드의 인자로 대입되었다. save() 메서드는 create(array $attributes = []) 와 같은 일을 하는데, 받을 수 있는 인자의 타입만(객체와 배열) 다르다.11.3 마스터 시더모델마다 아티즌 시딩 명령을 수행하는 것은 번거롭다. 라라벨은 시더 클래스를 등록할 수 있는 마스터 시더 클래스를 제공한다. 이 레지스트리가 필요한 이유는 시딩의 순서 때문이다. 마이그레이션할 때 외래 키와 연결할 다른 테이블의 열이 없으면 오류가 발생했다. 시딩도 마찬가지다. database/seeds/DatabaseSeeder.php&amp;lt;?phpuse Illuminate\\Database\\Seeder;use Illuminate\\Support\\Facades\\DB;class DatabaseSeeder extends Seeder{ /** * Seed the application&#39;s database. * * @return void */ public function run() { if (config(&#39;database.default&#39;) !== &#39;sqlite&#39;){ DB::statement(&#39;SET FOREIGN_KEY_CHECKS=0&#39;); } App\\User::truncate(); $this-&amp;gt;call(UsersTableSeeder::class); App\\Article::truncate(); $this-&amp;gt;call(ArticlesTableSeeder::class); if (config(&#39;database.default&#39;) !== &#39;sqlite&#39;){ DB::statement(&#39;SET FOREIGN_KEY_CHECKS=1&#39;); } }}아티즌 명령중로 시딩하고, 테이블에서 결과를 확인하자. 데이터베이스 시딩$ php artisan db:seedSeeding: UsersTableSeederSeeding: ArticlesTableSeederDatabase seeding completed successfully. config(‘database.default’)mysql을 반환한다. config/database.php 파일에서 default 키에 할당된 값을 읽어오는 구문이다. 데이터베이스 마이그레이션에서 FOREIGN_KEY_CHECKS를 본 적이 었다. 데이터를 변경 할 때 외래 키 체크를 잠시 꺼두기 위한 데이터베이스 구문이다. SQLite 데이터베이스는 이 구문을 지원하지 않기 때문에 예외 처리한 것이다. FOREIGN_KEY_CHECKS 설정을 끄지 않고 시딩을 실행하면 Illuminate\\database\\QureyException 이 발생한다. 시딩이 끝났으면 다시 켜야 한다 truncate()이 메서드는 테이블에 담긴 모든 데이터를 버린다. 데이터를 지운다는 측면에서 delete()메서드와 같지만, 이 메서드는 기본 키를 1부터 재배열한다는 점이 다르다. call(string $class)이 메서드는 $class::run() 메서드의 본문을 실행하고 콜솔에 결과를 출력한다. call() 메서드는 부모 클래스에서 찾을 수 있다. 11.4 마이그레이션과 시딩 마이그레이션과 시딩 한 번에 실행하기 $ php artisan migrate:refreshh --seed " }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A809/", "categories": "php", "tags": "", "date": "2021-01-19 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문10. 엘로퀀트 ORM10.1 일대다 관계사용자(일)는 어러 개의 포럼 글(다)을 쑬 수 있고, 특정 포럼 글은 항상 만든 사람이 있다. 이러한 관계를 데이터베이스 시스템 용어로 일대다 관계라고 표현한다. 마이그레이션 클래스 뼈대 코드 만들기$ php artisan make:migration create_articles_table --create=article /database/migrations/2014_10_12_000000_create_users_table.php&amp;lt;?phpuse Illuminate\\Support\\Facades\\Schema;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Database\\Migrations\\Migration;class CreateUsersTable extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::create(&#39;users&#39;, function (Blueprint $table) { $table-&amp;gt;bigIncrements(&#39;id&#39;); $table-&amp;gt;string(&#39;name&#39;); $table-&amp;gt;string(&#39;email&#39;)-&amp;gt;unique(); $table-&amp;gt;timestamp(&#39;email_verified_at&#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&#39;password&#39;); $table-&amp;gt;rememberToken(); $table-&amp;gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(&#39;users&#39;); }} database/migrations/2021_01_25_115104_create_articles_table.php&amp;lt;?php&amp;lt;?phpuse Illuminate\\Support\\Facades\\Schema;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Database\\Migrations\\Migration;class CreateArticlesTable extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::create(&#39;articles&#39;, function (Blueprint $table) { $table-&amp;gt;increments(&#39;id&#39;); $table-&amp;gt;unsignedBigInteger(&#39;user_id&#39;)-&amp;gt;index(); $table-&amp;gt;string(&#39;title&#39;); $table-&amp;gt;text(&#39;content&#39;); $table-&amp;gt;timestamps(); $table-&amp;gt;foreign(&#39;user_id&#39;)-&amp;gt;references(&#39;id&#39;)-&amp;gt;on(&#39;users&#39;) -&amp;gt;onUpdate(&#39;cascade&#39;)-&amp;gt;onDelete(&#39;cascade&#39;); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(&#39;articles&#39;); }} unsigned()양의 정수로 열 값을 제한한다. 외개키 열은 양의 정수 제약조건을 서선하는 게 좋다. foreign(string|array $columns)테이블끼리 외래 키 관계를 연결한다. articles.user_id 열은 users.id 열을 참조한다는 의미다. onUpdate(‘cascade’)와 onDelete(‘cascade’)는 users.id 열이 변경되거나 삭제될 때의 동작 옵션을 정의한 것이다. NOTE테이블 간의 관계를 표현할 때의 관례테이블이름_열이름_foreign 관계 이름이 생성된다. 예제에서는 article_user_id_foreign란 이름으로 만들어 진다. troubleshooting외래키로 관계가 연결되는 키의 쌍은 같은 타입이어야지만 마이그레이션에서 오류가 발생하지 않는다.(예 : string user_id 의 외래키는 같은 string 타입의 키)마이그레이션은 실행해 본다 마이그레이션 실행$ php artisan migrate10.1.1 관계 연결이제 모델끼리 관계를 표현하다. Article 모델을 만들고 관계를 표현하는 users() 메서드를 만들었다(대향 할당을 허용하기 위해 $fillable 프로퍼티 값도 채운다) Article 모델 뼈대 코드 만들기$ php artisan make:model Article /app/Models/Article.php&amp;lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;use Illuminate\\Database\\Eloquent\\Model;class Article extends Model{ protected $fillable = [&#39;title&#39;,&#39;content&#39;]; public function user() { return $this-&amp;gt;belongsTo(User::class); } use HasFactory;}새로만든 user() 메서드를 소리 나는 대로 읽어보자. this belongsto user class(이것은 user클래스에 속해 있습니다.) this 는 Article이다 읽을수 있는 코드라는 의미를 표현한것 같다user에서 바라보는 Article도 필요하다. /app/Models/User.php&amp;lt;?phpnamespace App\\Models;use Illuminate\\Contracts\\Auth\\MustVerifyEmail;use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;use Illuminate\\Foundation\\Auth\\User as Authenticatable;use Illuminate\\Notifications\\Notifiable;class User extends Authenticatable{ use HasFactory, Notifiable; public function articles() { return $this-&amp;gt;hasMany(Article::class); }}똑같이 articles() 메서드를 소리 나는 대로 읽어 보자. This hasMany Article class ( 이것은 여러 개의 Article class를 가지고 있습니다.) this는 User이다10.1.2 관계 확인이제 팅커 콘솔에서 관계를 이용해 새로운 Article 모델을 만든다 모델 간의 관계를 이용해 새로운 레코드 만들기$ php arisan tinker&amp;gt;&amp;gt;&amp;gt; App\\User::find(1)-&amp;gt;articles()-&amp;gt;create([ &#39;title&#39;=&amp;gt;&#39;first title&#39;, &#39;content&#39;=&amp;gt;&#39;first content&#39;, ]);=&amp;gt; App\\Article {#4108 title: &quot;first title&quot;, content: &quot;first content&quot;, user_id: 1, updated_at: &quot;2021-02-01 14:43:20&quot;, created_at: &quot;2021-02-01 14:43:20&quot;, id: 1, }위 사용법이 ORM 사용법이다/.App\\User::find(1)까지는 1번 기본 키를 가진 User 인스턴스를 방환한다는 것을 이미 알고 있다. 거기에 Articles() 관계를 체인하고, create() 메서드로 새로운 Acticle 모델을 만들었다. user_id 값은 넣지 않았지만, 데이터베이스를 확인해 보면 articles.user_id열에 값이 기록된 것을 확인할 수 있다. 모델 간의 관계를 이용한 쿼리&amp;gt;&amp;gt;&amp;gt; App\\User::find(1)-&amp;gt;articles()-&amp;gt;get();=&amp;gt; App\\Article {#4111 id: 1, user_id: 1, title: &quot;first title&quot;, content: &quot;first content&quot;, created_at: &quot;2021-02-01 14:42:46&quot;, updated_at: &quot;2021-02-01 14:42:46&quot;, }&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; App\\User::find(1)-&amp;gt;articles()-&amp;gt;first();=&amp;gt; App\\Article {#4111 id: 1, user_id: 1, title: &quot;first title&quot;, content: &quot;first content&quot;, created_at: &quot;2021-02-01 14:42:46&quot;, updated_at: &quot;2021-02-01 14:42:46&quot;, }&amp;gt;&amp;gt;&amp;gt; 이 예제를 통해 두 모델 간의 관계가 어떻게 상호 동작하는지 이해 할수 있다.10.2 다대다 관계 연결포럼 글이 한개 이사으이 태그를 가지는 시나리오를 사정해 보자. 그런데 포람 글 1번에 태그 1번을 할당했다고 해서, 포럼 글 2번에 대그 1번을 할당할 수 없는 것은 아니다. 두 모델은 다대다 관계를 현성한다.데이터베이스 시스템에서 다대다 관계를 표현하기 위해서는 총 세 개의 테이블이 필요하다. 우선 시나리오에는 articles, article_tag, tag 테이블이 필요하다. 이제 마이그레이션알 만들어 본다 다대다 관계 실습을 위한 마이그레이션 클래스 만들기$ php artisan make:migration create_tags_table --create=tagsCreated Migration: 2021_02_01_145454_create_tags_table$ php artisan make:migration create_article_tag_table --create=article_tagCreated Migration: 2021_02_01_145550_create_article_tag_table myapp/database/migrations/2021_02_01_145454_create_tags_table.php&amp;lt;?phpuse Illuminate\\Support\\Facades\\Schema;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Database\\Migrations\\Migration;class CreateTagsTable extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::create(&#39;tags&#39;, function (Blueprint $table) { $table-&amp;gt;increments(&#39;id&#39;); $table-&amp;gt;string(&#39;name&#39;); $table-&amp;gt;string(&#39;slug&#39;)-&amp;gt;index(); $table-&amp;gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(&#39;tags&#39;); }} /myapp/database/migrations/2021_02_01_145550_create_article_tag_table.php&amp;lt;?phpuse Illuminate\\Support\\Facades\\Schema;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Database\\Migrations\\Migration;class CreateArticleTagTable extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::create(&#39;article_tag&#39;, function (Blueprint $table) { $table-&amp;gt;increments(&#39;id&#39;); $table-&amp;gt;integer(&#39;article_id&#39;)-&amp;gt;unsigned(); $table-&amp;gt;integer(&#39;tag_id&#39;)-&amp;gt;unsigned(); $table-&amp;gt;foreign(&#39;article_id&#39;)-&amp;gt;references(&#39;id&#39;)-&amp;gt;on(&#39;articles&#39;)-&amp;gt;onDelete(&#39;cascade&#39;); $table-&amp;gt;foreign(&#39;tag_id&#39;)-&amp;gt;references(&#39;id&#39;)-&amp;gt;on(&#39;tags&#39;)-&amp;gt;onDelete(&#39;cascade&#39;); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(&#39;article_tag&#39;); }}article_tag 테이블에 timestamps() 메서드는 넣지 않았다.10.2.1 관계연결모델을 만들고 내용을 채워 보자 Tag 모델 뼈대 코드 만들기$ php artisan make:model Tag app/Tag.php&amp;lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Tag extends Model{ protected $fillable =[&#39;name&#39;,&#39;slug&#39;]; // public function articles() { return $this -&amp;gt; belongsToMany(Article::class); }}Article 모델과 관계를 맺기 위해서 belongsToMany(string $related, string $table= null, string $foreignKey = null, string $otherKey = null) 메서드를 이용했다. 소리가나는 대로 읽으면 “This belong to many article”(나는 여러개의 article에 속합니다)이다이번에서는 Articel 모델에 반대 관계를 만들어 보자 app/Article.php&amp;lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Article extends Model{ protected $fillable =[&#39;title&#39;,&#39;content&#39;]; public function user() { return $this-&amp;gt;belongsTo(User::class); } public function tags() { return $this-&amp;gt;belongsToMany(Tag::class); }}여기서도 같은 belongsToMany() 메서드를 사용한다. 마찬가지로 소리내어 읽으면 “This belong to many tag”(나는 여러 개의 tag에 속합니다.)이다10.2.2 관계 확인팅커 콜솔에서 실험할 태그와 포럼 글을 만들자. 다대다 관계 테스트를 위한 데이터 만들기&amp;gt;&amp;gt;&amp;gt; App\\Tag::create([... &#39;name&#39;=&amp;gt;&#39;Foo&#39;,... &#39;slug&#39;=&amp;gt;&#39;foo&#39;,... ]);=&amp;gt; App\\Tag {#3959 name: &quot;Foo&quot;, slug: &quot;foo&quot;, updated_at: &quot;2021-02-01 15:32:51&quot;, created_at: &quot;2021-02-01 15:32:51&quot;, id: 1, }&amp;gt;&amp;gt;&amp;gt; App\\Tag::create([ &#39;name&#39;=&amp;gt;&#39;Bar&#39;, &#39;slug&#39;=&amp;gt;&#39;bar&#39;, ]);=&amp;gt; App\\Tag {#4108 name: &quot;Bar&quot;, slug: &quot;bar&quot;, updated_at: &quot;2021-02-01 15:33:19&quot;, created_at: &quot;2021-02-01 15:33:19&quot;, id: 2, }&amp;gt;&amp;gt;&amp;gt; App\\Tag::all();=&amp;gt; Illuminate\\Database\\Eloquent\\Collection {#3894 all: [ App\\Tag {#3179 id: 1, name: &quot;Foo&quot;, slug: &quot;foo&quot;, created_at: &quot;2021-02-01 15:32:51&quot;, updated_at: &quot;2021-02-01 15:32:51&quot;, }, App\\Tag {#3164 id: 2, name: &quot;Bar&quot;, slug: &quot;bar&quot;, created_at: &quot;2021-02-01 15:33:19&quot;, updated_at: &quot;2021-02-01 15:33:19&quot;, }, ], }&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; App\\User::find(1)-&amp;gt;articles()-&amp;gt;create([... &#39;title&#39;=&amp;gt; &#39;Second title&#39;,... &#39;content&#39;=&amp;gt;&#39;Second title&#39;,... ]);=&amp;gt; App\\Article {#4103 title: &quot;Second title&quot;, content: &quot;Second title&quot;, user_id: 1, updated_at: &quot;2021-02-01 15:36:09&quot;, created_at: &quot;2021-02-01 15:36:09&quot;, id: 7, }&amp;gt;&amp;gt;&amp;gt; 포럼 글에 태그를 부여해 보자 다대다 관계 테스트&amp;gt;&amp;gt;&amp;gt; $article = App\\Article::find(1);=&amp;gt; App\\Article {#4118 id: 1, user_id: 1, title: &quot;first title&quot;, content: &quot;first content&quot;, created_at: &quot;2021-02-01 14:42:46&quot;, updated_at: &quot;2021-02-01 14:42:46&quot;, }&amp;gt;&amp;gt;&amp;gt; $article-&amp;gt;tags()-&amp;gt;sync([1,2]);=&amp;gt; [ &quot;attached&quot; =&amp;gt; [ 1, 2, ], &quot;detached&quot; =&amp;gt; [], &quot;updated&quot; =&amp;gt; [], ]&amp;gt;&amp;gt;&amp;gt; $article-&amp;gt;tags-&amp;gt;pluck(&#39;name&#39;,&#39;id&#39;);=&amp;gt; Illuminate\\Support\\Collection {#4105 all: [ 1 =&amp;gt; &quot;Foo&quot;, 2 =&amp;gt; &quot;Bar&quot;, ], } 1번 Article 인스턴스를 얻은 후, tags() 관계를 체인했다. 이어서 여기에 sync(\\Illuminata\\databe\\Eloquent\\Collection array $ids) 메서드를 체인했다. 우리는 1번 포험 글에는 1번과 2번 태스를 연결 했다. attach()와 detach() 메서드가 있지만, 나는 sync()메서드를 주로 쓴다. 어떤 포럼 글에서 태그 1번과 2번을 이미 할당했는데, attach([2])메서드를 호출하면, 중복 레코드가 생길 수 있다. attach()나 detach()메서드는 호출할 때마다 레코드가 이미 있는지 확인을 해야한다.중복 문제를 피라기 위해서는 피벗 테이블(articlea_tag) 의 article_id 와 tag_id 열을 동시에 기본 키로 지정하는 방법도 있다. 하지만 중복된 레코드 삽입 요청이 들어오면 데이터베이스 오류가 발생한다. 그러므로 중복 레코드를 피하는 안정함을 얻는 대신 자유도를 버여햐만 한다.반면, sync() 메서드는 테이블에 저장된 값보다 메서드 인자로 넘어온 값을 항상 우선한다. 레코드를 삭제하고 인장로 받은 값을 다시 입력하기 때문에 쉽게 최신 상태를 유지할 수 있다.10.2.3 다대다 관계 작동 원리피벗 테이블에 답이 있다. aritcle_id 열은 article.id 열의 외래 키, tag_id 는 tags.id 열의 외래 키로 동작한다. 피벗 테이블이 두 테이블 간의 관계를 연결해 주는 것이다. article_tag 피벗 테이블mysql&amp;gt; select * from article_tag;+----+------------+--------+| id | article_id | tag_id |+----+------------+--------+| 1 | 1 | 1 || 2 | 1 | 2 |+----+------------+--------+2 rows in set (0.00 sec)" }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A807/", "categories": "php", "tags": "", "date": "2021-01-19 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문8. 컨트롤러8.1 컨트롤러 만들기라우트 파일을 열어, / 라우트의 처리 로직을 ‘WelcomeController@index’로 연결 한다. routes/web.phpRoute::get(&#39;/&#39;, &#39;WelcomeController@index&#39;);아티즌 명령줄 인터페이스로 WelcomeController를 만든다. 만든 컨트롤러는 app/Http/Controller 디렉터리 아래에 있다. code$ php artisan make:controller WelcomeController# Controller created successfully.NOTE라라벨 5.1 의 make:controller 명령은 리소스 컨트롤라가 기본값이라 빈 컨트롤러를 만드려면 –plain 옵션을 부여해야 한다. 라라벨 5.2와 5.3은 반대로 기본값이 빈 컨트롤러다php artisan make:controller WelconmeController --plainindex 메서드에 블레이드때 사용한 뷰를 반환한다. (참고로 다른 부분에서도 사용해야 하기 때문에 public 선언을 해야 한다)8.2 RESTFul 라우트와 컨트롤러초기 URL을 보는 관덤은 두가지였다.하나는 /getDog?id=1 처럼 파라미터를 가지고 원격 컴퓨터에 있는 API를 호출로 보는 관점이다.이를 RPC(Remote Procedure Call)이라고 한다.다른 하나는 URL을 원격 컴퓨터의 리소스로 생각하는 관점이다. 원격컴퓨터의 리소스는 시간에 따라 그 상태가 변할 수 있는데, 클라이언트와 서버가 상태를 교환하기 때문에 REST(REpresentational State Transfer)라고 부른다. REST는 URL 경로를 명사로 사용한다. 구글을 비롯한 인터넷 거물들의 웹 API를 보면 모두 REST 원칙을 따른다는 것을 알 수 있다.8.2.1 RESTful 리소스 컨트롤러 만들기RESTfull 리소스 컨트롤러는 REST 원칙에 따라 URL을 컨트롤러 메서드에 자동으로 련결한다. –resource 옵션을 줘서 새로운 컨트롤러를 생성한다. 컨트롤러 뼈대 코드 만들기$ php artisan make:controller ArticlesConroller --resourceController created successfully.NOTE라라벨 5.1$ php artisan make:controller ArticlesConroller새로운 라우트를 정의할 텐데 그간 봐왔던 Route::get()이 아니라 Route::resource()를 쓴다는 점을 주목하자. routes/web.phpRoute::resource(&#39;articles&#39;, &#39;ArticlesController&#39;);8.2.2 RESTfull 리소스 컨트롤러 개요아지튼 명령어로 라우트를 확인해 본다 라우트 목록 확인$ php artisan route:list+--------+----------+----------+------+---------+------------+| Domain | Method | URI | Name | Action | Middleware |+--------+----------+----------+------+---------+------------+| | GET|HEAD | / | | Closure | web || | GET|HEAD | api/user | | Closure | api || | | | | | auth:api |+--------+----------+----------+------+---------+------------+ 명칭 설명 Domain URL 경로뿐만 아니라 도메인에 따라 라우팅을 분리할 수 있다 Method HTTP 요청 메서드 URI 경로 Name 라우트 이름 Action 라우팅을 처리할 컨트롤라와 메서드 Middleware 이 라우팅에 적용할 전역 또는 HTTP 미들웨어 REST 원칙에 맞춘 URL과 컨트롤러 메서드 HTTP메서드 URL 경로 HTTP 메서드 오버라이드 처리할 컨트롤러 설명 GET articles   ArticlesConroller@index Article 모델 컬렉션 조회 POST articles   ArticlesConroller@store 새 Article 모델 만들기 GET articels/create   ArticlesConroller 새 Article 모델 프로퍼티 값을 입력 받기 위한 폼 GET articles/{article}   ArticlesConroller@show {article} 기본키 값을 가진 Articel 모델 조회 POST articles/{article} _method=PUT ArticlesConroller@update {article} 기본 키값을 가진 Article모델의 프로터티값을 수정 POST articles/{article} _method=DELETE ArticlesConroller@destroy {article} 기본 값을 가진 Article 모델 삭제 GET articles/{article}/edit   ArticlesConroller@edit {article} 기본 값을 가진 Article 모델 프로퍼티 수정값을 받기 위한 폼 8.2.3 RESTfull 리소스 컨트롤러 테스트앞서 만든 ArticlesConroller를 수정한다 __METHOD__ 는 자신을 포함한 메서드 이름을 담고 있는 메직 상수다. app/Http/Controllers/ArticlesController.php&amp;lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class ArticlesController extends Controller{ public function index() { return __METHOD__.&quot;은 아티클 컬렉션을 조회합니다.&quot;; } public function create() { return __METHOD__.&quot;은 아티클 컬렉션을 만들기 위한 폼을 담은 뷰를 반환합니다.&quot;; } public function store(Request $request) { return __METHOD__.&quot;은 사용자릐 입력한 폼 데이터로 새로운 아티클 컬렉션을 만듭니다.&quot;; } public function show($id) { return __METHOD__.&quot;은 다음 기본 키를 가진 아티클 모델을 조회합니다.&quot;.$id; } public function edit($id) { return __METHOD__.&quot;은 다음 기본 키를 가진 아티클 모델을 수정하기 위한 폼을 담은 뷰를 반환합니다.&quot;.$id; } public function udpate(Request $request, $id) { return __METHOD__.&quot;은 사용자의 입력 폼 데이터로 다음 기본키를 가진 아티클 모델을 수정합니다.&quot;.$id; } public function destroy($id) { return __METHOD__.&quot;은 다음 기본 키를 가진 아티클 모델을 삭제합니다.&quot;.$id; }} toubleshooting라라벨 8버전 부터는 위 코드는 에러가 발생한다/app/Providers/RouteServiceProvider.php 로 가서 29번라인에 protected $namespace = &#39;App\\\\Http\\\\Controllers&#39;; 주석을 해제하자/artticle , /article/1 를 호출해 보자.8.2.4 CSRF 공격 방어 기능위 경로를 POST 형식으로 호출시 오류가 발생한다.라라벨을 데이터를 변경하는 POST 동작에 대해서는 토큰을 요구한다. 이러한 보호 동작은 아래와 같다 GET /article/create 요청에 ArticleController@create 메서드에서 숨은 필드로 _token 값을 담아 새로운 모델 만들기 폼(뷰)를 응답한다. 브라우저가 _token 필드를 HTTP 묘청 본문에 담아 POST articles 요청을 한다. POST /article 라우팅이 컨트롤러에게 작업을 할당하기 전에 web 미들웨어 그룹을 실행한다. 이 미들웨어 그룹에는 CSRF 토큰 검사가 포함되어 있는데, 폼을 응답했던 세션에서 만든 _token과 지금 HTTP 요청으로 받은 _token이 같은지 확인한다. CSRF 토큰 검사를 통화하면 ArticleController@store 메서드에게 작업을 위함하고, 그렇지 않으면 TokenMismatchException을 던진다.우리는 테스트를 위해 위 기능을 잠시 끈다 app/Http/Middleware/VerifyCsrfToken.php&amp;lt;?phpnamespace App\\Http\\Middleware;use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware;class VerifyCsrfToken extends Middleware{ /** * The URIs that should be excluded from CSRF verification. * * @var array */ protected $except = [ // &#39;articles&#39;, &#39;articles/*&#39; ];}8.2.5 메소드 오버라이드POST /article/1 요청시, 수정과 삭제 라우트를 구분하지 못해 MethodNotAllowedHttpException 가 발생한다. 원칙적으로는 수정은 PUT 또는 PATCH , 삭제는 DELETE 이지만 보안등을 이유로 비허용한 곳이 많다. 그런 경우, body에 _method를 키로 PUT을 값으로 전달하면 된다.8.2.6 RESTful 라우트 보충우리가 배운 메서드 외에도 다음과 같은 라우트 메서드가 있다. Route::post(string $url , \\Closure array string $action) Route::put(string $url , \\Closure array string $action) Route::patch(string $url , \\Closure array string $action) Route::delete(string $url , \\Closure array string $action) Route::options(string $url , \\Closure array string $action) " }, { "title": "자바스터디 10주차", "url": "/posts/whiteship-study-10week/", "categories": "study", "tags": "", "date": "2021-01-18 00:00:00 +0900", "snippet": "아래 내용은 https://github.com/Yadon079/yadon079.github.io/blob/master/_posts/dev/java/study%20halle/2021-01-18-week-10.md 내용을 차용했음을 알려드립니다.GOAL자바의 멀티쓰레드 프로그래밍에 대해 학습한다.학습할 것 Thread 클래스와 Runnable 인터페이스 쓰레드의 상태 쓰레드의 우선순위 Main 쓰레드 동기화 데드락Thread 클래스와 Runnable 인터페이스프로세스와 쓰레드   프로세스(process)란 간단히 말해서 ‘실행 중인 프로그램(program)’이다. 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)를 할당받아 프로세스가 된다.프로세스는 프로그램을 수행하는 데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있으며 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 바로 쓰레드이다.모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하며, 둘 이상의 쓰레드를 가진 프로세스를 멀티쓰레드 프로세스(multi-threaded process)라고 한다.공장(프로세스)에서 일하는 일꾼(쓰레드)라고 생각하면 된다.하나의 프로세스가 가질 수 있는 쓰레드의 개수는 제한되어 있지 않다. 하지만 쓰레드가 작업을 수행하는데 개별적인 메모리 공간(호출스택)을 필요로 하기 때문에 프로세스의 메모리 한계에 따라 생성할 수 있는 쓰레드의 수가 결정된다.멀티태스킹과 멀티쓰레딩   우리가 사용하는 대부분의 OS는 멀티태스킹(multi-tasking, 다중작업)을 지원하기 때문에 여러 개의 프로세스가 동시에 실행될 수 있다.멀티쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 수행하는 것이다. CPU의 코어(core)가 한 번에 단 하나의 작업만 수행할 수 있으므로, 실제로 동시에 처리되는 작업의 개수는 코어의 개수와 일치한다. 그러나 처리해야 하는 쓰레드의 수는 항상 코어의 수보다 많기 때문에 각 코어가 짧은 시간 동안 여러 작업을 번갈아 가며 수행함으로써 여러 작업들이 모두 동시에 수행되는 것처럼 보이게 한다.프로세스의 성능이 단순히 쓰레드의 개수에 비례하는 것은 아니며, 하나의 쓰레드를 가진 프로세스 보다 두 개의 쓰레드를 가진 프로세스가 오히려 더 낮은 성능을 보일 수도 있다.쓰레드의 구현과 실행   쓰레드를 구현하는 방법은 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법, 모두 두 가지가 있다. 어느 쪽을 선택해도 별 차이는 없지만 Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없기 때문에, Runnable 인터페이스를 구현하는 방법이 일반적이다.▶Thread 클래스를 상속class MyThread extends Thread { @Override public void run() { ... } // Thread 클래스의 run()을 오버라이딩}▶Runnable 인터페이스를 구현class MyThread implements Runnable { public void run() { ... } // Runnable 인터페이스의 run()을 구현}Runnable 인터페이스는 오로지 run()만 정의되어 있는 간단한 인터페이스이다. Runnable 인터페이스를 구현하기 위해서 해야 할 일은 추상메서드인 run()의 몸통{ }을 만들어 주는 것 뿐이다. public interface Runnable { public abstract void run(); }쓰레드를 구현한다는 것은, 위의 두 방법 중 어떤 것을 선택하든, 쓰레드를 통해 작업하고자 하는 내용으로 run()의 몸통{ }을 채우는 것일 뿐이다.class App { public static void main(String[] args) { ThreadOne t1 = new ThreadOne(); Runnable r = new ThreadTwo(); Thread t2 = new Thread(r); // 생성자 Thread(Runnable Target) t1.start(); t2.start(); }}class ThreadOne extends Thread { @Override public void run() { for(int i = 0; i &amp;lt; 3; i++) { System.out.println(getName()); // 조상인 Thread의 getName()을 호출 } }}class ThreadTwo implements Runnable { public void run() { for(int i = 0; i &amp;lt; 3; i++) { // Thread.currentThread() : 현재 실행 중인 Thread를 반환 System.out.println(Thread.currentThread().getName()); } }}상속받을 때와 구현할 때의 인스턴스 생성 방법이 다르다. ThreadOne t1 = new ThreadOne(); // Thread의 자손 클래스의 인스턴스를 생성 Runnable r = new ThreadTwo(); // Runnable을 구현한 클래스의 인스턴스를 생성 Thread t2 = new Thread(r); // 생성자 Thread(Runnable Target)Runnable 인터페이스를 구현한 경우, Runnable 인터페이스를 구현한 클래스의 인스턴스를 생성한 다음, 이 인스턴스를 Thread 클래스의 생성자의 매개변수로 제공해야 한다.Thread 클래스를 상속받으면, 자손 클래스에서 조상인 Thread 클래스의 메서드를 직접 호출할 수 있지만, Runnable을 구현하면 Thread 클래스의 static 메서드인 currentThread()를 호출하여 쓰레드에 대한 참조를 얻어 와야만 호출이 가능하다. static Thread currentThread() 현재 실행중인 쓰레드의 참조를 반환한다. String getName() 쓰레드의 이름을 반환한다. ▶쓰레드의 이름쓰레드의 이름은 다음과 같은 생성자나 메서드를 통해서 지정 또는 변경할 수 있다. Thread(Runnable target, String name) Thread(String name) void setName(String name)쓰레드의 이름을 지정하지 않으면 ‘Thread-번호’의 형식으로 이름이 정해진다. System.out.println(Thread.currentThread().getName());위 코드는 아래 코드를 한 줄로 쓴 것이라고 생각하면 된다. Thread t = Thread.currentThread(); String name = t.getName(); System.out.println(name);쓰레드의 실행 - start()   쓰레드를 생성했다고 해서 자동으로 실행되는 것은 아니다. start()를 호출해야만 쓰레드가 실행된다. t1.start(); t2.start();사실 start()가 호출되었다고 바로 실행되는 것은 아니고 실행대기 상태에 있다가 자신의 차례가 되어야 실행된다. 물론 실행대기 중인 쓰레드가 하나도 없으면 바로 실행상태가 된다.한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다. 즉, 하나의 쓰레드에 대해 start()가 한 번만 호출될 수 있다는 뜻이다.따라서 쓰레드의 작업을 한 번 더 수행해야 한다면 새로운 쓰레드를 생성한 다음 start()를 호출해야 한다. 만일 하나의 쓰레드에 대해 start()를 두 번 이상 호출하면 실행 시에 IllegalThreadStateException이 발생한다.▶잘못된 호출class App { public static void main(String[] args) { ThreadOne t1 = new ThreadOne(); t1.start(); t1.start(); }}class ThreadOne extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 3; i++) { System.out.println(getName()); } }}▶올바른 호출class App { public static void main(String[] args) { ThreadOne t1 = new ThreadOne(); t1.start(); t1 = new ThreadOne(); // 다시 생성 t1.start(); }}class ThreadOne extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 3; i++) { System.out.println(getName()); } }}쓰레드의 상태   쓰레드 프로그래밍이 어려운 이유는 동기화(synchronization)와 스케쥴링(scheduling)때문이다. 효율적인 멀티쓰레드 프로그램을 만들기 위해서는 보다 정교한 스케쥴링을 통해 프로세스에게 주어진 자원과 시간을 여러 쓰레드가 낭비없이 잘 사용하도록 프로그래밍 해야 한다.쓰레드의 상태쓰레드의 상태는 다음과 같다. NEW 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태 RUNNABLE 실행 중 또는 실행 가능한 상태 BLOCKED 동기화 블럭에 의해서 일시정지된 상태(lock이 풀릴 때까지 기다리는 상태) WAITING, TIMED_WATITING 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은(unrunnable) 일시정지 상태TIMED_WATITING은 일시정지시간이 지정된 경우를 의미한다. TERMINATED 쓰레드의 작업이 종료된 상태 이러한 쓰레드의 상태는 JDK1.5부터 추가된 Thread의 getState() 메서드를 호출해서 확인할 수 있다.쓰레드의 생성부터 소멸까지 쓰레드를 생성하고 start()를 호출하면 바로 실행되는 것이 아니라 실행대기열에 저장되어 차례를 기다린다. 실행대기열은 Queue와 같은 구조로 먼저 실행대기열에 들어온 쓰레드가 먼저 실행된다. 실행대기상태에 있다가 자신의 차례가 되면 실행상태가 된다. 주어진 실행시간이 다되거나 yield()를 만나면 다시 실행대기상태가 되고 다음 차례의 쓰레드가 실행상태가 된다. 실행 중에 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 될 수 있다. I/O block은 입출력작업에서 발생하는 지연상태를 말한다. 지정된 일시정지시간이 다되거나(time-out), notify(), resume(), interrupt()가 호출되면 일시정지상태를 벗어나 다시 실행대기열에 저장되어 차례를 기다린다. 실행을 모두 마치거나 stop()이 호출되면 쓰레드는 소멸된다.단, 무조건 번호 순서대로 쓰레드가 수행되는 것은 아니다.쓰레드의 스케쥴링과 관련된 메서드▶ sleep(long millis) - 일정시간동안 쓰레드를 멈추게 한다.   sleep()은 지정된 시간동안 쓰레드를 멈추게 한다. static void sleep(long millis) static void sleep(long millis, int nanos)세밀하게 값을 지정할 수 있지만 어느 정도의 오차가 발생할 수도 있다.sleep()에 의해 일시정지 상태가 된 쓰레드는 지정된 시간이 다 되거나 interrupt()가 호출되면(InterruptedException 발생), 실행대기 상태가 된다.따라서 sleep()을 호출할 때는 항상 try-catch문으로 예외를 처리해줘야 한다. 매번 try-catch문을 사용하기 번거롭기 때문에, 새로운 메서드로 만들어 사용하기도 한다. void delay(long millis) { try { Thread.sleep(millis) } catch (InterruptedException e) {} }class App { public static void main(String[] args) { ThreadOne th1 = new ThreadOne(); ThreadTwo th2 = new ThreadTwo(); th1.start(); th2.start(); try { th1.sleep(2000); } catch(InterruptedException e) { } System.out.println(&quot;&amp;lt;&amp;lt; main 종료 &amp;gt;&amp;gt;&quot;); }}class ThreadOne extends Thread { @Override public void run() { for(int i = 0; i &amp;lt; 50; i++) { System.out.print(&quot;-&quot;); } System.out.println(&quot;&amp;lt;&amp;lt; th1 종료 &amp;gt;&amp;gt;&quot;); }}class ThreadTwo extends Thread { @Override public void run() { for(int i = 0; i &amp;lt; 50; i++) { System.out.print(&quot;|&quot;); } System.out.println(&quot;&amp;lt;&amp;lt; th2 종료 &amp;gt;&amp;gt;&quot;); }}예제의 결과를 보면 th1, th2, main 순으로 종료되었는데, 아래 코드를 생각하면 조금 의외이다. th1.start(); th2.start(); try { th1.sleep(2000); } catch (InterruptedException e) { } System.out.println(&quot;&amp;lt;&amp;lt; main 종료 &amp;gt;&amp;gt;&quot;);start()를 호출하고 th1.sleep(2000)를 호출하여 th1을 2초동안 일시정지상태로 만들었는데 th1이 가장 먼저 종료되었다.그 이유는 sleep()이 항상 현재 실행 중인 쓰레드에 대해 작동하기 때문에 th1.sleep(2000)으로 호출하여도 실제로 영향을 받는 것은 main 메서드를 실행하는 main 쓰레드이다.그래서 sleep()은 static으로 선언되어 있으며 참조변수를 이용해서 호출하기 보다는 Thread.sleep(2000)과 같이 해야한다.▶ interrupt()와 interrupted() - 쓰레드의 작업을 취소한다.   진행 중인 쓰레드의 작업이 끝나기 전에 취소시켜야할 때가 있다. interrupt()를 사용하면 쓰레드에게 작업을 멈추라고 요청한다. 단지 멈추라고 요청만 하는 것이고 쓰레드를 강제로 종료시키지는 못한다. interrupt()는 그저 쓰레드의 interrupted상태(인스턴스 변수)를 바꾸는 것일 뿐이다.그리고 interrupted()는 쓰레드에 대해 interrupt()가 호출되었는지 알려준다. interrupt()가 호출되지 않았다면 false를, 호출되었다면 true를 반환한다. Thread th = new Thread(); th.start(); ... th.interrupt(); class MyThread extends Thread { public void run() { while(!interrupted()) { ... } } }   isInterrupted()도 쓰레드의 interrupt()가 호출되었는지 확인하는데 사용할 수 있지만, interrupted()와 달리 isInterrupted()는 쓰레드의 interrupt상태를 false로 초기화하지 않는다. void interrupt() 쓰레드의 interrupted상태를 false에서 true로 변경. boolean isInterrupted() 쓰레드의 interrupted상태를 반환. static boolean interrupted() 현재 쓰레드의 interrupted상태를 반환 후, false로 변경. 쓰레드가 sleep(), wait(), join()에 의해 일시정지 상태(WAITING)에 있을 때, 해당 쓰레드에 대해 interrupt()를 호출하면, sleep(), wait(), join()에서 InterruptedException이 발생하고 쓰레드는 실행대기 상태(RUNNABLE)로 바뀐다. 즉, 멈춰있던 쓰레드를 깨워서 실행가능한 상태로 만드는 것이다.▶ suspend(), resume(), stop()   suspend()는 sleep()처럼 쓰레드를 멈추게 한다. suspend()에 의해 정지된 쓰레드는 resume()을 호출해야 다시 실행대기 상태가 된다. stop()은 호출되는 즉시 쓰레드가 종료된다.suspend(), resume(), stop()은 쓰레드의 실행을 제어하는 가장 손쉬운 방법이지만, suspend()와 stop()이 교착상태(deadlock)을 일으키기 쉽게 작성되어있으므로 사용이 권장되지 않는다. 그래서 이 메서드들은 모두 deprecated되었다. Java API문서 stop()을 찾아보면 아래와 같이 Deprecated.라고 적혀있다.void stop(Throwable obj) Deprecated.This method was originally designed to force a thread to stop and throw a given Throwable as an exception. It was inherently unsafe (see stop() for details), and furthermore could be used to generate exceptions that the target thread was not prepared to handle.deprecated의 의미는 ‘전에는 사용되었지만, 앞으로는 사용하지 않을 것을 권장한다’는 의미이다. deprecated된 메서드는 하위 호환성을 위해서 삭제하지 않는 것일 뿐이므로 사용해서는 안 된다.▶ yield() - 다른 쓰레드에게 양보한다.   yield()는 쓰레드 자신에게 주어진 실행시간을 다음 차례의 쓰레드에게 양보(yield)한다. 예를 들어 스케쥴러에 의해 1초의 실행시간을 할당받은 쓰레드가 0.5초의 시간동안 작업한 상태에서 yield()가 호출되면, 나머지 0.5초는 포기하고 다시 실행대기상태가 된다.▶ join() - 다른 쓰레드의 작업을 기다린다.   join()은 자신의 작업 중간에 다른 쓰레드의 작업을 참여(join)시킨다는 의미로 이름 지어진 것이다. 쓰레드 자신이 하던 작업을 잠시 멈추고 다른 쓰레드가 지정된 시간동안 작업을 수행하도록 할 때 사용한다. void join() void join(long millis) void join(long millis, int nanos)시간을 지정하지 않으면, 해당 쓰레드가 작업을 모두 마칠 때까지 기다리게 된다. 작업 중에 다른 쓰레드의 작업이 먼저 수행되어야할 필요가 있을 때 join()을 사용한다. try { th1.join() } catch (InterruptedException e) { }join()도 sleep()처럼 interrupt()에 의해 대기상태에서 벗어날 수 있으며, join()이 호출되는 부분을 try-catch문으로 감싸야 한다. join()은 여러모로 sleep()과 유사한 점이 많은데, sleep()과 다른 점은 join()은 현재 쓰레드가 아닌 특정 쓰레드에 대해 동작하므로 static메서드가 아니라는 것이다.쓰레드의 우선순위   쓰레드는 우선순위(priority)라는 속성(멤버변수)를 가지고 있는데, 이 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라진다. 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 서로 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있다.우선순위 지정하기   쓰레드의 우선순위와 관련된 메서드와 상수는 다음과 같다. void setPriority(int newPriority) // 쓰레드의 우선순위를 지정한 값으로 변경한다. int getPriority() // 쓰레드의 우선순위를 반환한다. public static final int MAX_PRIORITY = 10 // 최대 우선순위 public static final int MIN_PRIORITY = 1 // 최소 우선순위 public static final int NORM_PRIORITY = 5 // 보통 우선순위쓰레드가 가질 수 있는 우선순위의 범위는 1 ~ 10이며 숫자가 높을수록 우선순위가 높다.   쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다. main메서드를 수행하는 쓰레드는 우선순위가 5이므로 main메서드 내에서 생성하는 쓰레드의 우선순위는 자동적으로 5가 된다.class App { public static void main(String[] args) { ThreadOne th1 = new ThreadOne(); ThreadTwo th2 = new ThreadTwo(); th2.setPriority(10); System.out.println(&quot;Priority of th1(-) : &quot; + th1.getPriority()); System.out.println(&quot;Priority of th2(|) : &quot; + th2.getPriority()); th1.start(); th2.start(); }}class ThreadOne extends Thread { @Override public void run() { for(int i = 0; i &amp;lt; 300; i++) { System.out.print(&quot;-&quot;); for(int x = 0; x &amp;lt; 10000000; x++); // 작업을 지연시키기위한 for문 } }}class ThreadTwo extends Thread { @Override public void run() { for(int i = 0; i &amp;lt; 300; i++) { System.out.print(&quot;|&quot;); for(int x = 0; x &amp;lt; 10000000; x++); } }}한 가지 의문은 예제에서 th2의 우선순위를 높게했음에도 불구하고 th1이 먼저 완료되는 결과가 나왔다.우선순위가 10에서 7로 낮아졌는데 이번에는 th2가 먼저 완료되었다. 몇 번 더 실행해본 결과 th2가 먼저 완료되는 경우가 많기는 했지만 th1이 먼저 완료되는 경우도 출력이 되었다. 이러한 결과에서 알 수 있듯이 우선순위는 절대적으로 지켜지는 것이 아니다. 다만 우선순위가 높은 쓰레드에게 상대적으로 많은 양의 실행시간이 주어지는 것일 뿐이다.Main 쓰레드   실제로 쓰레드를 실행시킬 때는 run()이 아니라 start()를 사용한다.main메서드에서 run()을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아니라 단순히 클래스에 선언된 메서드를 호출하는 것일 뿐이다.반면에 start()는 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택(call stack)을 생성한 다음에 run()을 호출해서, 생성된 호출스택에 run()이 첫번째로 올라가게 한다.모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택이 필요하고, 새로운 쓰레드를 생성하고 실행시킬 때마다 새로운 호출스택이 생성되고 소멸되는 것을 반복한다.호출스택은 이름처럼 스택(stack)과 같이 동작하며 가장 위에 있는 메서드가 현재 실행중인 메서드이고 나머지 메서드들은 대기상태이다. 그러나 쓰레드가 둘 이상인 경우에는 호출스택의 최상위에 있는 메서드일지라도 대기상태에 있을 수 있다.main쓰레드   main메서드의 작업을 수행하는 것도 쓰레드이며, 이를 main 쓰레드라고 한다. 프로그램을 실행하면 기본적으로 하나의 쓰레드를 생성하고, 그 쓰레드가 main메서드를 호출해서 작업이 수행되는 것이다.보통 main메서드가 수행을 마치면 프로그램이 종료되지만, main메서드는 수행을 마쳤는데 다른 쓰레드가 아직 작업을 마치지 않은 상태라면 프로그램이 종료되지 않는다.class App { public static void main(String[] args) { ThreadOne th1 = new ThreadOne(); th1.start(); }}class ThreadOne extends Thread { @Override public void run() { throwException(); } public void throwException() { try { throw new Exception(); } catch (Exception e) { e.printStackTrace(); } }}결과를 보면 알 수 있듯이 호출스택의 첫 번째 메서드가 main메서드가 아니라 run메서드이다.한 쓰레드가 예외를 발생해서 종료되어도 다른 쓰레드의 실행에는 영향을 미치지 않는다.class App { public static void main(String[] args) { ThreadOne th1 = new ThreadOne(); th1.run(); }}class ThreadOne extends Thread { @Override public void run() { throwException(); } public void throwException() { try { throw new Exception(); } catch (Exception e) { e.printStackTrace(); } }}이전 예제와 달리 run()을 사용하여 새로운 쓰레드가 생성되지 않았다.동기화   멀티쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유하기 때문에 서로의 작업에 영향을 줄 수 있다.이러한 일을 방지하기 위해서 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다. 그래서 도입된 개념이 바로 ‘임계 영역(critical section)’과 ‘잠금(락, lock)’이다.공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정해놓고, 공유 데이터(객체)가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행할 수 있게 한다. 그리고 해당 쓰레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만 다른 쓰레드가 반납된 lock을 획득하여 임계 영역의 코드를 수행할 수 있게 된다.이렇게 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 ‘쓰레드의 동기화(synchronization)’라고 한다.자바에서는 synchronized블럭을 이용해서 쓰레드의 동기화를 지원했지만, JDK1.5부터 java.util.concurrent.locks와 java.util.concurrent.atomic패키지를 통해서 다양한 방식으로 동기화를 구현할 수 있도록 지원하고 있다.synchronized를 이용한 동기화   가장 간단한 동기화 방법인 synchronized 키워드를 이용한 동기화는 두 가지 방식이 있다. 메서드 전체를 임계 영역으로 지정public synchronized void calcSum() { // …} 특정한 영역을 임계 영역으로 지정synchronized(객체의 참조변수) { // …} 첫 번째 방법은 메서드 앞에 synchronized를 붙이는 것인데, synchronized를 붙이면 메서드 전체가 임계 영역으로 설정된다. 쓰레드는 synchronized메서드가 호출된 시점부터 해당 메서드가 포함된 객체의 lock을 얻어 작업을 수행하다가 메서드가 종료되면 lock을 반환한다.두 번째 방법은 메서드 내의 코드 일부를 블럭으로 감싸고 블럭 앞에 synchronized(참조변수)를 붙이는 것인데, 이 때 참조변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다. 이 블럭을 synchronized블럭이라고 부르며, 이 블럭의 영역 안으로 들어가면서부터 쓰레드는 지정된 객체의 lock을 얻게 되고, 이 블럭을 벗어나면 lock을 반납한다.   두 방법 모두 lock의 획득과 반납이 모두 자동적으로 이루어지므로 우리가 해야 할 일은 그저 임계 영역만 설정해주는 것뿐이다.class App { public static void main(String[] args) { Runnable r = new RunnableEx(); new Thread(r).start(); new Thread(r).start(); new Thread(r).start(); }}class Account { private int balance = 1000; public int getBalance() { return balance; } public void withdraw(int money) { if (balance &amp;gt;= money) { try { Thread.sleep(1000); } catch (InterruptedException e) { } balance -= money; } }}class RunnableEx implements Runnable { Account acc = new Account(); public void run() { while (acc.getBalance() &amp;gt; 0) { // 100, 200, 300 중 임의의 한 값으로 출금(withdraw) int money = (int) (Math.random() * 3 + 1) * 100; acc.withdraw(money); System.out.println(&quot;balance : &quot; + acc.getBalance()); System.out.println(&quot;출금되었습니다.&quot;); } }}은행계좌에서 잔고를 확인하고 임의의 금액을 출금하는 예제이다. 코드 중 withdraw부분을 살펴보면 잔고가 출금하려는 금액보다 큰 경우에만 출금하도록 되어 있는 것을 확인할 수 있다. public void withdraw(int money) { if (balance &amp;gt;= money) { try { Thread.sleep(1000); } catch (InterruptedException e) { } balance -= money; } }그러나 실행결과를 보면 잔고가 음수 값으로 되어있는데, 그 이유는 한 쓰레드가 if문의 조건식을통과하고 출금하기 바로 직전에 다른 쓰레드가 끼어들어서 출금을 먼저 했기 때문이다.이러한 상황을 막기 위해서 synchronized를 사용하는 것이다.아래 코드는 synchronized를 사용하여 수정한 코드이다.class App { public static void main(String[] args) { Runnable r = new RunnableEx(); new Thread(r).start(); new Thread(r).start(); new Thread(r).start(); }}class Account { private int balance = 1000; public int getBalance() { return balance; } public synchronized void withdraw(int money) { if (balance &amp;gt;= money) { try { Thread.sleep(1000); } catch (InterruptedException e) { } balance -= money; } }}class RunnableEx implements Runnable { Account acc = new Account(); public void run() { while (acc.getBalance() &amp;gt; 0) { // 100, 200, 300 중 임의의 한 값으로 출금(withdraw) int money = (int) (Math.random() * 3 + 1) * 100; acc.withdraw(money); System.out.println(&quot;balance : &quot; + acc.getBalance()); System.out.println(&quot;출금되었습니다.&quot;); } }}결과 값에 음수가 사라진 것을 확인할 수 있다. 여기서 한 가지 주의할 점은 Account클래스의 인스턴스 변수인 balance의 접근 제어자가 private이라는 것이다. 만일 private이 아니면, 외부에서 직접 접근할 수 있기 때문에 동기화가 무의미해 진다. synchronized를 이용한 동기화는 지정된 영역의 코드를 한 번에 하나의 쓰레드가 수행하는 것을 보장하는 것일 뿐이기 때문이다.wait()와 notify()   동기화를 이용해서 공유 데이터를 보호하는 것은 좋은데, 특정 쓰레드가 락을 보유한 채로 상황이 해결될 때까지 오랜 시간을 보내게 된다면, 다른 작업들이 원활히 진행되지 않을 것이다.   이러한 상황을 개선하기 위해 고안된 것이 바로 wait()와 notify()이다. 동기화된 임계 영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면, 일단 wait()를 호출하여 쓰레드가 락을 반납하고 기다리게 한다. 그러면 다른 쓰레드가 락을 얻어 해당 객체에 대한 작업을 수행할 수 있게 된다. 나중에 작업을 진행할 수 있는 상황이 되면 notify()를 호출해서, 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있게 한다.lock이 넘어간다고 해서 무조건 오래 기다리던 쓰레드가 받게 된다는 보장은 없다. wait()을 호출하면 작업을 하던 쓰레드는 해당 객체의 대기실(waiting pool)로 이동하여 연락을 기다린다. notify()가 호출되면, 해당 객체의 대기실에 있던 모든 쓰레드 중 임의의 쓰레드만 연락을 받게되고, notifyAll()이 호출되면 연락은 모든 쓰레드가 받지만 랜덤하게 선택된 하나의 쓰레드가 lock을 받게 된다.   wait()와 notify()는 특정 객체에 대한 것이므로 Object클래스에 정의되어있다. void wait() void wait(long timeout) void wait(long timeout, int nanos) void notify() void notifyAll()wait()는 notify() 또는 notifyAll()이 호출될 때까지 기다리지만, 매개변수가 있는 wait()는 지정된 시간동안만 기다린다.waiting pool은 객체마다 존재하는 것이므로 notifyAll()이 호출된다고 해서 모든 객체의 waiting pool에 있는 쓰레드가 깨워지는 것은 아니다. notifyAll()이 호출된 객체의 waiting pool에 대기 중인 쓰레드만 해당된다. wait(), notify(), notifyAll() Object에 정의되어 있다. 동기화 블록(synchronized블록)내에서만 사용할 수 있다. 보다 효율적인 동기화를 가능하게 한다. 기아 현상과 경쟁 상태정말 지독하게 운이 나빠서 쓰레드가 연락을 받지 못하고 오랫동안 기다리게 되는데, 이것은 기아(starvation) 현상이라고 한다. 이 현상을 막으려면, notify() 대신 notifyAll()을 사용해야 한다.notifyAll()로 원하는 쓰레드의 기아현상은 막았지만, 다른 쓰레드까지 연락을 받아서 불필요하게 lock을 얻기 위해 경쟁하게 된다. 이처럼 여러 쓰레드가 lock을 얻기 위해 서로 경쟁하는 것을 경쟁 상태(race condition)라고 하는데, 이것을 개선하기 위해서는 구별해서 연락하는 것이 필요하다.Lock과 Condition을 이용한 동기화   동기화할 수 있는 방법은 synchronized블럭 외에도 java.util.concurrent.locks패키지가 제공하는 lock클래스들을 이용하는 방법이 있다. 이 패키지는 JDK1.5에 와서야 추가된 것으로 그 전에는 동기화 방법이 synchronized블럭뿐이었다.   synchronized블럭으로 동기화를 하면 자동적으로 lock이 잠기고 풀리기 때문에 편리하다. 하지만 같은 메서드 내에서만 lock을 걸 수 있다는 제약이 불편하기도 하다. 그럴 때 이 lock클래스를 사용한다. lock클래스의 종류는 다음과 같이 3가지가 있다. ReentrantLock 재진입이 가능한 lock. 가장 일반적인 배타 lock ReentrantReadWriteLock 읽기에는 공유적이고, 쓰기에는 배타적인 lock StampedLock ReentrantReadWriteLock에 낙관적인 lock을 추가 ▶ ReentrantLock   ReentrantLock은 가장 일반적인 lock이다. ‘reentrant(재진입할 수 있는)’이라는 단어가 앞에 붙은 이유는 wait() &amp;amp; notify()처럼, 특정 조건에서 lock을 풀고 나중에 다시 lock을 얻어 이후의 작업을 수행할 수 있기 때문이다.▶ ReentrantReadWriteLock   ReentrantReadWriteLock은 읽기를 위한 lock과 쓰기를 위한 lock을 제공한다. ReentrantLock은 배타적인 lock이라서 무조건 lock이 있어야만 임계 영역의 코드를 수행할 수 있지만, ReentrantReadWriteLock은 읽기 lock이 걸려있으면, 다른 쓰레드가 읽기 lock을 중복해서 걸고 읽기를 수행할 수 있다. 읽기는 내용을 변경하지 않으므로 동시에 여러 쓰레드가 읽어도 문제가 되지 않는다. 그러나 읽기 lock이 걸린 상태에서 쓰기 lock을 거는 것은 허용되지 않는다. 반대의 경우도 마찬가지다. 읽기를 할 때는 읽기 lock을 걸고, 쓰기 할 때는 쓰기 lock을 거는 것일 뿐 lock을 거는 방법은 같다.▶ StampedLock   StampedLock은 lock을 걸거나 해지할 때 ‘스탬프(long타입의 정수값)’를 사용하며, 읽기와 쓰기를 위한 lock외에 ‘낙관적 읽기 lock(optimistic reading lock)’이 추가된 것이다. 읽기 lock이 걸려있으면, 쓰기 lock을 얻기 위해서는 읽기 lock이 풀릴 때까지 기다려야하는데 비해 ‘낙관적 읽기 lock’은 쓰기 lock에 의해 바로 풀린다. 따라서 낙관적 읽기에 실패하면, 읽기 lock을 얻어서 다시 읽어 와야 한다. 무조건 읽기 lock을 걸지 않고, 쓰기와 읽기가 충돌할 때만 쓰기가 끝난 후에 읽기 lock을 거는 것이다.int getBalance() { long stamp = lock.tryOptimisticRead(); // 낙관적 읽기 lock을 건다. int curBalance = this.balance; // 공유 데이터인 balance를 읽어온다. if(!lock.validate(stamp)) { // 쓰기 lock에 의해 낙관적 읽기 lock이 풀렸는지 확인 stamp = lock.readLock(); // lock이 풀렸으면, 읽기 lock을 얻으려고 기다린다. try { curBalance = this.balance; // 공유 데이터를 다시 읽어온다. } finally { lock.unlockRead(stamp); // 읽기 lock을 푼다. } } return curBalance; // 낙관적 읽기 lock이 풀리지 않았으면 곧바로 읽어온 값을 반환}ReentrantLock의 생성자 ReentrantLock() ReentrantLock(boolean fair)생성자의 매개변수를 true로 주면, lock이 풀렸을 때 가장 오래 기다린 쓰레드가 lock을 획득할 수 있게, 즉 공정(fair)하게 처리한다. 그러나 공정하게 처리하면 가장 오래된 쓰레드를 찾는 과정이 추가되어 성능이 떨어진다.   대부분의 경우 공정하게 처리하지 않아도 문제가 되지 않으므로 공정함보다 성능을 선택한다. void lock() // lock을 잠근다. void unlock() // lock을 해제한다. boolean isLocked() // lock이 잠겼는지 확인한다.자동적으로 lock의 잠금과 해제가 관리되는 synchronized블럭과 달리, ReentrantLock과 같은 lock클래스들은 수동으로 lock을 잠그고 해제해야 한다. 하지만 메서드를 호출하기만 하면되기 때문에 간단하다. lock을 걸고 나서 푸는 것을 잊지않도록 주의하자. lock.lock(); // 임계 영역 lock.unlock();임계 영역 내에서 예외가 발생하거나 return문으로 빠져 나가게 되면 lock이 풀리지 않을 수 있으므로 unlock()은 try-finally문으로 감싸는 것이 일반적이다. 참조변수 lock은 ReentrantLock객체를 참조한다고 가정하였다. lock.lock(); try { // 임계 영역 } finally { lock.unlock(); }이렇게 하면, try블럭 내에서 어떤 일이 발생해도 finally블럭에 있는 unlock()이 수행되어 lock이 풀리지 않는 일은 발생하지 않는다. 대부분의 경우 synchronized블럭을 사용할 수 있어서 그냥 synchronized블럭을 사용하는 것이 나을 수 있다.▶ tryLock()   tryLock()은 lock()과 달리, 다른 쓰레드에 의해 lock이 걸려 있으면 lock을 얻으려고 기다리지 않는다. 또는 지정된 시간만큼만 기다린다. lock을 얻으면 true, 얻지 못하면 false를 반환한다. boolean tryLock() boolean tryLock(long timeout, TimeUnit unit) throws InterruptedExceptionlock()은 lock을 얻을 때까지 쓰레드를 블락(block)시키므로 쓰레드의 응답성이 나빠질 수 있다. 응답성이 중요한 경우, tryLock()을 이용해서 지정된 시간동안 lock을 얻지 못하면 다시 작업을 시도할 것인지 포기할 것인지를 사용자가 결정할 수 있게 하는 것이 좋다.이 메서드는 InterruptedException을 발생시킬 수 있는데, 이것은 지정된 시간동안 lock을 얻을려고 기다리는 중에 interrupt()에 의해 작업이 취소될 수 있도록 코드를 작성할 수 있다는 뜻이다.ReentrantLock과 ConditionCondition은 wait() &amp;amp; notify()에서 쓰레드를 구분해서 연락하지 못한다는 단점을 해결하기 위한 것이다.   wait() &amp;amp; notify()로 쓰레드의 종류를 구분하지 않고, 공유 객체의 waiting pool에 같이 몰아넣은 대신, 각각의 쓰레드의 Condition을 만들어서 각각의 waiting pool에서 기다리도록 하면 문제는 해결된다.Condition은 이미 생성된 lock으로부터 new Condition()을 호출해서 생성한다. private ReentrantLock lock = new ReentrantLock(); // lock을 생성 // lock으로 condition을 생성 private Condition forOne = lock.newCondition(); private Condition forTwo = lock.newCondition();그리고 wait() &amp;amp; notify() 대신 await() &amp;amp; signal()을 사용하면된다. void await() void await() void awaitUninterruptibly() void await(long timeout) boolean await(long time, TimeUnit unit) long awaitNanos(long nanosTimeout) boolean awaitUntil(Date deadline) void notify() void signal() void notifyAll() void signalAll() 데드락   교착상태(데드락, deadlock)은 두 개 이상의 작업이 서로 상대방의 작업이 끝나기를 기다리고 있어서 아무것도 완료되지 못하는 상태를 말한다.교착상태의 조건 상호배제(Mutual exclusion) : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다. 점유대기(Hold and wait) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다. 비선점(No preemption) : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다. 순환대기(Circular wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다. 위 조건 중에서 한 가지라도 만족하지 않으면 교착 상태는 발생하지 않는다. 이중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.교착상태는 예방, 회피, 무시 세 가지 방법으로 관리할 수 있다.예방 상호배제 조건의 제거 교착 상태는 두 개 이상의 프로세스가 공유가능한 자원을 사용할 때 발생하는 것이므로 공유 불가능한, 즉 상호 배제 조건을 제거하면 교착 상태를 해결할 수 있다. 점유와 대기 조건의 제거 한 프로세스에 수행되기 전에 모든 자원을 할당시키고 나서 점유하지 않을 때에는 다른 프로세스가 자원을 요구하도록 하는 방법이다. 자원 과다 사용으로 인한 효율성, 프로세스가 요구하는 자원을 파악하는 데에 대한 비용, 자원에 대한 내용을 저장 및 복원하기 위한 비용, 기아 상태, 무한대기 등의 문제점이 있다. 비선점 조건의 제거 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 준다. 환형 대기 조건의 제거 자원 유형에 따라 순서를 매긴다. 이 해결 방법들은 자원 사용의 효율성이 떨어지고 비용이 많이 드는 문제점이 있다.회피자원이 어떻게 요청될지에 대한 추가정보를 제공하도록 요구하는 것으로 시스템에 circular wait가 발생하지 않도록 자원 할당 상태를 검사한다.교착 상태 회피 알고리즘은 크게 두가지가 있다. 자원 할당 그래프 알고리즘 (Resource Allocation Graph Algorithm) 은행원 알고리즘 (Banker’s algorithm)무시예방과 회피방법을 활용하면 성능 상 이슈가 발생하는데, 데드락 발생에 대한 상황을 고려하는 것에 대한 비용이 낮다면 별다른 조치를 하지 않을 수도 있다고 한다.다음 코드는 오라클에서 제공하는 데드락의 예제이다.public class Deadlock { static class Friend { private final String name; public Friend(String name) { this.name = name; } public String getName() { return this.name; } public synchronized void bow(Friend bower) { System.out.format(&quot;%s: %s&quot; + &quot; has bowed to me!%n&quot;, this.name, bower.getName()); bower.bowBack(this); } public synchronized void bowBack(Friend bower) { System.out.format(&quot;%s: %s&quot; + &quot; has bowed back to me!%n&quot;, this.name, bower.getName()); } } public static void main(String[] args) { final Friend alphonse = new Friend(&quot;Alphonse&quot;); final Friend gaston = new Friend(&quot;Gaston&quot;); new Thread(new Runnable() { public void run() { alphonse.bow(gaston); } }).start(); new Thread(new Runnable() { public void run() { gaston.bow(alphonse); } }).start(); }}Reference 자바의 정석 3/e Java in a Nutshell 오라클 공식 가이드 https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html" }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A806/", "categories": "php", "tags": "", "date": "2021-01-17 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문7. 데이터베이스 마이그레이션데이터베이스 마이그레이션이란, 테이블 스키마의 버전 관리다. 데이터베이스 마이그레이션을 이용하면, 테이블에 새로운 열을 추가한다든지, 열 이름을 바꾼다든지 하는 이력을 마이그레이션 코드로 남겨 두고 필요할 때마다 마이그레이션을 실행했다가 롤백하는 등의 작업을 자유롭게 할 수 있다.SQL 문장을 이용해서 데이터베이스 스키라를 만들고 관리할 수 있는데, 마이그레이션은 왜 필요할까? 모던 개발 방법론 팀 내 개발자들은 같은 데이터베이스 스키마로 개발해야 한다. 한 개발자의 스키마 변경을 다른 개발자도 사용해야 한다. 개발 환경뿐 아니라 테스트 서버, 지속적 통합 서버, 운영 서버 등에서 환경을 쉽고 빠르게 만들 수 있는 도구가 필요하다. ‘완벽’이란 없다. ‘완벽 추구’만 있을 뿐이다. 비지니스는 계속 변하고, 요구 사항도 계속 변한다. 데이터베이스 모델링을 기가 막히게 했더라도 시간이 지나면 바뀔 수 밖에 없다(users 테이블에 직원과 고객을 모두 넣었는데, 직원이 고객이 되면? 또는 직원일 때의 이메일과 고객일 때의 이메일이 다르다면?) 또는 실수로 열이름에 오탈자가 들어갔다거나, 모델링을 잘못했는데 빠르게 롤백해야 하는 상황도 생각해 볼 수 있다. 번거롭더라도 데이터베이스 마이그레이션을 작성해 두면 데이터베이스 스키마 때문에 위기에 처하거나 변경 요구가 생겼을 때 효과적으로 대응할 수 있다.7.1 마이그레이션 만들기이전 테이블을 모두 삭제한다 데이터베이스 정리$ mysql -uhomestead -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 36Server version: 8.0.22 HomebrewCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.mysql&amp;gt; use myapp;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&amp;gt; set foreign_key_checks=0;Query OK, 0 rows affected (0.00 sec)mysql&amp;gt; drop table posts;Query OK, 0 rows affected (0.01 sec)mysql&amp;gt; drop table authors;Query OK, 0 rows affected (0.01 sec)mysql&amp;gt; set foreign_key_checks=1;Query OK, 0 rows affected (0.00 sec)새로운 마이그레이션 만든다. --create=테이블_이름 과 --table=테이블_이름 옵션을 주면 좀더 많은 코드를 생성해 준다. 마이그레이션 클래스 뼈대 코드 만들기$ php artisan make:migration create_posts_table --create=posts Created Migration: 2021_01_17_141752_create_posts_table$ php artisan make:migration create_authors_table --create=authorsCreated Migration: 2021_01_17_141834_create_authors_table생성된 파일은 database/migrations 디렉터리 아래에 있다.NOTE마이그레이션의 파일 이름 테이블과 모델 이름의 관례처럼 마이그레이션 이름 명명에 엄격한 규칙이 있는 것은 아니다. 관례적으로 스네이크 표기법을 사용하며, create_, make_, add_, drop_, change_ 등으로 시작하고, _table로 끝난다. 둘 사이에는 아미그레이션을 설명할 수 있는 내용을 기술한다.up() 은 마이그레이션을 실행하는 메서드이고, down() 은 롤백을 위한 메서드다. database/migrations/2021_01_17_141752_create_posts_table.php&amp;lt;?phpuse Illuminate\\Database\\Migrations\\Migration;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Support\\Facades\\Schema;class CreatePostsTable extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::create(&#39;posts&#39;, function (Blueprint $table) { $table-&amp;gt;increments(&#39;id&#39;); $table-&amp;gt;string(&#39;title&#39;); $table-&amp;gt;text(&#39;body&#39;); $table-&amp;gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(&#39;posts&#39;); }} database/migrations/2021_01_17_141834_create_authors_table.php&amp;lt;?phpuse Illuminate\\Database\\Migrations\\Migration;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Support\\Facades\\Schema;class CreateAuthorsTable extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::create(&#39;authors&#39;, function (Blueprint $table) { $table-&amp;gt;increments(&#39;id&#39;); $table-&amp;gt;string(&#39;email&#39;,255); $table-&amp;gt;string(&#39;password&#39;,60); $table-&amp;gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(&#39;authors&#39;); }} Schema::create(string $table , \\Closure $callback) 테이블을 만든다. Schema::dropIfExists(string $table ) 테이블을 지운다. Schema::table(string $table , \\Closure $callback) 테이블을 생성/삭제를 제외한 나머지 대부분의 스키마 관련 작업을 담는다. 메서드 내용 boolean(), dateTime(), enum(), integer(), timestamp() 열 타입 메서드 timestamps(), softDeletes() 도우미 메서드 nullable(), default(), unsigned() 장식 메서드 unique(), index() 인덱스 메서드 전체 목록은 공식 문서를 참고 하자.note타입 힌트마이그레이션 코드에서 blueprint라 타이핑된 문자열은 타입 힌트다. Schema::create() 메서드의 주 번째 인자는 콜백 함수인데, 콜백 함수가 인자로 받는 $table이 Illuminate/Database/Schema/Blueprint 클래스의 인스턴스여야 한다고 강제하는 것이다.7.2 마이그레이션 실행마이그레이션 실행 확인 마이그레시연 힐생$ php artisan migrate Migrating: 2014_10_12_000000_create_users_tableMigrated: 2014_10_12_000000_create_users_table (16.35ms)Migrating: 2014_10_12_100000_create_password_resets_tableMigrated: 2014_10_12_100000_create_password_resets_table (9.62ms)Migrating: 2021_01_17_141752_create_posts_tableMigrated: 2021_01_17_141752_create_posts_table (4.58ms)Migrating: 2021_01_17_141834_create_authors_tableMigrated: 2021_01_17_141834_create_authors_table (4.69ms) 마이그레이션 실행 결과$ mysql -uhomestead -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 39Server version: 8.0.22 HomebrewCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.mysql&amp;gt; use myapp;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&amp;gt; describe posts;+------------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+--------------+------+-----+---------+----------------+| id | int unsigned | NO | PRI | NULL | auto_increment || title | varchar(255) | NO | | NULL | || body | text | NO | | NULL | || created_at | timestamp | YES | | NULL | || updated_at | timestamp | YES | | NULL | |+------------+--------------+------+-----+---------+----------------+5 rows in set (0.00 sec)mysql&amp;gt; describe authors;+------------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+--------------+------+-----+---------+----------------+| id | int unsigned | NO | PRI | NULL | auto_increment || email | varchar(255) | NO | | NULL | || password | varchar(60) | NO | | NULL | || created_at | timestamp | YES | | NULL | || updated_at | timestamp | YES | | NULL | |+------------+--------------+------+-----+---------+----------------+5 rows in set (0.00 sec)7.3 롤백 롤백$ php artisan migrate:rollbackRolling back: 2021_01_17_141834_create_authors_tableRolled back: 2021_01_17_141834_create_authors_table (13.51ms)Rolling back: 2021_01_17_141752_create_posts_tableRolled back: 2021_01_17_141752_create_posts_table (3.25ms)Rolling back: 2014_10_12_100000_create_password_resets_tableRolled back: 2014_10_12_100000_create_password_resets_table (4.22ms)Rolling back: 2014_10_12_000000_create_users_tableRolled back: 2014_10_12_000000_create_users_table (3.21ms)테이블이 삭제 되었다$ mysql -uhomestead -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 41Server version: 8.0.22 HomebrewCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.mysql&amp;gt; use myapp;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&amp;gt; describe posts;ERROR 1146 (42S02): Table &#39;myapp.posts&#39; doesn&#39;t existmysql&amp;gt; describe authors;ERROR 1146 (42S02): Table &#39;myapp.authors&#39; doesn&#39;t existmigration 테이블은 롤백 해도 지워지지 않는다. 마이그레이션 실행$ php artisan migrate Migrating: 2014_10_12_000000_create_users_tableMigrated: 2014_10_12_000000_create_users_table (16.35ms)Migrating: 2014_10_12_100000_create_password_resets_tableMigrated: 2014_10_12_100000_create_password_resets_table (9.62ms)Migrating: 2021_01_17_141752_create_posts_tableMigrated: 2021_01_17_141752_create_posts_table (4.58ms)Migrating: 2021_01_17_141834_create_authors_tableMigrated: 2021_01_17_141834_create_authors_table (4.69ms)7.4 열 추가authors 테이블에 name 컬럼을 추가 해 보자. 테이블 열 추가 마이드레이션 뼈대 코드 만들기$ php artisan make:migration add_name_to_authors_table --table=authorsCreated Migration: 2021_01_17_145632_add_name_to_authors_table database/migrations/2021_01_17_145632_add_name_to_authors_table.php&amp;lt;?phpuse Illuminate\\Database\\Migrations\\Migration;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Support\\Facades\\Schema;class AddNameToAuthorsTable extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::table(&#39;authors&#39;, function (Blueprint $table) { $table-&amp;gt;string(&#39;name&#39;)-&amp;gt;nullable(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::table(&#39;authors&#39;, function (Blueprint $table) { $table-&amp;gt;dropColumn(&#39;name&#39;); }); }}create() 메소드가 아닌 table() 메서드를 사용한다 마이그레이션 실행$ php artisan migrateMigrating: 2021_01_17_145632_add_name_to_authors_tableMigrated: 2021_01_17_145632_add_name_to_authors_table (2.69ms) 마이그레이션 실행 결과$ mysql -uhomestead -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 53Server version: 8.0.22 HomebrewCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.mysql&amp;gt; use myapp;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&amp;gt; describe authors;+------------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+--------------+------+-----+---------+----------------+| id | int unsigned | NO | PRI | NULL | auto_increment || email | varchar(255) | NO | | NULL | || password | varchar(60) | NO | | NULL | || created_at | timestamp | YES | | NULL | || updated_at | timestamp | YES | | NULL | || name | varchar(255) | YES | | NULL | |+------------+--------------+------+-----+---------+----------------+6 rows in set (0.00 sec)초기화 및 새로고침migrate:rollback 명령은 직전 마이그레이션만 록백 하는 반면, migrate:reset 명령은 모든 마이그레이션을 롤백하고 데이터베이스를 초기화한다. migrateLrefresh는 초기화한 후, 마이그레이션을 다시 실행하는 명령이다. 마이그레이션 새로고침% php artisan migrate:refreshRolling back: 2021_01_17_145632_add_name_to_authors_tableRolled back: 2021_01_17_145632_add_name_to_authors_table (13.63ms)Rolling back: 2021_01_17_141834_create_authors_tableRolled back: 2021_01_17_141834_create_authors_table (2.90ms)Rolling back: 2021_01_17_141752_create_posts_tableRolled back: 2021_01_17_141752_create_posts_table (2.90ms)Rolling back: 2014_10_12_100000_create_password_resets_tableRolled back: 2014_10_12_100000_create_password_resets_table (3.84ms)Rolling back: 2014_10_12_000000_create_users_tableRolled back: 2014_10_12_000000_create_users_table (3.18ms)Migrating: 2014_10_12_000000_create_users_tableMigrated: 2014_10_12_000000_create_users_table (10.88ms)Migrating: 2014_10_12_100000_create_password_resets_tableMigrated: 2014_10_12_100000_create_password_resets_table (12.00ms)Migrating: 2021_01_17_141752_create_posts_tableMigrated: 2021_01_17_141752_create_posts_table (5.69ms)Migrating: 2021_01_17_141834_create_authors_tableMigrated: 2021_01_17_141834_create_authors_table (4.86ms)Migrating: 2021_01_17_145632_add_name_to_authors_tableMigrated: 2021_01_17_145632_add_name_to_authors_table (5.58ms)" }, { "title": "자바스터디 9주차", "url": "/posts/whiteship-study-9week/", "categories": "study", "tags": "", "date": "2021-01-15 00:00:00 +0900", "snippet": "GOAL자바의 예외 처리에 대해 학습하세요.학습할 것 (필수) 자바에서 예외 처리 방법 (try, catch, throw, throws, finally) 자바가 제공하는 예외 계층 구조 Exception과 Error의 차이는? RuntimeException과 RE가 아닌 것의 차이는? 커스텀한 예외 만드는 방법자바에서 예외 처리 방법 (try, catch, throw, throws, finally)예외(exception)란 ? ‘예외적인 이벤트’의 약자로 프로그램의 정상적인 흐름은 방해하는 이벤트라고 정의 한다 오라클에외 전체 흐름도try try블럭 내에서 예외가 발생한 경우, 해당 되는 catch 블록을 실행 한다. 일치하는 catch블럭을 찾으면, 그 catch블럭 내의 문장들을 수행 일치하는 catch블럭이 없으면, 처리하지 못하고 그대로 잔행catch try블럭에서 발생한 예외와 catch블록에 있는 예외를 비교하여 일치하는 예외 블록시 실행 된다public class TryCatchFinally { public static void main(String[] args) { try{ ...처리작업 }catch (Exception e){ ...예외발생시 처리작업 } }} 컴파일소스public class TryCatchFinally { public TryCatchFinally(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: return}추가catch블럭(자바7) 기호(|)를 통해 하나의 catch블럭으로 통합 기호(|)로 연결된 예외 클래스가 부모와 자식 관계에 있다면 컴파일 에러가 발생 참조변수 e는 상수 라서 값을 변경할 수 없다try { ...} catch (ExceptionA | ExceptionB e) { e.printStackTrace();}finally 블록내 처리후 반드시 실행되는 블럭 io나 connect 등 사용후 종료 하는 자원이 있을 경우 사용 finally 블록에서 예외 발생시, catch블록의 예외 추적이 불가하다. 이런 문제는 자바7에서 try-with-resources로 해결할 수 있다.spublic class TryCatchFinally { public static void main(String[] args) { try{ ...처리작업 }catch (Exception e){ ...예외발생시 처리작업 }finally { ...항상 실행 작업 } }} 컴파일소스public class TryCatchFinally { public TryCatchFinally(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: return}chtry-with-resources(자바7) 대상이 되는 메소드는 AutoCloseable 인터페이스를 구현해야 한다. try블록이 종료 되면, AutoCloseable 의 close()메소드의 구현체가 실행된다. try-catch문과 AutoCloseable.close()에서 모두 예외가 발생되면, 두 예외가 동시에 발생할 수는 없기 때문에 close()에서 발생되는 예외는 억제된 예외 로 처리되어 실제 발생한 예외(try-catch문에서 발생한 예외)에 저장된다.public class TryCatchResource { public static void main(String[] args){ try(TryCatchResourceMethod c = new TryCatchResourceMethod()){ } catch (Exception e) { } }}class TryCatchResourceMethod implements AutoCloseable { @Override public void close() { System.out.println(&quot;always exec&quot;); }} 컴파일 소스public class TryCatchResource { public TryCatchResource(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #7 // class TryCatchResourceMethod 3: dup 4: invokespecial #9 // Method TryCatchResourceMethod.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: aload_1 9: invokevirtual #10 // Method TryCatchResourceMethod.close:()V 12: goto 16 15: astore_1 16: return Exception table: from to target type 0 12 15 Class java/lang/Exception}실행 순서를 보면 0번에서 생성한 클래스를 7번라인에서 저장 7번라인에서 저장한 클래스를 8번 라인에서 로드 8번라인에서 로드한 클래스의 close()를 9번 라인에서 실행예외 처리는 Exception table 테이블을 이용하여, 12번 라인의 목적이 메모값을 변경 (종료인 16라인에서 Exception 클래스 가 있는 15번 라인으로 이동)outputalways execgetSuppressed,addSuppressed Throwable에 추가된 getSuppressed메소드를 이용하면 예외를 가져올 수도 있다. Throwable에 추가된 addSuppressed메소드를 이용하면 예외를 추가할 수도 있다.public class Throwable implements Serializable { public final synchronized Throwable[] getSuppressed() { if (suppressedExceptions == SUPPRESSED_SENTINEL || suppressedExceptions == null) return EMPTY_THROWABLE_ARRAY; else return suppressedExceptions.toArray(EMPTY_THROWABLE_ARRAY); } public final synchronized void addSuppressed(Throwable exception) { if (exception == this) throw new IllegalArgumentException(SELF_SUPPRESSION_MESSAGE, exception); Objects.requireNonNull(exception, NULL_CAUSE_MESSAGE); if (suppressedExceptions == null) // Suppressed exceptions not recorded return; if (suppressedExceptions == SUPPRESSED_SENTINEL) suppressedExceptions = new ArrayList&amp;lt;&amp;gt;(1); suppressedExceptions.add(exception);}}throw throw키워드를 이용해서 고의로 예외를 발생 가능 Exception e = new Exception(&quot;예외&quot;);throw e; throws throws키워드를 이용해서 예외를 호출한 메소드로 넘길 수 있다. 하지마세요 throws키워드를 사용할 경우, 예외 처리를 위한 Exception table 생성public class TryCatchResource { public static void main(String[] args) { parent(); } public static void parent(){ try{ child(); } catch (Exception e) { System.out.println(&quot;parent&quot;); e.printStackTrace(); } } private static void child() throws Exception { throw new Exception(&quot;child Exception&quot;); }} 컴파일소스public class TryCatchResource { public TryCatchResource(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: invokestatic #7 // Method parent:()V 3: return public static void parent(); Code: 0: invokestatic #12 // Method child:()V 3: goto 19 6: astore_0 7: getstatic #17 // Field java/lang/System.out:Ljava/io/PrintStream; 10: ldc #23 // String parent 12: invokevirtual #24 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 15: aload_0 16: invokevirtual #30 // Method java/lang/Exception.printStackTrace:()V 19: return Exception table: from to target type 0 3 6 Class java/lang/Exception}컴파일 소스를 보면 예외 처리를 위한 Exception table이 생긴걸 알 수 있다.outputparentjava.lang.Exception: child Exception at TryCatchResource.child(TryCatchResource.java:18) at TryCatchResource.parent(TryCatchResource.java:10) at TryCatchResource.main(TryCatchResource.java:5)자바가 제공하는 예외 계층 구조https://madplay.github.io/post/java-checked-unchecked-exceptions Exception과 Error는 Throwable이라는 클래스를 상속받고 있으며 Throwable은 Object를 직접 상속받음Exception과 Error의 차이는? Throwable은 Error와 Exception이라는 두 개의 하위 클래스를 갖는데, 필요한 곳에서 Exception클래스를 확인하고 수정하는 것으로 개발자가 직접 처리 할 수 있다 Error는 OutOfMemoryError나 NoClassDefFoundError클래스처럼 개발자 스스로 처리 할 수 있는것이 아니다.RuntimeException과 RE가 아닌 것의 차이는? 예외는 ‘런타임 예외(runtime exception)’이거나 ‘확인해야 하는 예외(checked exception)’ 두 가지로 구분 런타임 예외는 모두 RuntimeException의 하위 클래스고, 확인해야 하는 예외는 모두 다른 예외 확인해야 하는 예외(checked exception)를 처리하는 메소드(또는 생성자)를 사용할 때는 메소드 정의에 명시적으로 예외가 정의되어야 하며, 따라 코드를 호출하는 모든 호출자들은 해당 예외를 처리 즉, 메소드의 호출자에게 전달하거나 try/catch/finally문으로 예외를 적절히 처리참고커스텀한 예외 만드는 방법 기존 정의된 예외 클래스 외에 필요에 따라 새로운 예외 클래스를 정의 보통 Exception클래스로부터 상속받는 클래스를 만들지만, 필요에 따라 알맞은 예외 클래스를 선택 가능public class CustomException extends Exception { private final int ERROR_CODE; CustomException(String message, int errorCode) { super(message); this.ERROR_CODE = errorCode; } CustomException(String message) { this(message, 100); } public int getErrorCode() { return ERROR_CODE; }} 컴파일소스ublic class CustomException extends java.lang.Exception { CustomException(java.lang.String, int); Code: 0: aload_0 1: aload_1 2: invokespecial #1 // Method java/lang/Exception.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V 5: aload_0 6: iload_2 7: putfield #7 // Field ERROR_CODE:I 10: return CustomException(java.lang.String); Code: 0: aload_0 1: aload_1 2: bipush 100 4: invokespecial #13 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V 7: return public int getErrorCode(); Code: 0: aload_0 1: getfield #7 // Field ERROR_CODE:I 4: ireturn}참고9주차" }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A805/", "categories": "php", "tags": "", "date": "2021-01-14 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문6. 데이터베이스와 모델라라벨은 Mysql을 기본값으로 설정하지만, MariaDB, Postgres, SqlLite, SqlServer 등을 사용 가능하다.옐로퀀트 데이트베이스의 레코드를 객체로 표현하는 객체 관계 모델의 구현체이며, PHP의 클래스 문법으로 RDB와 상호 작용이 가능 하다. 자바의 jpa와 유사한 기능같다6.1 데이터베이스 준비이전에 헀던 root 비밀번호를 입력하여 접속한다 trouble shootingCan’t connect to local MySQL server through socket ‘/tmp/mysql.sock’에러 발생시, mysql 서버가 작동중인지 확인해 보자 MySql 접속$ mysql -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 13Server version: 8.0.22 HomebrewCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.mysql&amp;gt;데이터를 만든다 데이터베이스 만들기mysql&amp;gt; create database myapp;Query OK, 1 row affected (0.01 sec)mysql&amp;gt; create user &#39;homestead&#39; identified by &#39;secert&#39;;Query OK, 0 rows affected (0.02 sec)mysql&amp;gt; grant all privileges on myapp.* to &#39;homestead&#39;;Query OK, 0 rows affected (0.01 sec)mysql&amp;gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&amp;gt; quitBye MySQL 8.0.4 이상부터 계정 인증 방식이 변경 mysql&amp;gt; ALTER USER &#39;homestead&#39; IDENTIFIED WITH mysql_native_password BY &#39;secert&#39;; 생성한 새 계정(homestead)으로 로그인을 한다 MySql 접속$ mysql -uhomestead -p스키마와 테이블을 생성한다 스키마, 테이블 생성mysql&amp;gt; use myapp;Database changedmysql&amp;gt; create table posts( -&amp;gt; id int(11) unsigned not null auto_increment primary key, -&amp;gt; title varchar(255), -&amp;gt; body text -&amp;gt; ) engine=innodb default charset=utf8 collate=utf8_unicode_ci;Query OK, 0 rows affected, 3 warnings (0.01 sec)mysql&amp;gt; describe posts;+-------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+----------------+| id | int unsigned | NO | PRI | NULL | auto_increment || title | varchar(255) | YES | | NULL | || body | text | YES | | NULL | |+-------+--------------+------+-----+---------+----------------+3 rows in set (0.01 sec)6.2 REPLREPL(Read-Evalutate-Print-Loop)은 코솔 환경에서 명령을 내리고 실행 결과를 확인 하기 위해 사용하는 도구 팅커(REPL) 콘솔php artisan tinkerNOTE라라벨 명령줄 인터페이스 아티즌$ php artisan [실행할 명령] [명령인자] --[옵션]6.3 데이터베이스 쿼리데이터베이스 접속을 하기 위해 설정파일을 변경 필요 .envDB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=myappDB_USERNAME=homesteadDB_PASSWORD=secert QueryException$ php artisan tinkerPsy Shell v0.10.5 (PHP 7.3.11 — cli) by Justin Hileman&amp;gt;&amp;gt;&amp;gt; db::select(&#39;select * from posts&#39;);=&amp;gt; [] QueryInsert&amp;gt;&amp;gt;&amp;gt; db::insert(&#39;insert into posts(title , body) values(?,?)&#39;,[&#39;Ola Database&#39;,&#39;tinker&#39;]);=&amp;gt; true&amp;gt;&amp;gt;&amp;gt; db::insert(&#39;insert into posts(title , body) values(?,?)&#39;,[&#39;Hello Database&#39;,&#39;tinker2&#39;]);=&amp;gt; truedb는 라라벨의 특수 문법인 파사드(facade)문법이다. insert는 메서드 이름이다.물음표는 PDO::prepare()의 인자를 바인딩하는 문법이다. 사용자 입력값 등을 깨끗하게 세탁한 후 SQL 문장에 바인딩함으로써, SQL 삽입과 같은 악의적인 공격을 원천적으로 차단하기 위해서이다.파사드 파사드는 디자인 패턴의 일종으로 라라벨의 파사드는 디자인 패턴의 파사드가 아닌 라라벨 만의 문법이다. 컬렉션 쿼리배열 형태를 갖는 컬렉션이 반환후, 값에 접근해 본다&amp;gt;&amp;gt;&amp;gt;&amp;gt; $posts = db::select(&#39;select * from posts&#39;);=&amp;gt; [ {#3355 +&quot;id&quot;: 1, +&quot;title&quot;: &quot;Ola Database&quot;, +&quot;body&quot;: &quot;tinker&quot;, }, {#3359 +&quot;id&quot;: 2, +&quot;title&quot;: &quot;Hello Database&quot;, +&quot;body&quot;: &quot;tinker2&quot;, }, ]&amp;gt;&amp;gt;&amp;gt; $posts[0] -&amp;gt; title;=&amp;gt; &quot;Ola Database&quot;컬렉션이 아닌 단일 데이터 인스턴스를 얻을수 있다. 인스턴스 쿼리인덱스 시작은 0 부터가 아닌 1부터 시작한다&amp;gt;&amp;gt;&amp;gt; $post = db::selectone(&#39;select * from posts where id = ?&#39;,[1]);=&amp;gt; {#3366 +&quot;id&quot;: 1, +&quot;title&quot;: &quot;Ola Database&quot;, +&quot;body&quot;: &quot;tinker&quot;, }6.4 쿼리빌더SQL 문장을 PHP 클래스 문법을 사용한다 쿼리 빌더는 db::table(‘posts’)와 같이 무조건 table(string $table) 메서드로 시작해야 한다. get() 메소드로 컬렉션 조회&amp;gt;&amp;gt;&amp;gt; db::table(&#39;posts&#39;)-&amp;gt;get();=&amp;gt; Illuminate\\Support\\Collection {#3376 all: [ {#3371 +&quot;id&quot;: 1, +&quot;title&quot;: &quot;Ola Database&quot;, +&quot;body&quot;: &quot;tinker&quot;, }, {#3377 +&quot;id&quot;: 2, +&quot;title&quot;: &quot;Hello Database&quot;, +&quot;body&quot;: &quot;tinker2&quot;, }, ], } first() , find() 메서드로 인스턴스 조회&amp;gt;&amp;gt;&amp;gt; db::table(&#39;posts&#39;)-&amp;gt;first();=&amp;gt; {#3373 +&quot;id&quot;: 1, +&quot;title&quot;: &quot;Ola Database&quot;, +&quot;body&quot;: &quot;tinker&quot;, }&amp;gt;&amp;gt;&amp;gt; db::table(&#39;posts&#39;)-&amp;gt;find(1);=&amp;gt; {#3369 +&quot;id&quot;: 1, +&quot;title&quot;: &quot;Ola Database&quot;, +&quot;body&quot;: &quot;tinker&quot;, } 원하는 컬럼만 조회 할때&amp;gt;&amp;gt;&amp;gt; db::table(&#39;posts&#39;)-&amp;gt;first(&#39;id&#39;);=&amp;gt; {#3379 +&quot;id&quot;: 1, }&amp;gt;&amp;gt;&amp;gt; db::table(&#39;posts&#39;)-&amp;gt;select(&#39;id&#39;)-&amp;gt;find(1);=&amp;gt; {#3377 +&quot;id&quot;: 1, } 조건절은 where(string array   Closure $column , string $operator = null, mixed $value = null) 메서드로 쿼리 조건을 정의할 수 있다. 조건절&amp;gt;&amp;gt;&amp;gt; db::table(&#39;posts&#39;)-&amp;gt;where(&#39;id&#39;,&#39;=&#39;,1)-&amp;gt;get();=&amp;gt; Illuminate\\Support\\Collection {#3391 all: [ {#3379 +&quot;id&quot;: 1, +&quot;title&quot;: &quot;Ola Database&quot;, +&quot;body&quot;: &quot;tinker&quot;, }, ], }&amp;gt;&amp;gt;&amp;gt; db::table(&#39;posts&#39;)-&amp;gt;where(&#39;id&#39;,1)-&amp;gt;get();=&amp;gt; Illuminate\\Support\\Collection {#3353 all: [ {#3383 +&quot;id&quot;: 1, +&quot;title&quot;: &quot;Ola Database&quot;, +&quot;body&quot;: &quot;tinker&quot;, }, ], }&amp;gt;&amp;gt;&amp;gt; db::table(&#39;posts&#39;)-&amp;gt;whereId(1)-&amp;gt;get();=&amp;gt; Illuminate\\Support\\Collection {#3382 all: [ {#3384 +&quot;id&quot;: 1, +&quot;title&quot;: &quot;Ola Database&quot;, +&quot;body&quot;: &quot;tinker&quot;, }, ], }&amp;gt;&amp;gt;&amp;gt; db::table(&#39;posts&#39;)-&amp;gt;where(function($query){$query-&amp;gt;where(&#39;id&#39;,1);})-&amp;gt;get();=&amp;gt; Illuminate\\Support\\Collection {#3401 all: [ {#3397 +&quot;id&quot;: 1, +&quot;title&quot;: &quot;Ola Database&quot;, +&quot;body&quot;: &quot;tinker&quot;, }, ], } operator 는 등호(=)일 경우, 생략이 가능하다. whereId()는 종적 메서드다. 대등 조건에서만 사용할 수 있으며, 카멜표기법으로 가용 가능하다. 클로저를 사용 가능 하다.추가 메서드 메서드 내용 insert(array $value) 새 레코드 삽입 update(array $value) [‘column’=&amp;gt;’value’]처럼 연관 배열 인자를 넘겨 데이터를 변경한다 delete(int $id) $id에 해당하는 레코드를 삭제한다 pluck(string $column, string $key = null) 인자로 지정한 열의 값으로만 구성된 콜렉션을 조회한다 limit(int $value) 한 번에 조회할 레코드 개수를 제한한다 orderBy(string $column, string $direction = ‘asc’) 조회 결과를 정렬한다. $derection에 허용되는 값은 ‘asc’ 또는 ‘desc’다 6.5 엘로퀀트 ORM엘로퀀트는 러라벨이 제공하는 ORM의 구헌체 이름이다.새로운 테이블을 생성한다 테스트 테이블 및 데이터 만들기$ mysql -uhomestead -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 30Server version: 8.0.22 HomebrewCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.mysql&amp;gt; use myapp;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -Amysql&amp;gt; create table authors( -&amp;gt; id int(11) unsigned not null auto_increment primary key, -&amp;gt; email varchar(255) not null, -&amp;gt; password varchar(60) not null -&amp;gt; ) engine=innodb default charset=utf8 collate=utf8_unicode_ci;Query OK, 0 rows affected, 3 warnings (0.01 sec)mysql&amp;gt; insert into authors(email, password) values(&#39;test@gmail.com&#39;,&#39;test&#39;);Query OK, 1 row affected (0.00 sec)mysql&amp;gt; select * from authors;+----+----------------+----------+| id | email | password |+----+----------------+----------+| 1 | test@gmail.com | test |+----+----------------+----------+1 row in set (0.00 sec)모델을 만들어 보자 모델 만들기$ php artisan make:model PostModel created successfully.$ php artisan make:model AuthorModel created successfully.생성된 모델을 확인해 보자 app/Models/Post.php&amp;lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model{ use HasFactory;} app/Models/Author.php&amp;lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;use Illuminate\\Database\\Eloquent\\Model;class Author extends Model{ use HasFactory;}테이블과 모델이름테이블 이름은 복수로 짓고, 모델이름은 단수로 짓는다테이블은 여러 개의 레코드를 가지고 있기 때문에 복수이고, 모델은 하나의 인스턴스를 담고 있기 때문에 단수를 쓰는 것이 상식적이다.테이블과 모델 이름이 관례를 따르지 않을 때는 엘로퀀스에게 알려 주어야 한다. 테이블 이름을 user라고 했다면, Author 모델에게 protected $table = ‘user’; 처럼 사용할 테이블 이름을 알려 줘야한다class Author extends Model{ protected $table = &#39;users&#39;;}모델 쿼리팅커 콘솔에서 전체 콜렉션을 조회한다. DB 파사드가 아닌 [namespace][class명]모델을 이용한다.(위 예제에서는 App\\Models\\Author) 엘로퀀트 쿼리&amp;gt;&amp;gt;&amp;gt; App\\Models\\Author::get();새 모델 인스턴스를 만들고, 테이블에 저장해본다 엘로컨트로 새로운 레코드 만들기&amp;gt;&amp;gt;&amp;gt; $author = new App\\Models\\Author;=&amp;gt; App\\Models\\Author {#4231}&amp;gt;&amp;gt;&amp;gt; $author-&amp;gt;email = &#39;test@gmail.com&#39;;=&amp;gt; &quot;test@gmail.com&quot;&amp;gt;&amp;gt;&amp;gt; $author-&amp;gt;password = &#39;test&#39;;=&amp;gt; &quot;test&quot;&amp;gt;&amp;gt;&amp;gt; $author-&amp;gt;save();Illuminate\\Database\\QueryException with message &#39;SQLSTATE[42S22]: Column not found: 1054 Unknown column &#39;updated_at&#39; in &#39;field list&#39; (SQL: insert into `authors` (`email`, `password`, `updated_at`, `created_at`) values (test@gmail.com, test, 2021-01-16 14:53:48, 2021-01-16 14:53:48))&#39;엘로퀀트는 updated_at, created_at 컬럼을 생성을 강제 한다. 하지만 테이블에 컬럼이 없기 때문에 에러가 발생 한다.처리방법은 두가지로 1. 컬럼 생성, 2. 엘로컨트 타임스탬프 자동 입력 기능을 끄는 방법 이 있다 app/Models/Author.php&amp;lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;use Illuminate\\Database\\Eloquent\\Model;class Author extends Model{ public $timestamps = false; use HasFactory;}해당 변수확인 방법부모 클래스(model)의 프로퍼티를 오버라이드 된것이다.변경 후, tinker를 재시작 해야한다 30분 삽질 했다 재시도 &amp;gt;&amp;gt; $author = new App\\Models\\Author;=&amp;gt; App\\Models\\Author {#3349}&amp;gt;&amp;gt; $author-&amp;gt;email = &#39;test@email.com&#39;;=&amp;gt; &quot;test@email.com&quot;&amp;gt;&amp;gt; $author-&amp;gt;password = &#39;test&#39;;=&amp;gt; &quot;test&quot;&amp;gt;&amp;gt; $author-&amp;gt;save();=&amp;gt; true 데이터 저장create() 메서드를 이용하면 새코드를 좀 더 편하게 만들수 있다 대량 할당&amp;gt;&amp;gt;&amp;gt; App\\Models\\Author::create([ &#39;email&#39;=&amp;gt;&#39;test2@email.com&#39;, &#39;password&#39;=&amp;gt;bcrypt(&#39;test&#39;) ]);Illuminate\\Database\\Eloquent\\MassAssignmentException with message &#39;Add [email] to fillable property to allow mass assignment on [App\\Models\\Author].&#39;에러가 발생 한다. 위 에러는 무차별 대입 공격(brute force attack)을 막기위해 해당 형태로는 사용 못하 도록 막아 놓은 것이다비말번호해시bcrypt(string $value) 는 60바이트 단방향 패시를 만드는 도우미 함수다.파사드로 사용시 hash::make(‘password’)로 사용 하면 된다.MassAssingnmentException엘로컨트는 무차별 대입 공격(brute force attack)를 방지하기 위하여 두가지 방법을 제공한다. $fillable 프로퍼티를 이용하는 허용 목록(whitelist) 방식 $guarded 프로퍼티를 이용한 금지 목록(blacklist) 방식아래 예제에서는 $fillable 방식을 사용한다. app/Author.php&amp;lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;use Illuminate\\Database\\Eloquent\\Model;class Author extends Model{ public $timestamps = false; protected $fillable = [&#39;email&#39;, &#39;password&#39;]; use HasFactory;} app/Post.php&amp;lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model{ public $timestamps = false; protected $fillable = [&#39;title&#39;, &#39;body&#39;]; use HasFactory;}팅커 콘솔을 재시작 후 실행해본다 재시도Psy Shell v0.10.5 (PHP 7.3.11 — cli) by Justin Hileman&amp;gt;&amp;gt;&amp;gt; App\\Models\\Author::create([ &#39;email&#39;=&amp;gt;&#39;test3@email.com&#39;, &#39;password&#39;=&amp;gt;bcrypt(&#39;test&#39;), ]);=&amp;gt; App\\Models\\Author {#4230 email: &quot;test3@email.com&quot;, password: &quot;$2y$10$c/n4HsoX2Ne.0OVeKG8kGu9zZMPhhacJWvHw0WcId2ljolvyGtJz6&quot;, id: 3, }&amp;gt;&amp;gt;&amp;gt; " }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A804/", "categories": "php", "tags": "", "date": "2021-01-14 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문5. 블레이드블레이드는 아아벨의 템플릿 언어인 동시에 HTML 컴파일 엔진이다.템플릿 언어는 다음의 특징을 가진다. 변수를 이용한 문자열 보간(string interpolation) 제어구조(control structure) 템플릿 상속 조각(portal) 뷰 삽입블레이드 엔진은 템플릿을 PHP 스크립트로 컴파일하고, 이렇게 변환된 PHP파일을 PHP엔진이 다시 HTML로 컴파일한다. 블레이드 문법으로 쓴 템플릿은 .blade.php 확장자를 가져야 하며, resources/views 디렉터리 아래에 저장해야 한다.5.1 변수를 이용한 문자열 보간 resources/views/welcome.blade.php ( 5.7 이하)&amp;lt;h1&amp;gt;{{ $greeting or &#39;Hello&#39; }} {{ $name or &#39;&#39;}}&amp;lt;/h1&amp;gt; resources/views/welcome.blade.php ( 5.7 이상)&amp;lt;h1&amp;gt;{{ $greeting ?? &#39;Hello&#39; }} {{ $name ?? &#39;&#39;}}&amp;lt;/h1&amp;gt; 블레이드는 문자열 보간을 위해 이중 중괄호({{}})를 이용한다. {{ $name}}은 &amp;lt;?= $name; ?&amp;gt; php 문법과 같다. {{ $greeting or &#39;Hello &#39;}} 는 &amp;lt;=? isset($greeting) ? &quot;{$greeting}&quot; : &#39;Hello&#39;; ?&amp;gt; 와 같다. 이 문법을 사용할 때는 {{$greeting}}처럼 써도 된다. 중괄호와 변수 사이의 공백은 개인의 취향이다.블레이드는 XSS 공격으로부터 서비스를 보호하기 윈해 문자열을 보간한 때 특수 문자를 이스케이프한다. 이스케이프하지 않은 채로 문자열을 뷰에 포함하려면 {!! $var!!}문법을 이용한다.몇몇 자바스크립트에서 프레임워크도 {{}}를 문자열 보간 문법으로 사용한다. 브레이드 내의 자바스크립에서 문자열 보간을 사용한다면 @{{}} 문법을 사용해야 한다.5.2 주석블레이드에서 주석은 {{--주석--}} 형식을 사용한다. resources/views/welcome.blade.php{{--HTEML 주석으로 표시 됩니다.--}}&amp;lt;h1&amp;gt;{{ $greeting or &#39;Hello&#39; }} {{ $name or &#39;&#39;}}&amp;lt;/h1&amp;gt; 5.3 제어 구조블레이드는 모든 제어 구조에 이메일기호(@)를 이용하고, end로 시작하는 키워드로 제어 구조의 끝을 표시한다.조건문 routes/web.phpRoute::get(&#39;/&#39;, function () { $items = [&#39;사과&#39;,&#39;포도&#39;,&#39;딸기&#39;]; return view(&#39;welcome&#39;,[&#39;items&#39; =&amp;gt; $items]);}); resources/views/welcome.blade.php@if ($itemCount = count($items)) &amp;lt;p&amp;gt;{{$itemCount}} 종류의 과일이 있습니다.&amp;lt;/p&amp;gt;@else &amp;lt;p&amp;gt;아무것도 없습니다.&amp;lt;/p&amp;gt;@endif@elseif , @unless(조건식) 도 사용 가능하다. * @unless는 @if(! 조건식)과 의미가 같다반복문 resources/views/welcome.blade.php&amp;lt;ul&amp;gt;@foreach ($items as $item) &amp;lt;li&amp;gt;{{ $item }}&amp;lt;/li&amp;gt;@endforeach&amp;lt;/ul&amp;gt;@for, @while 도 사용가능하며 배열값이 없을 경우, 처리하는 @forelse도 있다.&amp;lt;?php $items = [] ?&amp;gt;와 같이 호출되는 블레이드에서 변수에 할당된 값을 오버라이딩 할 수 있다. resources/views/welcome.blade.php&amp;lt;ul&amp;gt;@forelse ($items as $item) &amp;lt;li&amp;gt;{{ $item }}&amp;lt;/li&amp;gt;@empty &amp;lt;li&amp;gt;값이 없습니다.&amp;lt;/li&amp;gt;@endforelse&amp;lt;/ul&amp;gt;5.4 템플릿 상속최상위 부모 템플릿인 마스터레이아웃을 만들어 보자. resources/views/layouts 디렉터리를 만들고 코드를 작성한다. resources/views/layouts/master.blade.php&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt; &amp;lt;title&amp;gt;라라벨 입문&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; @yield(&#39;content&#39;)&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;마스터 레이아웃을 상속 받도록 welcome.blade.php를 수정한다. resources/views/welcome.blade.php@extends(&#39;layouts.master&#39;)@section(&#39;content&#39;) &amp;lt;p&amp;gt;저는 자식 뷰의 컨텐츠 섹션입니다.&amp;lt;/p&amp;gt;@endsection@yield(섹션명) 으로 해당 부모의 레이아웃에 자식의 내용을 표출 가능하다.5.5 조각 뷰 삽입블레이드로 정의된 뷰에서 다른 조각 뷰를 가져다가 삽입 가능하다.조각뷰를 만들어 본다 resources/views/parials/footer.blade.php&amp;lt;footer&amp;gt; &amp;lt;p&amp;gt;저는 꼬리말입니다. 다른 뷰에서 저를 사용합니다.&amp;lt;/p&amp;gt;&amp;lt;/footer&amp;gt;다른 뷰에서 @include를 이용해서 사용한다. resources/views/welcome.blade.php@extends(&#39;layouts.master&#39;)@section(&#39;content&#39;) @include(&#39;partials.footer&#39;)@endsection섹션 명이 중복될 경우 resources/views/layouts/master.blade.php&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt; &amp;lt;title&amp;gt;라라벨 입문&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; @yield(&#39;content&#39;) @yield(&#39;script&#39;)&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; resources/views/parials/footer.blade.php@section(&#39;script&#39;) &amp;lt;script&amp;gt; alert(&quot;조각뷰의 섹션입니다.&quot;); &amp;lt;/script&amp;gt;@endsection resources/views/welcome.blade.php@extends(&#39;layouts.master&#39;)@section(&#39;content&#39;) @include(&#39;partials.footer&#39;)@endsection@section(&#39;script&#39;) &amp;lt;script&amp;gt; alert(&quot;자식 뷰의 섹션입니다&quot;); &amp;lt;/script&amp;gt;@endsection조각뷰의 섹션입니다가 호출 된다. 둘다 호출하려면 조각뷰쪽 코드를 수정한다 resources/views/parials/footer.blade.php@section(&#39;script&#39;) @parent &amp;lt;script&amp;gt; alert(&quot;조각뷰의 섹션입니다.&quot;); &amp;lt;/script&amp;gt;@endsection" }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A803/", "categories": "php", "tags": "", "date": "2021-01-13 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문4. 뷰와 데이터 바인딩4.1 뷰 반환라레벨의 뷰 파일은 resoures/views 디렉터리에 있다. routes/web.phpRoute::get(&#39;/&#39;, function () { return view(&#39;errors.503&#39;);});규칙 하위 디렉터리에 있는 뷰 파일은 점(.)또는 슬러시(/)로 참조 할 수 있다. 뷰 파일은 파일이름.blade.php와 같은 모양이다.(라레벨 템플릿 미사용지 .php도 사용 가능) 인자로 넘기는 값은 .blade.php 를 제외한 파일 이름을 넘긴다.추가 view(string #view , array $data = []) 함수 대신 view::make(string $view , array $data = []) 파사드를 사용해도 무방하다. php artisan down : 유지보수 상태 on php artisan up : 서비스 상태 복구4.2 데이터 바인딩with() 메서드 이용방법view() 함수에 아무 인자도 넘기지 않으면 뷰 인스턴스를 반환한다. 그 인스턴스에 with() 메서드를 체인하여 데이터를 바인딩 할 수 있다. routes/web.phpRoute::get(&#39;/&#39;, function () { return view(&#39;welcome&#39;)-&amp;gt;with(&#39;name&#39;,&#39;Foo&#39;);}); resources/views/welcome.blade.php&amp;lt;h1&amp;gt;&amp;lt;?= isset($greeting)? &quot;{$greeting}&quot; : &#39;Hello&#39;; ?&amp;gt;&amp;lt;?= $name; ?&amp;gt;&amp;lt;/h1&amp;gt;배열을 이용해서 여러 개의 데이터를 넘겨본다 routes/web.phpRoute::get(&#39;/&#39;, function () { return view(&#39;welcome&#39;)-&amp;gt;with([ &#39;name&#39; =&amp;gt; &#39;Foo&#39;, &#39;greeting&#39; =&amp;gt; &#39;안녕하세요&#39; ]);});실전 코드보통 view()의 두 번째 인자로 데이터를 넘긴다. routes/web.phpRoute::get(&#39;/&#39;, function () { return view(&#39;welcome&#39;,[ &#39;name&#39; =&amp;gt; &#39;Foo&#39;, &#39;greeting&#39; =&amp;gt; &#39;안녕하세요&#39; ]);});" }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A802/", "categories": "php", "tags": "", "date": "2021-01-12 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문1.1 새로운 라라벨 프로젝트 만들기 라라벨 설치--verbose 옵션은 생략 가능$ composer create-project laravel/laravel myapp --prefer-dist --verbose 라라벨 설치 확인$ cd myapp$ php artisan --version 로컬 서버 구동$ php artisan serve --port=80801.2 라라벨 프로젝트 구조|- .evn # 글로벌 설정|- app | |-Console # 콘솔 명령어 담는 디렉터리| | |- Kernel.php #| || |- Exceptions| | |- Handler.php| || |-Http| | |- Controllers| | | ㄴ Auth| | |- Kernel.php| | |- Middleware| | | |-Providers| | |- AppServiceProvider.php| | |- AuthServiceProvider.php| | |- BroadcastServiceProvider.php| | |- EventServiceProvider.php| | |- RouteServiceProvider.php| || |- User.php| |- bootstrap|- composer.json|- composer.lock|- config|- database| |- factories| |- migrations| |- seeds||- gulpfile.js|- pakage.json|- phpunit.xml|- public|- resources| |- assets| |- lang| |- views||- routes| |- api.php| |- console.php| |- web.php||- server.php|- storage|- tests|- vendor1.3 라라벨 작동 원리 사용자는 브라우저에서 http://example.com/about 페이지 요청을 한다. 사용자의 요청은 example.com 이라는 이름을 가진 서버에 도착한다. 웹 브라우저가 HTTP 프로토콜로 요청했으므로 example.com 서버의 웹 서버가 요청을 처리한다. 웹 서버는 URL을 해석하고 자신이 해결할 수 있는 파일이면, 파일을 읽어서 곧바로 응답한다.(CSS , 이미지등 정적 데이터) 자신이 해결할 수 없는 파일이면 웹 서버 설정에 따라 작업을 PHP에게 넘긴다. PHP에게 작업을 넘길 때는 index.php 를 향하도록 URL 경로를 변경하여 넘긴다. index.php에는 라라벨의 부팅 시퀀스가 담겨 있다. 라라벨은 routes/web.php에 정의한 라우팅 테이블에서 about을 찾는다 (라우팅) 일치하는 라우트가 없다면 웹 서버에게 적절한 오류 응답을 반환한다.(전역 예외 처리기) 일치하는 라우트가 있다면 전역 미들웨어와 about 라우트에 정의한 라우트 미들웨어가 HTTP 요청을 필터링한다.(미들웨어) 미들웨어를 통과하지 못하면 예외가 발생한다. 전역 예외 처리기는 웹 서버에게 적절한 HTTP 응답을 반환한다. 미들웨어를 통과하면 비소로 about 요청을 처리할 컨트롤러에게 작업이 도달한다.(컨트롤러) 컨트롤러는 HTTP 요청을 처리한다. 이때 라라벨 컴포넌트, 외부 컴포넌트의 기능, 우리가 만든 기능 등을 이용한다. 처리가 끝나면 HTTP 응답을 만들고 반환한다. 컨트롤러는 요청을 처리하는 과정에 데이터베이스와 통신을 하기도 한다(엘로퀀트) 컨트롤러는 웹 서버에게 돌려줄 HTTP 응답 본문을 만들 때 템플릿 엔진을 이용하기도 한다.(블레이드) 웹 서버는 PHP/라라벨 측으로부터 넘겨받은 HTTP 응답을 브라우저에 돌려준다 2. 전역 환경 설정2.1 dotenv 파일이 하는 일 .gitignore/verdor/node_modules/pulbic/storage.env설정 정보(.env)를 저장하시는 않지만, 설정 정보를 처리하는 파일(config/*)은 git으로 관리한다 .env...DB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=laravelDB_USERNAME=rootDB_PASSWORD=... config/database.php...&#39;mysql&#39; =&amp;gt; [ &#39;driver&#39; =&amp;gt; &#39;mysql&#39;, &#39;url&#39; =&amp;gt; env(&#39;DATABASE_URL&#39;), &#39;host&#39; =&amp;gt; env(&#39;DB_HOST&#39;, &#39;127.0.0.1&#39;), &#39;port&#39; =&amp;gt; env(&#39;DB_PORT&#39;, &#39;3306&#39;), &#39;database&#39; =&amp;gt; env(&#39;DB_DATABASE&#39;, &#39;forge&#39;), &#39;username&#39; =&amp;gt; env(&#39;DB_USERNAME&#39;, &#39;forge&#39;), &#39;password&#39; =&amp;gt; env(&#39;DB_PASSWORD&#39;, &#39;&#39;), &#39;unix_socket&#39; =&amp;gt; env(&#39;DB_SOCKET&#39;, &#39;&#39;), &#39;charset&#39; =&amp;gt; &#39;utf8mb4&#39;, &#39;collation&#39; =&amp;gt; &#39;utf8mb4_unicode_ci&#39;, &#39;prefix&#39; =&amp;gt; &#39;&#39;, &#39;prefix_indexes&#39; =&amp;gt; true, &#39;strict&#39; =&amp;gt; true, &#39;engine&#39; =&amp;gt; null, &#39;options&#39; =&amp;gt; extension_loaded(&#39;pdo_mysql&#39;) ? array_filter([ PDO::MYSQL_ATTR_SSL_CA =&amp;gt; env(&#39;MYSQL_ATTR_SSL_CA&#39;), ]) : [], ],...위 소스에서 보듯이, 설정파일 정보(전역변수)를 가져와 설정 처리에서 그 값을 사용한다2.2 APP 환경 설정 .envAPP_ENV=local# 어플리케이션 실행 환경을 선언한다. 현재 값인 local은 임의의 값이다. 통상적으로 local, staging, testing, production 등의 값을 사용한다. local은 로컬 컴퓨터, pordution은 운영 서버에서 사용한다APP_DEBUG=true디버그 옵견 활성화 여부를 정의한다. true는 로컬 환경에서만 사용해야 한다. true로 설정하면 예외에 관한 상세한 역추적 로거가 화면에 출력된다. 운영 환경에서 이 새용이 표시되면 해커의 공격 대상이 될 수 있으니 주의APP_KEY=base64:xxxxxxxxxxxxxxxxxxxxx프레임워크 전반에 걸쳐 암호화 알고리즘의 키 값으로 사용되는 값이다. 예를 들면 브라우저와 주고받는 암호화된 쿠키를 만들거나 해독할 때 사용한다.SomeRandomString으로 값이 채워져 있거나 비어있다면, 다음 명열으로 새로운 암호화 키를 만들다. 또한, 다른 실행환경에 코드를 처음 배포했을 때도 다음 명령으로 암호화 키를 만들 수 있다.$ php artisan key:generateAPP_URL=http://localhost콜솔에서는 $_SERVER[&#39;HTTP_HOST&#39;] 값이 없다. 아티등 녈령줄 인터페이스는 이 설정을 대체 값(fallback)으로 사용한다.3. 라우팅3.1 URL라벨에서는 .php가 없는 URL을 사용한다.3.2 라우팅 만들기index 페이지를 수정해 본다 resources/views/welcome.blade.php&amp;lt;h1&amp;gt;hello, Laravel&amp;lt;/h1&amp;gt;설정 파일 변경시, 서버 재부팅이 필요하다웹 서버의 루트 다렉터리는 public 이다. 다음을 확인 해보자 routes/web.phpRoute::get(&#39;/&#39;, function () { return view(&#39;welcome&#39;);});/ 요청이 들어오면 , view() 함수를 실행하며, 해당 &#39;welcome&#39;이라는 인자가 resources/views/welcome.blade.php 로 매핑된다.3.3 URL 파라미터파라미터 처리를 위해선 중괄호를 사용한다 routes/web.php# http://127.0.0.1:8000/파라미터Route::get(&#39;/{foo}&#39;, function ($foo) { return $foo;});기본값 설정 routes/web.php# http://127.0.0.1:8000/파라미터Route::get(&#39;/{foo?}&#39;, function ($foo = &#39;기본값&#39;) { return $foo;});파라미터 중간 설정 routes/web.php# http://127.0.0.1:8000/파라미터/testRoute::get(&#39;/{foo?}/test&#39;, function ($foo = &#39;기본값&#39;) { return $foo;});정규 표현식 사용하여 필터링이 가능하다 routes/web.phpRoute::pattern(&#39;foo&#39;,&#39;[0-9a-zA-z]{3}&#39;);Route::get(&#39;/{foo?}&#39;, function ($foo = &#39;기본값&#39;) { return $foo;});메서드 체인 routes/web.phpRoute::get(&#39;/{foo?}&#39;, function ($foo = &#39;기본값&#39;) { return $foo;})-&amp;gt;where(&#39;foo&#39;,&#39;[0-9a-zA-Z]{3}&#39;);3.4 라우트 이름Route::get() 메서드의 두 번째 인자를 배열로 전달하는데, 배열 원소에 &#39;as&#39; =&amp;gt; &#39;라우트_이름&#39; 을 정의하면 사용 가능 routes/web.phpRoute::get(&#39;/&#39;, [ &#39;as&#39; =&amp;gt; &#39;home&#39;, function () { return &#39;메인 화면 입니다&#39;; }]);Route::get(&#39;/home&#39;, function(){ return redirect(route(&#39;home&#39;));});위 redirect() 와 route()는 도우미 함수다" }, { "title": "라라벨로 배우는 php 웹 프로그래밍", "url": "/posts/%EB%9D%BC%EB%9D%BC%EB%B2%A801/", "categories": "php", "tags": "", "date": "2021-01-10 00:00:00 +0900", "snippet": "라라벨로 배우는 실전 PHP 웹 프로그래밍PART 1 라라벨 입문1. 라라벨 설치사용 기본 요건 php 5.6.4 이상 ponessl php 확장 모듈 - 암복호화, 해시를 위해 필요한 모듈 pdo php 확장 모듈 - php와 데이터베이스를 연셜하는 모듈 mbstring php 확장 모듈 - 멀티바이트 문자열 처리를 위한 모듈 tokenizer php 확장 모듈 - php 파서, 아티즌 콘솔 등의 동작에 필요한 모듈1.1 개발 도구 설치홈블루 MAC용 패키지 관리 도구 홈블루 설치 및 설치 확인# homebrew install로 구글링 하여 복사하여 사용$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;$ brew --versionPHPphp 7,0 설치 php 텝 추가$ brew tap homebrew/php$ brew search php70 Touble shooting homebrew/php was deprecated. How i can install only php7.0 by homebrew?$ brew tap exolnet/homebrew-deprecated$ brew reinstall --build-from-source php@7.0 php 설치 및 설치 확인$ brew install homebrew/php/php70$ php --versionMySql mysql_secure_installation 의 첫 질문에 N로 선택해야 짧은 비번을 설정 가능하다 MySql 설치 및 설치 확인$ brew install mysql$ mysql --version$ mysql_secure_installation$ brew tap homebrew/services MySql 시작과 종료$ brew services start mysql # 시작$ brew services stop mysql # 종료컴포저 php 표준 의존성 관리 도구 컴포저 설치$ brew install homebrew/php/composer$ composer --version or$ curl -sS https://getcomposer.org/installer | sudo php -- --install-dir=/usr/local/bin/ $ sudo ln -s /usr/local/bin/composer.phar /usr/local/bin/composerPHP 확장 모듈 PHP 확장 모듈 확인$ php -m | grep &#39;openssl\\|pdo\\|mbstring\\|tokenizer&#39; PHP 내장 웹 서버 실행$ php artisan serve --host=0.0.0.0 --port-8001" }, { "title": "자바스터디 8주차", "url": "/posts/whiteship-study-8week/", "categories": "study", "tags": "", "date": "2021-01-08 00:00:00 +0900", "snippet": "GOAL 자바의 인터페이스에 대해 학습하세요학습할 것 (필수) 인터페이스 정의하는 방법 인터페이스 구현하는 방법 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법 인터페이스 상속 인터페이스의 기본 메소드 (Default Method), 자바 8 인터페이스의 static 메소드, 자바 8 인터페이스의 private 메소드, 자바 9인터페이스 정의하는 방법인터페이스란?인터페이스란 어원과 같이 대상간의 서로 약속된 규약으로써 이용된다. (이러한 규약은 정하기 나름이다. 어떤 나라는 악수를 하면 인사라고 생각하며, 어떤 나라는 볼에 키스를 해서 인사를 표현한다.) 규약이란 사용을 강제 하는 것이다.아래의 예를 살펴보자public interface Monitor { int _GLOBAL=0; void on(); void off();}컴파일 코드public interface week8.Monitor { public static final int _GLOBAL; public abstract void on(); public abstract void off();}컴파일 소스를 보면 인터페이스에서 선언된 변수에는 public static final, 메소드에는 public abstract 가 붙는 것은 알 수 있다.이로 인해 우리는 첫째 인터페이스 내부의 변수는 재할당이 불가능 하며, 두번째 추상 메소드와 같이 상속 받은 자식 메소드에서 구현부를 구현 해야 한다는 것을 알 수 있다. 추가접근 제어자로는 public 과 default를 사용한다인터페이스 구현하는 방법위에서 만든 Monitor의 구현체를 만들어 보자public class LG implements Monitor{ public void globalValue(){ System.out.println(_GLOBAL); } @Override public void on() { System.out.println(&quot;LG on&quot;); } @Override public void off() { System.out.println(&quot;LG off&quot;); }}public class SONY implements Monitor{ public void globalValue(){ System.out.println(_GLOBAL); } @Override public void on() { System.out.println(&quot;sony on&quot;); } @Override public void off() { System.out.println(&quot;sony off&quot;); }}컴파일 소스public class week8.LG implements week8.Monitor { public week8.LG(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void globalValue(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: iconst_0 4: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 7: return public void on(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #5 // String LG on 5: invokevirtual #6 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return public void off(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #7 // String LG off 5: invokevirtual #6 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}public class week8.SONY implements week8.Monitor { public week8.SONY(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void globalValue(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: iconst_0 4: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 7: return public void on(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #5 // String sony on 5: invokevirtual #6 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return public void off(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #7 // String sony off 5: invokevirtual #6 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}인터페이스의 구현은 implements라는 예약어를 통해 인터페이스를 상속받으면, 구현가능하다.상속받은 구현체(위 예제의 LG,SONY)는 인터페이스의 메소드를 반드시 구현 해야만 한다.이것이 위에서 설명한 규약 의 이점이다. 예를 들어 모니터를 생산하는 업체가 100개 라고 가정했을때어떤 업체는 100볼트에 사각형으로 생긴 코드를, 다른 업체는 별모양으로 생긴 코드를 만들었다고 생각해 보면사용자의 입장에서는 모니터를 구매할 때 마다 새로운 코드를 어뎁터를 구매해야 할것 이다.인터페이스 레퍼런스를 통해 구현체를 사용하는 방법사용법을 알아보자 이전에 배운 상속과 유사하다. 코드를 보자public class Test { public static void main(String[] args) { Monitor monitor = new LG(); monitor.on(); }}컴파일소스public class week8.Test { public week8.Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class week8/LG 3: dup 4: invokespecial #3 // Method week8/LG.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: aload_1 9: invokeinterface #4, 1 // 실제 인터페이스를 처리 InterfaceMethod week8/Monitor.on:()V 14: return}상속과 비슷하게 인터페이스에 구현체를 할당 받아 사용 가능 하다.할당받은 인터페이스 변수는 인터페이스에 있는 메소드만 사용 가능하다. invokeinterface인터페이스를 처리하는 컴파일러의 코드로 자세한 사항은 이곳에서 살펴보자 추가익명 객체로 구현체를 만들지 않고 잠깐만 구현하여 사용할 수 있다.public class Test { public static void main(String[] args) { Monitor monitor = new Monitor() { @Override public void on() { } @Override public void off() { } }; }}컴파일 소스public class week8.Test { public week8.Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class week8/Test$1 3: dup 4: invokespecial #3 // Method week8/Test$1.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: return}인터페이스 상속인터페이스의 상속은 기존 상속과 차이점이 있다 인터페이스를 상속 받은 클래스는 인터페이스의 모든 메소드를 구현 해야한다 인터페이스는 다중 상속 이 가능하다다중 상속이 가능 하기 때문에 메소드 시그니처가 같은 인터페이스를 동시에 상속 받는 경우, 컴파일 에러가 발생 한다.인터페이스의 기본 메소드 (Default Method), 자바 8자바 8 버전에서 추가된 기능으로, 추상 메소드에서 사용하듯이 default 키워드를 이용 하여, 추가된 기능이 구현된 인터페이스를 제공 할 수 있게 되었다.아래의 예시를 보자public interface Monitor { void on(); void off(); default void add(){ System.out.println(&quot;add&quot;); }}컴파일소스public interface week8.Monitor { public abstract void on(); public abstract void off(); public default void add(); Code: 0: getstatic #1 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #7 // String add 5: invokevirtual #9 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}위 처럼 생성한 메소드는 상속 받은 구현체에서 구현하지 않아도, 레퍼런스에서 사용 가능 하다public class Test { public static void main(String[] args) { Monitor monitor = new LG(); monitor.add(); }}컴파일 소스public class week8.Test { public week8.Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #7 // class week8/LG 3: dup 4: invokespecial #9 // Method week8/LG.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: aload_1 9: invokeinterface #10, 1 // InterfaceMethod week8/Monitor.add:()V 14: return}사용되는 메소드는 invokeinterface로 기존 인터페이스와 동일하다인터페이스의 static 메소드, 자바 8유틸형 클래스에 사용하는 static 또한 지원된다. 인터페이스에 구현하여 유틸성으로 이용 할 수 있다.public interface Monitor { static void whiteUp(){ System.out.println(&quot;whiteUp&quot;); };}public class Test { public static void main(String[] args) { Monitor.whiteUp(); }}컴파일소스public interface week8.Monitor { public static void whiteUp(); Code: 0: getstatic #1 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #7 // String whiteUp 5: invokevirtual #9 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}public class week8.Test { public week8.Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: invokestatic #7 // InterfaceMethod week8/Monitor.whiteUp:()V 3: return}사용되는 메소드는 invokestatic로 인터페이스의 invokeinterface를 사용하지 않는다인터페이스의 private 메소드, 자바 9인터페이스 내부에서만 사용 가능한 private 메소드가 추가 되어 내부적인 처리가 필요 할 경우, 이용 가능하도록 기능이 추가 되었다public interface Monitor { static void whiteUpStatic(){ printStatic(); }; private static void printStatic(){ System.out.println(&quot;whiteUpStatic&quot;); } default void whiteUp(){ print(); } private void print(){ System.out.println(&quot;whiteUp&quot;); }}public class Empty implements Monitor{}public class Test { public static void main(String[] args) { Monitor.whiteUpStatic(); Monitor monitor = new Empty(); monitor.whiteUp(); }}컴파일 소스public interface week8.Monitor { public static void whiteUpStatic(); Code: 0: invokestatic #1 // InterfaceMethod printStatic:()V 3: return public default void whiteUp(); Code: 0: aload_0 1: invokeinterface #21, 1 // InterfaceMethod print:()V 6: return}public class week8.Empty implements week8.Monitor { public week8.Empty(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return}public class week8.Test { public week8.Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: invokestatic #7 // InterfaceMethod week8/Monitor.whiteUpStatic:()V 3: new #12 // class week8/Empty 6: dup 7: invokespecial #14 // Method week8/Empty.&quot;&amp;lt;init&amp;gt;&quot;:()V 10: astore_1 11: aload_1 12: invokeinterface #15, 1 // InterfaceMethod week8/Monitor.whiteUp:()V 17: return}Monitor 클래스를 살펴보면 private 메소드는 컴파일소스에서 확인 불가능 하다. 때문에 상속받은 클래스에서 사용이 불가하며 이를 이용하여 캡슐화를 진행 할 수 있다 첨언위에서 설명 했듯이 인터페이스는 규약에 가깝다 하지만, static 이나 default 메소드는 규약에 적혀있지 않은 편법 에 가깝다고 생각한다. 너무 지나친 자유는 오히려 독이 될수 있다.참조인터페이스" }, { "title": "자바스터디 7주차", "url": "/posts/whiteship-study-7week/", "categories": "study", "tags": "", "date": "2020-12-28 00:00:00 +0900", "snippet": "GOAL 자바의 패키지에 대해 학습하세요.학습할 것 (필수) package 키워드 import 키워드 클래스패스 CLASSPATH 환경변수 -classpath 옵션 접근지시자package 키워드 package자바에서 유사한 개념을 그룹화 하는 개념으로, 내장 패키지 와 사용자정의 패키지 가 있다. 내장 패키지 는 자바에서 기본적으로 제공1하는 클래스나 인터페이스 등이 속해있는 패키지이며, 사용자 정의 패키지 는 사용자가 추가로 생성한 패키지 이다. 왜 쓰나요? 클래스, 인터페이스 등을 분리 하여, 유지보수 를 쉽게 할 수 있다 접근제어자를 통한 접근 분리 를 할 수 있다. 같은 이름 의 클래스, 인터페이스를 사용 가능하다.import 키워드자바에서 다른 패키지를 사용시, 사용되는 키워드로 같은 패키지 의 클래스를 호출 하거나, java.lang 패키지 내부의 클래스를 사용시에는 해당 키워드를 사용하지 않아도 된다. import 사용 방법자바에서는 3가지의 사용 방법을 제공 하고 있다. import 패키지명.* import 패키지명.클래스명 풀 패키지 경로(fully qualified name)1. import 패키지명.*패키지명.* 사용시 해당 패키지안의 모든 클래스나 인터페이스 등을 사용가능가지만, 하위 패키지 의 내용은 사용이 불가능 하다.예제import test.*;public class Test { public static void main(String[] args) { TestA testA = new TestA(); }} 컴파일 소스public class Test { public Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #7 // class test/TestA 3: dup 4: invokespecial #9 // Method test/TestA.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: return}패키지에 대한 정보는 바이트코드에 반영되지 않는다.2. import 패키지명.클래스명패키지명.클래스명 사용시, 사용할 클래스나 인터페이스를 특정하여 사용 가능하다.예제import test.TestA;public class Test { public static void main(String[] args) { TestA test = new TestA(); }} 컴파일 소스public class Test { public Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #7 // class test/TestA 3: dup 4: invokespecial #9 // Method test/TestA.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: return}패키지에 대한 정보는 바이트코드에 반영되지 않는다.3. 풀 패키지 경로(fully qualified name)import를 사용하지 않고, 사용하는 방식이다. 변수 생성시, 클래스 명이 아닌 해당 클래스의 전체 경로를 입력하여 사용한다. 같은 이름의 클래스를 사용하는 변수를 사용시 이용한다.public class Test { public static void main(String[] args) { test.TestA test = new test.TestA(); }} 컴파일 소스public class Test { public Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #7 // class test/TestA 3: dup 4: invokespecial #9 // Method test/TestA.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: return}패키지에 대한 정보는 바이트코드에 반영되지 않는다.PATH VS CLASSPATH자바에서 Path와 ClassPath를 환경 설정에 이용한다. 차이점 Path classPath 정의 자바 프로그램을 실행하고 자바 소스 파일을 컴파일하는 데 사용되는 “ java “또는 “ javac “명령 과 같은 JDK 바이너리를 찾는 데 사용되는 환경 변수 System 또는 Application ClassLoader 에서 .class 파일에 저장된 Java 바이트 코드를 찾아서로드 하는 데 사용되는 환경 변수 설정내용 JDK_HOME / bin 디렉토리 .class 파일 또는 JAR 파일을 넣은 모든 디렉토리 변경가능여부 불가능 “java “및 “ javac “명령 모두에 명령 줄 옵션 -classpath 또는 -cp 를 제공 하거나 Class-를 사용하여 CLASSPATH를 재정의 가능 사용 운영체제에서 바이너리타입이나 클래스 타입에 이용된다 오직 자바의 classLoader에서만 사용된다 클래스패스자바 컴파일러는 실행시켜야 하는 클래스 파일의 위치를 알아야 하는데 그 클래스 파일의 위치를 클래스패스 를 라고 부른다.위에 설명한 내용과 같이, 클래스 패스는 클래스 로더에서 사용하는 환경변수 이다.CLASSPATH 환경변수CLASSPATH 명령어를 사용해서 설정이 가능하다.윈도우 https://blog.opid.kr/62맥vi /etc/profileexport CLASSPATH=.:$JAVA_HOME/lib/tools.jar-classpath 옵션CLI로 쉘등에서 javac를 이용하여 사용 가능하다. Test폴더와 같은 위치에 있을때윈도우java -cp &quot;.;Test&quot; Test맥java -cp &quot;.:Test&quot; Test 어떻게 제 소스가 실행되는거죠?classLoader는 classpath를 기준으로 파일 위치를 확인 하여 실행한다. 여기서 중요한 점은 classPath를 분석할때 java파일의 최상단에 선언된 package 키워드 를 기반으로 해당 클래스를 찾아내는 것이다.지시자자바에는 두가지 종류의 지시자를 제공하고 있으며, 접근 지시자 와 비 접근 지시자 가 있다.비 접근 지시자종류가 많아 추후 추가예정접근지시자필드, 메소드, 생성자 또는 클래스의 접근 가능여부 또는 범위를 지정하며, 접근 지시자를 적용하여 필드, 생성자, 메서드 및 클래스의 접근 가능 범위을 변경할 수 있다 총 4가지 접근지시자가 있다.참고이미지(출처[https://kils-log-of-develop.tistory.com/430]) 왜 쓰나요모르는게 약이다라는 말이 있다. OOP 세상에서 객체는 살이있는 능동적인 존재다. 사람이 모든 일을 할 수 없듯이, 객체가 모든 것을 알지 못 하게 하는 것도 중요하다. 생각해 보자 대통령의 고조 할아버지 생애를 알아야 한다는 법률이 제정된다면, 누가 좋아 할 것인가? OOP에서 프로그래머의 명령은 법이나 마찬가지다. 어쩌면 우리 컴파일 에러를 볼때마다, 클래스 입장에서는 처벌을 받는 것일 지도 모른다.예제참고javatpoint클래스패스what-is-path-and-classpath-in-java-difference생활코딩-클래스패스1: java, lang, awt, javax, swing, net, io, util, sql" }, { "title": "맥의 세상에 빠지다_처음 시작하는 맥북 가이드", "url": "/posts/%EB%A7%A5%EC%84%B8%EC%83%81%EC%97%90/", "categories": "books", "tags": "", "date": "2020-12-27 00:00:00 +0900", "snippet": "finder 살펴보기 단축키 command + n보기 방식 변경 아이콘 보기 방식 ( command + 1 ) 목록 보기 방식 ( command + 2 ) 계층 보기 방식 ( command + 3 ) 커버플로우 보기 방식 ( command + 4 )탭 사용하기 텝 막대 보기 ( shift + command + t ) 탭 막대 추가 ( command + t )설정 command + , 폴더를 새로운 윈도우 대신 탭에서 열기( command 버튼을 누른 상태에서 퐇ㄹ더를 더블클릭 했을 경우, 새로운 Finder창 대신 텝을 생성)삭제 단축키 command + delete 한영 변환 control + space bar " }, { "title": "키보드", "url": "/posts/%ED%82%A4%EB%B3%B4%EB%93%9C/", "categories": "tools", "tags": "", "date": "2020-12-21 00:00:00 +0900", "snippet": "ROG FALCHION이번에 신규 출시된 따끈따끈한 신상이다.지난달 27일 예약 구매하여, 18일날 도착하였다.홈장비는 모니터를 제외하고, ASUS 제품으로 이용중이다.오픈케이스대망의 작동 사진키감도 좋고 잘 사용중이다. 그런데 문제가 있다.제품끼리 간섭이 있는건지 사용중에 갑자기 윈도우 소리가 28까지 올라가는 현상있다…원인은 모르겠다.. AS문의를 해봐야 할지도…박스하나 더 모았다 히히…" }, { "title": "자바스터디 6주차", "url": "/posts/whiteship-study-6week/", "categories": "study", "tags": "", "date": "2020-12-20 00:00:00 +0900", "snippet": "GOAL 자바의 상속에 대해 학습하세요.학습할 것 (필수)자바 상속의 특징Java의 상속은 하나의 객체가 부모 객체의 모든 속성과 동작을 획득하는 방법이다. 기본개념은 기존에 만들어 놓은 클래스를 기반으로 하는 새 클래스를 만들어 사용하는 것으로,상속을 받은 클래스의 경우, 기존의 클래스의 기능을 사용하는 것은 물론, 기존 클래스의 기능을 수정, 신규 메소드의 추가, 필드의 추가를 할 수 있다. 보통 부모-자식관계라고 하며 IS-A 관계이다. 왜 사용하죠? 코드의 재사용을 위해서 유연한 구조 생성을 위해서(이 내용에 대해서는 아래의 오버라이딩, 메소드 디스패치 , 더블 디스패치를 확인) 사용방법클래스 생성시, extend 라는 키워드를 이용하여 사용 가능하다package week6;public class Parent{ public void print(){ System.out.println(&quot;parent&quot;); }} 컴파일 코드public class week6.Parent { public week6.Parent(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void print(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // 런타임 상수풀에 String parent를 push 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}package week6;public class Child extends Parent { public void print(){ System.out.println(&quot;child&quot;); }} 컴파일 코드public class week6.Child extends week6.Parent { public week6.Child(); Code: 0: aload_0 1: invokespecial #1 // Method week6/Parent.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void print(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // 런타임 상수풀에 String child를 push 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}해당 코드를 사용할 매인메소드를 구성해보자package week6;public class Main { public static void main(String[] args) { Parent parent = new Child(); parent.print(); // child }} 컴파일 코드public class week6.Main { public week6.Main(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class week6/Child 3: dup 4: invokespecial #3 // Method week6/Child.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: aload_1 9: invokevirtual #4 // Method week6/Parent.print:()V 12: return}위 코드의 주목할 점은 9번으로 child가 호출되었기 때문에 자식 메소드인 Child가 호출 될것 같았는데, 놀랍게도(?) 부모메소드인 Parent가 호출된다는것을 확인 할수 있다.상속의 유형상속은 크게 단일 , 다중 레벨 , 계층 구조 상속이 있다.(자바는 다중상속은 지원하지 않는다.)상속의 단점이렇게 유용한 상속에도 단점이 존재한다. 복잡도가 증가할수록 상속이 중첩될수록 메소드 오버라이드로 인한사이드이펙트를 감당하기 힘들어진다. 쉽게 예를 들어 위의 예시인 Child 클래스를 상속한 Child2가 있고 그 Child2를 상속한 Child3가 있고 그런 방식을 반복하여 Child100 까지 있다고 생각했을 경우, print()메소드를 사용하라고 말 할수 있을까?super 키워드supersuper 키워드는 호출된 객체의 부모 클래스 또는 상위 클래스 중 해당 필드를 호출할 수 있는 가장 가까운 값을 호출한다.package week6;public class Pparent { int test= 10;} 컴파일코드public class week6.Pparent { int test; public week6.Pparent(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: aload_0 5: bipush 10 7: putfield #2 // Field test:I 10: return}package week6;public class Parent extends Pparent{ int test = 1;} 컴파일 코드public class week6.Parent extends week6.Pparent { public week6.Parent(); Code: 0: aload_0 1: invokespecial #1 // Method week6/Pparent.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return}package week6;public class Child extends Parent { public void test(){ System.out.println(test); // 1 System.out.println(this.test); // 1 System.out.println(super.test); // 1 }} 컴파일 코드public class week6.Child extends week6.Parent { public week6.Child(); Code: 0: aload_0 1: invokespecial #1 // Method week6/Parent.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void test(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: getfield #3 // 객체에서 필드를 가져온다 (Field test:I) 7: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 10: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 13: aload_0 14: getfield #3 // 객체에서 필드를 가져온다 (Field test:I) 17: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 20: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 23: aload_0 24: getfield #5 // 객체에서 필드를 가져온다 (Field week6/Parent.test:I) 27: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 30: return}여기서 확인해보면 4,14번은 Child 객체의 필드를 사용하지만, 24번(super.test)의 경우는 부모 객체의 필드를 호출한다.super()전주 학습에서 우리는 객체 생성시 생성자가 필수적으로 생성되여야 하며 자동으로 생성된다는 것을 알수 있었다. 때문에 자식 클래스에서 부모클래스를 이용하기 위해서는 부모클래스를 이용한 객체가 생성 될 수 있어야 한다. 자바에서는 친절하게도 자식 클래스를 생성시 부모클래스를 생성 할 수 있도록 자식 클래스의 생성자 에서 부모클래스의 생성자를호출 할 수 있는 super() 를 자동으로 호출 해 준다. 때문에 기본 생성자를 호출 할 수 없는 아래와 같은 경우에는 컴파일 에러가 발생 한다.public class Parent{ //이 경우, 자식클래스에서 아규먼트를 넣어 호출하면 정상 호출이 가능하다. int test; public Parent(int test) { this.test = test; }}public class Parent{ private Parent() { }} 왜 있어요?자식 클래스를 생성시, 부모의 필드의 값을 변경하고 싶을수 있다. 또는 추가적인 로직이 필요할때 응용하면 되겠다.메소드 오버라이딩하위 클래스 또는 하위 클래스가 해당 부모 클래스 또는 상위 클래스 중 하나에서 이미 제공 한 메서드를 재구현 할수 있도록 하는 기능으로, 다형성을 런타임 시 지원하는 한가지 방법이다. 실행되는 메서드는 호출에 사용되는 객체에 의해 결정된다. 예제로 사용되는 소스는 위의 상속 부분의 소스와 동일하며, 부모 클래스의 메소드를 자식클래스의 메소드로 오버라이딩 하는 부분만 다시한번 확인해 보자package week6;public class Parent{ public void print(){ System.out.println(&quot;parent&quot;); }} 컴파일 코드public class week6.Parent { public week6.Parent(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void print(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // 런타임 상수풀에 String parent를 push 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}package week6;public class Child extends Parent { public void print(){ System.out.println(&quot;child&quot;); }} 컴파일 코드public class week6.Child extends week6.Parent { public week6.Child(); Code: 0: aload_0 1: invokespecial #1 // Method week6/Parent.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void print(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // 런타임 상수풀에 String child를 push 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}해당 코드를 사용할 매인메소드를 구성해보자package week6;public class Main { public static void main(String[] args) { Parent parent = new Child(); parent.print(); // child }} 컴파일 코드public class week6.Main { public week6.Main(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class week6/Child 3: dup 4: invokespecial #3 // Method week6/Child.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: aload_1 9: invokevirtual #4 // Method week6/Parent.print:()V 12: return}디스패치 제 설명보다 상세하고 친절한 설명으로 토비님의 영상 이 있으니, 꼭 보시기 바랍니다.오버로딩컴파일 시점 에 사용하는 기술로, 해당 메소드의 파라미터를 기준으로 어떤 메소드를 실행할지를 결정 하는 기술이다. 아래의 예제를 참고스태틱 메소드 디스패치 (static method dispatch)스태틱 메소드 디스패치 자바가 컴파일 하는 시점에 이미 어떤 클래스에 어떤 메소드를 실행 할지, 클래스에 코드로 만들어 놓는 것이다.package week6;public class StaticDispatch { public static void main(String[] args){ new Service().run(); new Service().run(&quot;test&quot;); }}class Service{ void run(){ System.out.println(&quot;run&quot;); } void run(String msg){ System.out.println(msg); }} 컴파일 코드public class week6.StaticDispatch { public week6.StaticDispatch(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class week6/Service 3: dup 4: invokespecial #3 // Method week6/Service.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: invokevirtual #4 // Method week6/Service.run:()V 10: new #2 // class week6/Service 13: dup 14: invokespecial #3 // Method week6/Service.&quot;&amp;lt;init&amp;gt;&quot;:()V 17: ldc #5 // String test 19: invokevirtual #6 // Method week6/Service.run:(Ljava/lang/String;)V 22: return}7번과 19번 라인을 보면 어디에 있는 무슨 메소드를 호출 할지, 컴파일러는 이미 알고 있다다이나믹 메소드 디스패치 (Dynamic Method Dispatch)다이다믹 메소드 디스패치는 오버라이딩된 메소드를 처리할때 컴파일시 처리가 아닌 런타임 시 처리하는 메커니즘이다. 부모클래스를 통해 오버라이딩 된 메소드가 호출 될 경우(자식 클래스를 부모클래스로 형 변환하여, 오버라이딩된 메소드를 호출 할 경우)자바에서는 호출할 메소드 실행시, 호출 당시의 참조된(가르키는) 객체에 기반하여 해당 메소드를 결정 하게된다. 다시말해, 런타임 시에, 어떤 객체에 어떤 메소드를 실행 할지가 결정된다. 런타임시, 참조된 객체의 타입에 의존하며(레퍼런스 변수의 타입이 아니다. 어렵다면 아래 예제를 참고), 해당 객체는 부모클래스가 참조 할 수있는 자식클래스의 실행될 오버라이딩된 메소드를 결정하게 된다. 이런 방식은 업케스팅이라고도 알려져 있고, 자바에서는 오버라이딩된 메소드를 런타임시 처리한다.package week6;public class DynamicDispatch { static abstract class Service{ abstract void run(); } static class MyService1 extends Service{ void run(){ System.out.println(&quot;MyService1&quot;); } } static class MyService2 extends Service{ void run(){ System.out.println(&quot;MyService2&quot;); } } public static void main(String[] args){ Service svc = new MyService1(); svc.run(); // MyService1 }} 컴파일 코드public class week6.DynamicDispatch { public week6.DynamicDispatch(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class week6/DynamicDispatch$MyService1 3: dup 4: invokespecial #3 // Method week6/DynamicDispatch$MyService1.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: aload_1 9: invokevirtual #4 // Method week6/DynamicDispatch$Service.run:()V 12: return}9번 라인을 보면, Service클래스의 run 메소드를 실행 하지만, 해당 메소드는 구현이 없는 메소드이다. 하지만 “MyService1”가 정확히 호출된다. 그 의미는 런타임시 JVM에서 그 처리를 진행한다는 뜻이다. 토비님의 설명을 추가 하자면, 자바 스팩에는 해당 메소드 호출과정에서 최초로 리시버 파라미터가 호출되고 그 메소드의 객체를 확인하여 어떤 객체의 메소드를 실행하는지 파악 한다고 한다. (위 영상의 30분 정도)(과제하는 시간이 새벽 4시라 자세히는 못찾겠어요)더블 디스패치쉽게 말해서 다이나믹 디스패치를 두번 처리하는 것이다. 처리되는 과정은 토비님 영상을 참고하자 영상에는 왜안되는지 이유까지 상세히 알려주십니다. (개인적으로 static method처리 때문에 오류발생 설명해주시는 부분은 꿀부분입니다.)package week6;import java.util.Arrays;import java.util.List;public class Dispatch { interface Post{ void postOn(SNS sns); } interface SNS { void post(Text post); void post(Picture post); } static class Text implements Post{ public void postOn(SNS sns){ sns.post(this); } } static class Picture implements Post{ public void postOn(SNS sns){ sns.post(this); } } static class facebook implements SNS{ public void post(Text post) { System.out.println(&quot;text - &amp;gt; facebook&quot;); } public void post(Picture post) { System.out.println(&quot;Picture - &amp;gt; facebook&quot;); } } static class twitter implements SNS{ public void post(Text post) { System.out.println(&quot;text - &amp;gt; twitter&quot;); } public void post(Picture post) { System.out.println(&quot;Picture - &amp;gt; twitter&quot;); } } public static void main(String[] args) { List&amp;lt;Post&amp;gt; posts = Arrays.asList(new Text() , new Picture()); List&amp;lt;SNS&amp;gt; snsList = Arrays.asList(new facebook(), new twitter()); posts.forEach(post -&amp;gt; snsList.forEach(sns -&amp;gt; post.postOn(sns))); }} 컴파일 소스public class week6.Dispatch { public week6.Dispatch(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: iconst_2 1: anewarray #2 // class week6/Dispatch$Post 4: dup 5: iconst_0 6: new #3 // class week6/Dispatch$Text 9: dup 10: invokespecial #4 // Method week6/Dispatch$Text.&quot;&amp;lt;init&amp;gt;&quot;:()V 13: aastore 14: dup 15: iconst_1 16: new #5 // class week6/Dispatch$Picture 19: dup 20: invokespecial #6 // Method week6/Dispatch$Picture.&quot;&amp;lt;init&amp;gt;&quot;:()V 23: aastore 24: invokestatic #7 // Method java/util/Arrays.asList:([Ljava/lang/Object;)Ljava/util/List; 27: astore_1 28: iconst_2 29: anewarray #8 // class week6/Dispatch$SNS 32: dup 33: iconst_0 34: new #9 // class week6/Dispatch$facebook 37: dup 38: invokespecial #10 // Method week6/Dispatch$facebook.&quot;&amp;lt;init&amp;gt;&quot;:()V 41: aastore 42: dup 43: iconst_1 44: new #11 // class week6/Dispatch$twitter 47: dup 48: invokespecial #12 // Method week6/Dispatch$twitter.&quot;&amp;lt;init&amp;gt;&quot;:()V 51: aastore 52: invokestatic #7 // Method java/util/Arrays.asList:([Ljava/lang/Object;)Ljava/util/List; 55: astore_2 56: aload_1 57: aload_2 58: invokedynamic #13, 0 // InvokeDynamic #0:accept:(Ljava/util/List;)Ljava/util/function/Consumer; 63: invokeinterface #14, 2 // InterfaceMethod java/util/List.forEach:(Ljava/util/function/Consumer;)V 68: return}두번 디스패치 되는 곳은 다음과 같다 post 객체의 postOn 메소드 실행시, 처리되는 static Sns 객체의 text(),pictrue() 메소드 처리를 하는 다이나믹 디스패치사실 post 클래스에서 파라미터에 따른 동척 디스패칭이 가능하다면, 좀더 깔끔한 처리가 가능하지만, 안타값게도 자바에서는 지원하지 않는다.추상 클래스추상 클래스는 클래스와 인터페이스의 중간정도의 역할을 하는 클래스이다. 가장 큰 장점은 객체 생성를 못하면서 상속의 기능을 사용할 수 있는 점이다. 위에서 확인 했듯 우리는 객체를 생성하지 못하면 상속도 사용 할 수 없다. 하지만 우리는 객체 생성을 막아 직접적으로 객체 조작을 못하게 하면서, 구현은 받아서 쓰고 싶을수 있다. 오라클 공식 문서에서는 다음과 같은 사항일때, 추상 메소드 사용을 고려해보라고 하고있다. 여러 클래스 간의 구현된 메소드를 공유 하고 싶다. 확장 하려는 클래스에 공통적으로 사용하는 필드가 있거나 public 이외의 접근제어자를 설정 하고 싶다. static 또는 final 이외의 필드를 사용하고 싶다.package week6;public abstract class AbstractClass { protected int a; public void test(){ System.out.println(&quot;abstract&quot;); }} 컴파일 코드public abstract class week6.AbstractClass { protected int a; public week6.AbstractClass(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public void test(); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String abstract 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return}package week6;public class AbstractImpl extends AbstractClass{} 컴파일 코드public class week6.AbstractImpl extends week6.AbstractClass { public week6.AbstractImpl(); Code: 0: aload_0 1: invokespecial #1 // Method week6/AbstractClass.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return}매인클래스를 확인해보자package week6;public class Main { public static void main(String[] args) { // AbstractClass abs = new AbstractClass(); 컴파일 에러 AbstractImpl abs = new AbstractImpl(); abs.test(); //abstract }} 컴파일 코드public class week6.Main { public week6.Main(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class week6/AbstractImpl 3: dup 4: invokespecial #3 // Method week6/AbstractImpl.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: aload_1 9: invokevirtual #4 // Method week6/AbstractImpl.test:()V 12: return}상속과 유사하게, 부모 클래스의 구현 부를 사용할 수 있다. 그러면서도 new 키워드를 통한 생성을 불가능 하다.final 키워드final 은 변수, 메서드 또는 클래스에만 적용 할 수 있는 비접근 수정자 이다. 용법은 아래와 같다.final 변수변수가 값일 경우, 기본적으로 변경이 불가능한 상수지만, 변수가 참조 값일 경우(예:map , array 등) 해당 객체의 내부 상태(추가,삭제)가 가능하다package week6;import java.util.HashMap;import java.util.Map;public class Finalval { final int num =1; final Map&amp;lt;String , String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); public void setData(){ //num = 2; // 컴파일 에러 //map = new HashMap&amp;lt;&amp;gt;(); //컴파일 에러 map.put(&quot;test&quot;,&quot;test&quot;); }}final 메소드오버라이딩을 막아 재정의 방지package week6;public class FinalMethod { final void method(){ }}public class FinalMethodChild extends FinalMethod{ /* void method(){ }*/ //컴파일 에러}final 클래스상속을 방지하여 확장을 금지(Integer , Float 등)String 클래스와 같이 불변 클래스 를 생성package week6;public final class FinalClass {}public class FinalClassChild extends FinalClass { //컴파일 에러}컴파일 후 소스에서는 final키워드에 의한 변화를 확인 할 수 없다. 다른 방식으로 확인 방식을 아시는 분은 답글좀 부탁드립니다…Object 클래스Object 클래스는 기본적으로 자바의 모든 클래스의 부모 클래스로, 즉, Java의 최상위 클래스이다. Object 클래스는 유형을 모르는 객체를 참조하려는 경우 이용하면 좋지만, 가능하다면 제네릭을 사용하도록 하면 좋다. 아래는 Object에서 기본적으로 제공하는 메소드이다. 메소드명 설명 protected Object clone() 해당 객체의 복제본을 생성하여 반환함. boolean equals(Object obj) 해당 객체와 전달받은 객체가 같은지 여부를 반환함. protected void finalize() 해당 객체를 더는 아무도 참조하지 않아 가비지 컬렉터가 객체의 리소스를 정리하기 위해 호출함. Class getClass() 해당 객체의 클래스 타입을 반환함. int hashCode() 해당 객체의 해시 코드값을 반환함. void notify() 해당 객체의 대기(wait)하고 있는 하나의 스레드를 다시 실행할 때 호출함. void notifyAll() 해당 객체의 대기(wait)하고 있는 모든 스레드를 다시 실행할 때 호출함. String toString() 해당 객체의 정보를 문자열로 반환함. void wait() 해당 객체의 다른 스레드가 notify()나 notifyAll() 메소드를 실행할 때까지 현재 스레드를 일시적으로 대기(wait)시킬 때 호출함. void wait(long timeout) 해당 객체의 다른 스레드가 notify()나 notifyAll() 메소드를 실행하거나 전달받은 시간이 지날 때까지 현재 스레드를 일시적으로 대기(wait)시킬 때 호출함. void wait(long timeout, int nanos) 해당 객체의 다른 스레드가 notify()나 notifyAll() 메소드를 실행하거나 전달받은 시간이 지나거나 다른 스레드가 현재 스레드를 인터럽트(interrupt) 할 때까지 현재 스레드를 일시적으로 대기(wait)시킬 때 호출함. 오라클 도큐먼트 javatpoint 토비의 봄 1회" }, { "title": "자바스터디 5주차", "url": "/posts/whiteship-study-5week/", "categories": "study", "tags": "", "date": "2020-12-15 00:00:00 +0900", "snippet": "GOAL 자바의 Class에 대해 학습하세요.학습할 것 (필수)클래스 정의하는 방법 클래스란클래스(class)는 객체 지향 프로그래밍(OOP)에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀이다. 객체를 정의 하기 위한 상태(멤버변수)와 메서드(함수)로 구성된다 - 위키백과고전적인 붕어빵과 붕어빵틀에서 틀의 역할을 담당한다. 틀만 있으면 같은 모양을 만들수 있는것 처럼 하나의 클래스가 있으면, 같은 기능의 객체(인스턴스)를 생성 할 수 있다.생성자클래스는 생성자 메서드가 기본적으로 호출된다. 때문에 생성자를 실행시키지 않고 객체를 만들 수 없다.또한, 생성자는 리턴 타입이 없다.아래 세가지 코드는 같은 형식으로 컴파일된다public class Test {}public class Test { public Test() { }}public class Test { {}} 컴파일 코드public class Test { public Test(); Code: 0: aload_0 // 로컬변수배열(array)의 0번째 레퍼런스 값을 호출 1: invokespecial #8 // 인스턴스 생성을 위한 메소드 호출 Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return}invokespecial은 특정 상황에서, 예외를 발생 하는데 그 예외는 아래와 같다.(오역의 가능성이 있어 해석은 차후에 진행) Linking Exceptions During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution (§5.4.3.3) can be thrown. if the resolved method is an instance initialization method, and the class in which it is declared is not the class symbolically referenced by the instruction, a NoSuchMethodError is thrown. if the resolved method is a class (static) method, the invokespecial instruction throws an IncompatibleClassChangeError. Run-time Exception if objectref is null, the invokespecial instruction throws a NullPointerException. if no method matching the resolved name and descriptor is selected, invokespecial throws an AbstractMethodError. if the selected method is abstract, invokespecial throws an AbstractMethodError. if the selected method is native and the code that implements the method cannot be bound, invokespecial throws an UnsatisfiedLinkError. innner class를 사용할 경우, 컴파일시 해당 클래스가 추가로 생성된다아래와 같은 코드는 Test.class, Test2.class를 생성해낸다.public class Test {}class test2{}싱글톤이나 빌더패턴에서 사용하는 생성자를 private으로 만들면 어떻게 될까?코드가 생성되지 않는다. 메모리에 올라가지 않기 때문에 쓸수 없는 것 같다.public class Test { private Test(){ int a= 0; }} 컴파일 코드public class Test {}변수(필드)변수는 중괄호 {} 블록을 기준으로 전역변수와 지역변수로 나눌 수 있다전역변수를 많이쓰면 팀원을 괴롭 힐 수 있다public class Test { int global = 0; // 전역 변수 Test(){ // 블록 int local = 1; // 지역변수 } // 블록}메소드실제 동작을 구현하며, 중괄호 {} 블록을 사용한다.public class Test { int method(int arg){ return arg; }} 컴파일 코드public class Test { public Test(); Code: 0: aload_0 // 로컬변수배열(array)의 0번째 레퍼런스 값을 호출 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return int method(int); Code: 0: iload_1 // 로컬변수배열(array)의 1번째 int 값을 호출 1: ireturn // int를 반환}객체 만드는 방법 (new 키워드 이해하기)객체생성(인스턴스 생성)은 new 키워드를 통해 생성한다.우리가 마주치는 Exception 들은 new 키워드에서 발생한다.public class Test { void newKeyword(){ new Test(); }} 컴파일 코드public class Test { public Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return void newKeyword(); Code: 0: new #2 // 객체를 생성한다 3: dup 4: invokespecial #3 // Method &quot;&amp;lt;init&amp;gt;&quot;:()V 7: pop 8: return}new는 특정 상황에서, 예외를 발생 하는데 그 예외는 아래와 같다 Linking Exceptions 레퍼런스(class, array, interface type)를 해석하는 과정에서 오류를 발생 레퍼런스(class, array, interface type)가 interface 혹은 추상 클래스인 경우 InstantiationError 발생 Run-time Exception 클래스 초기화에 실패 했을 경우 메소드 정의하는 방법메소드는 접근제어자, 리턴타입, 메소드명, 매개변수로 구성되며, 예외 발생시 호출한 메소드로 책임을 전가하는 throws를 이용 할 수 있다.왠만하면 자기의 일은 스스로 하도록 만들자 이름 설명 private 해당 클래스 내부에서만 호출 가능 default 같은 패키지내의 클래스에서만 호출 가능 protected 같은 패키지내의 클래스나 상속받은 클래스에서만 호출 가능 public 어디서나 사용가능 오버로딩같은 이름의 메소드를 매개변수의 수를 변경하여 정의 할 수 있는 기능public class Test { void newKeyword(){ } void newKeyword(int i){ }} 컴파일 코드public class Test { public Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return void newKeyword(); Code: 0: return void newKeyword(int); Code: 0: return}같은이름의 파라미터만 다른 메소드가 생성 되었다오버라이딩부모 클래스에서 만든 메소드를 자식 메소드에서 재정의하는 기능public class Main { public static void main(String[] args) { Child child = new Child(); child.myname(); //dola child.papa(); //papa child.mama(); //mother }}class Child extends Parent{ String myname(){ return &quot;dola&quot;; } String mama(){ return &quot;mother&quot;; }}class Parent{ String papa(){ return &quot;papa&quot;; } String mama(){ return &quot;mama&quot;; }} 컴파일 코드public class Main { public Main(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class Child 3: dup 4: invokespecial #3 // Method Child.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: aload_1 9: invokevirtual #4 // 해당 인스턴트의 메소드를 호출 Method Child.myname:()Ljava/lang/String; 12: pop 13: aload_1 14: invokevirtual #5 // 해당 인스턴트의 메소드를 호출 Method Child.papa:()Ljava/lang/String; 17: pop 18: aload_1 19: invokevirtual #6 // 해당 인스턴트의 메소드를 호출 Method Child.mama:()Ljava/lang/String; 22: pop 23: return}부모의 메소드를 호출하고, 바꿀수 있는 마법같은 기능은 invokevirtual 가능하게 해준다 먼저 오버라이드 된 메소드를 찾아 존재 할 경우, 해당 메소드를 실행한다 1항에 해당하지 않으면, 부모클래스에서 같은 작업을 재귀적으로 반복한다.생성자 정의하는 방법위에 클래스에 설명한 내용을 참고하자.this 키워드 이해하기영문법에서 this 약간 감정적으로 가까운 것을 의미하는것 같다. 그 때문인지 각 언어마다 this에 대한 해석이 다르다.java 에서는 this를 객제자이라고 생각한다.public class Test{ String me; public Test(String me) { this.me = me; } public Test(){ this(&quot;me&quot;); }} 컴파일 코드public class Test { java.lang.String me; public Test(java.lang.String); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: aload_0 5: aload_1 6: putfield #2 //객체에 me하는 이름으로 필드 셋팅// Field me:Ljava/lang/String; 9: return public Test(); Code: 0: aload_0 1: ldc #3 // 현재 클래스 상수풀에 값을 푸시 // String me 3: invokespecial #4 // Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V 6: return}생성자에서는 this를 통해 자신의 생성자를 호출 할 수 있다.과제 (Optional)int 값을 가지고 있는 이진 트리를 나타내는 Node 라는 클래스를 정의하세요.int value, Node left, right를 가지고 있어야 합니다.BinrayTree라는 클래스를 정의하고 주어진 노드를 기준으로 출력하는 bfs(Node node)와 dfs(Node node) 메소드를 구현하세요.DFS는 왼쪽, 루트, 오른쪽 순으로 순회하세요." }, { "title": "전자정부 타일즈 적용", "url": "/posts/%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%ED%83%80%EC%9D%BC%EC%A6%88%EC%A0%81%EC%9A%A9/", "categories": "", "tags": "", "date": "2020-12-07 00:00:00 +0900", "snippet": "타일즈 관련 정리가 잘되있는곳타일즈" }, { "title": "JUNIT in egov", "url": "/posts/%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%EC%84%A4%EC%A0%95%EB%A1%9C%EB%93%9C%EB%B6%88%EA%B0%80%EC%98%A4%EB%A5%98/", "categories": "", "tags": "", "date": "2020-12-07 00:00:00 +0900", "snippet": " 전자정부 설정 로드 불가 오류 컴파일 위치 확인(이클립스 기준) properties &amp;gt; Deployment Assembly &amp;gt; /src/main/resources 설정 여부 " }, { "title": "자바스터디 4주차", "url": "/posts/whiteship-study-4week/", "categories": "study", "tags": "", "date": "2020-12-02 00:00:00 +0900", "snippet": "GOAL 자바가 제공하는 제어문을 학습하세요.학습할 것 선택문 반복문조건문 if를 사용하는 결정문if문 안 조건에 해당하는 경우, 그 블록안의 코드를 실행class Main { public static void main(String[] args) { int x=0 , y; if(x==0) y = 0; else if(x==1) y = 1; else if(x==2) y = 2; else if(x==5) y = 5; else if(x==6) y = 6; }}Code: 0: iconst_0 //int 0 피연산자 스택에 push 1: istore_1 //로컬변수1번(x) 에 피연산자 스택에서 pop된 값(0)을 저장 2: iload_1 //로컬변수1번에서 값 호출(0) 3: ifne 11 //값이 0이 아닌경우 , 11번지로 점프 6: iconst_0 //int 0 피연산자 스택에 push 7: istore_2 //로컬변수2번(y) 에 피연산자 스택에서 pop된 값(0)을 저장 8: goto 50 //50번지로 이동(return) 11: iload_1 //로컬변수1번에서 값 호출(0) 12: iconst_1 //int 1 피연산자 스택에 push 13: if_icmpne 21 //로컬변수1번에서 값(0)과 피연산자 스택에서 pop된 값(1)을 비교하여 서로 다른경우, 21번으로 점프 16: iconst_1 //int 1 피연산자 스택에 push 17: istore_2 //로컬변수2번(y) 에 피연산자 스택에서 pop된 값(1)을 저장 18: goto 50 //50번지로 이동(return) 21: iload_1 //로컬변수1번에서 값 호출(0) 22: iconst_2 //int 2 피연산자 스택에 push 23: if_icmpne 31 //로컬변수1번에서 값(0)과 피연산자 스택에서 pop된 값(2)을 비교하여 서로 다른경우, 31번으로 점프 26: iconst_2 //int 2 피연산자 스택에 push 27: istore_2 //로컬변수2번(y) 에 피연산자 스택에서 pop된 값(2)을 저장 28: goto 50 //50번지로 이동(return) 31: iload_1 //로컬변수1번에서 값 호출(0) 32: iconst_5 //int 5 피연산자 스택에 push 33: if_icmpne 41 //로컬변수1번에서 값(0)과 피연산자 스택에서 pop된 값(5)을 비교하여 서로 다른경우, 41번으로 점프 36: iconst_5 //int 5 피연산자 스택에 push 37: istore_2 //로컬변수2번(y) 에 피연산자 스택에서 pop된 값(5)을 저장 38: goto 50 //50번지로 이동(return) 41: iload_1 //로컬변수1번에서 값 호출(0) 42: bipush 6 //int 6 피연산자 스택에 push 44: if_icmpne 50 //로컬변수1번에서 값(0)과 피연산자 스택에서 pop된 값(6)을 비교하여 서로 다른경우, 50번으로 점프 47: bipush 6 //int 6 피연산자 스택에 push 49: istore_2 //로컬변수2번(y) 에 최상위 스택에 쌓인 값(6)을 저장 50: return //void 메서드를 리턴선택문 swich를 사용하는 결정문, if문을 이용할 때 보다 속도가 빠르다. 관련문서 switch 문 표현식은 byte, short, int, long, enum 유형, String 및 Byte, Short, Int 및 Long과 같은 일부 래퍼 유형일 수 있습니다.(단, switch 표현식에서만 wrapper 허용하고, case 에는 wrapper 를 허용하지 않는다.) switch () 대괄호 사이에 변수 또는 표현식을 넣을 수 있습니다 . (float 은 두 개의 부동 소수점 숫자를 비교하는 것은 x와 y의 십진수 등가가 합리적인 정밀도로 동일하게 보일 때 정확하지 않을 수 있어 허용하지 않습니다.) 케이스 값은 리터럴 또는 상수 여야합니다. 케이스 값 유형은 표현식 유형이어야합니다. 각 케이스는 고유해야합니다. 중복 케이스 값을 생성하면 컴파일 타임 오류가 발생합니다. 각 케이스에는 선택적인 break 문 이 있습니다. 스위치 내부에서 명령문 시퀀스를 종료하고 스위치 표현식 다음에 컨트롤을 점프하는 데 사용됩니다. 어떤 경우에도 break 문을 사용하지 않으면 break 문에 도달 할 때까지 다음 case로 실행이 계속됩니다 . 스위치 문 케이스에 해당하는 경우가 없으면 이 default 가 실행됩니다. 기본 케이스에는 break 문이 필요하지 않습니다 .class Main { public static void main(String[] args) { int x=0 , y; switch(x) { case 0 : y = 0; break; case 1 : y = 1; break; case 4 : y = 4; break; case 5 : y = 5; break; case 6 : y = 6; break; } }} Code: 0: iconst_0 //int 0 피연산자 스택에 push 1: istore_1 //로컬변수1번(x)에 피연산자 스택에서 pop된 값(0)을 저장 2: iload_1 3: tableswitch { // 0 to 6 //스위치 처리를 위한 테이블 생성(변수길이까지 생성, 예제에서는 총 7개(0~6) 생성) 0: 44 1: 49 2: 67 3: 67 4: 54 5: 59 6: 64 default: 67 } 44: iconst_0 //int 0 피연산자 스택에 push 45: istore_2 //로컬변수2번(y)에 피연산자 스택에서 pop된 값(0)을 저장 46: goto 67 //67번지로 점프 49: iconst_1 //int 1 피연산자 스택에 push 50: istore_2 //로컬변수2번(y)에 피연산자 스택에서 pop된 값(2)을 저장 51: goto 67 //67번지로 점프 54: iconst_4 //int 4 피연산자 스택에 push 55: istore_2 //로컬변수2번(y)에 피연산자 스택에서 pop된 값(4)을 저장 56: goto 67 //67번지로 점프 59: iconst_5 //int 5 피연산자 스택에 push 60: istore_2 //로컬변수1번(y)에 피연산자 스택에서 pop된 값(5)을 저장 61: goto 67 //67번지로 점프 64: bipush 6 //int 6 피연산자 스택에 push 66: istore_2 //로컬변수1번(y)에 피연산자 스택에서 pop된 값(6)을 저장 67: return //void 메서드를 리턴반복문 반복하는 작업을 처리 할 경우, 조건을 주어 해당 작업이 완료 될때 까지 작업을 처리 break 해당 코드 하위 작업을 더 이상 진행 하지 않으며, 해당 블록의 작업을 종료한다. continue 해당 코드 하위 작업을 더 이상 진행 하지 않으며, 해당 루프의 다음 작업을 진행한다. label 위 코드와 혼합하여 사용, 조건에 일치하면 라벨이 붙어 있는 대상으로 점프한다.참고링크 forpublic static void main(String[] args) { for(int i= 0; i &amp;lt; 5 ; i+=2) { System.out.println(i); } }} 2번에서 15번으로 이동하여 비교 처리 후, 5번으로 돌아와 i값을 출력후, 증감 시킨다. Code: 0: iconst_0 //int 0 피연산자 스택에 push 1: istore_1 //로컬변수1번(i)에 피연산자 스택에서 pop된 값(0)을 저장 2: goto 15 //15번지로 점프 5: getstatic #16 //static 메소드 호출(Field java/lang/System.out:Ljava/io/PrintStream) 8: iload_1 //로컬변수1번에서 값 호출(0) 9: invokevirtual #22 //메소드 실행(Method java/io/PrintStream.println:(I)V)(i 출력) 12: iinc 1, 2 //로컬변수1번(i)를 2만큼 증가 15: iload_1 //로컬변수1번에서 값 호출(0) 16: iconst_5 //int 5 피연산자 스택에 push 17: if_icmplt 5 //로컬변수1번에서 값과 피연산자 스택에서 pop된 값을 비교하여 로컬변수가 작은 경우, 5번으로 점프 20: returnwhile 놀랍게도 어셈블러는 for문과 동일하게 처리한다.public static void main(String[] args) { int i = 0; while (i&amp;lt;5) { System.out.println(i); i+=2; } } Code: 0: iconst_0 //int 0 피연산자 스택에 push 1: istore_1 //로컬변수1번(i)에 피연산자 스택에서 pop된 값(0)을 저장 2: goto 15 //15번지로 점프 5: getstatic #16 //static 메소드 호출(Field java/lang/System.out:Ljava/io/PrintStream) 8: iload_1 //로컬변수1번에서 값 호출(0) 9: invokevirtual #22 //메소드 실행(Method java/io/PrintStream.println:(I)V)(i 출력) 12: iinc 1, 2 //로컬변수1번(i)를 2만큼 증가 15: iload_1 //로컬변수1번에서 값 호출(0) 16: iconst_5 //int 5 피연산자 스택에 push 17: if_icmplt 5 //로컬변수1번에서 값과 피연산자 스택에서 pop된 값을 비교하여 로컬변수가 작은 경우, 5번으로 점프 20: returndo-whilepublic static void main(String[] args) { int i = 0; do{ System.out.println(i); i+=2; }while(i&amp;lt;5); } 비교연산처리부터 하지 않고, 차래대로 실행 된다. 때문에 do구문에 있는 명령은 한번문 무조건 실행 되게 된다. Code: 0: iconst_0 //int 0 피연산자 스택에 push 1: istore_1 //로컬변수1번(i)에 피연산자 스택에서 pop된 값(0)을 저장 2: getstatic #16 //static 메소드 호출(Field java/lang/System.out:Ljava/io/PrintStream) 5: iload_1 //로컬변수1번에서 값 호출(0) 6: invokevirtual #22 //메소드 실행(Method java/io/PrintStream.println:(I)V)(i 출력) 9: iinc 1, 2 //로컬변수1번(i)를 2만큼 증가 12: iload_1 //로컬변수1번에서 값 호출(2) 13: iconst_5 //int 5 피연산자 스택에 push 14: if_icmplt 2 //로컬변수1번에서 값과 피연산자 스택에서 pop된 값을 비교하여 로컬변수가 작은 경우, 2번으로 점프 17: returnfor-each 향상된 for문 (어셈블리어 부분은 추가 수정필요)public static void main(String[] args) { int[] array = {1,2}; for (int i : array) { System.out.println(i); } } Code: 0: iconst_2 //int 2 피연산자 스택에 push 1: newarray int //int타입으로 피연산자 스택에서 pop된 값의 크기만큼의 배열 생성 3: dup //피연산자 스택의 최상위 값을 복사 4: iconst_0 //int 0 피연산자 스택에 push 5: iconst_1 //int 1 피연산자 스택에 push 6: iastore //int타입 배열에 피연산자 스택에서 pop된 값저장 //{1}이됨 7: dup //피연산자 스택의 최상위 값을 복사 8: iconst_1 //int 1 피연산자 스택에 push 9: iconst_2 //int 2 피연산자 스택에 push 10: iastore //int타입 배열에 피연산자 스택에서 pop된 값저장 //{2}이됨 11: astore_1 //배열생성끝 12: aload_1 //로컬변수1번(array)에서 배열 호출 13: dup 14: astore 5 16: arraylength 17: istore 4 19: iconst_0 //int 0 피연산자 스택에 push 20: istore_3 21: goto 39 24: aload 5 26: iload_3 27: iaload 28: istore_2 29: getstatic #16 // Field java/lang/System.out:Ljava/io/PrintStream; 32: iload_2 33: invokevirtual #22 // Method java/io/PrintStream.println:(I)V 36: iinc 3, 1 39: iload_3 //로컬변수3번에서 값 호출하여 피연산자 스택에 push 40: iload 4 //로컬변수4번에서 값 호출하여 피연산자 스택에 push 42: if_icmplt 24 //로컬변수1번에서 값과 피연산자 스택에서 pop된 값을 비교하여 로컬변수가 작은 경우, 24번으로 점프 45: return과제(옵션) 과제 0. JUnit 5 학습하세요.인텔리J, 이클립스, VS Code에서 JUnit 5로 테스트 코드 작성하는 방법에 익숙해 질 것.이미 JUnit 알고 계신분들은 다른 것 아무거나!더 자바, 테스트 강의도 있으니 참고하세요~ 과제 1. live-study 대시 보드를 만드는 코드를 작성하세요.깃헙 이슈 1번부터 18번까지 댓글을 순회하며 댓글을 남긴 사용자를 체크 할 것.참여율을 계산하세요. 총 18회에 중에 몇 %를 참여했는지 소숫점 두자리가지 보여줄 것.Github 자바 라이브러리를 사용하면 편리합니다.깃헙 API를 익명으로 호출하는데 제한이 있기 때문에 본인의 깃헙 프로젝트에 이슈를 만들고 테스트를 하시면 더 자주 테스트할 수 있습니다. 과제 2. LinkedList를 구현하세요.LinkedList에 대해 공부하세요.정수를 저장하는 ListNode 클래스를 구현하세요.ListNode add(ListNode head, ListNode nodeToAdd, int position)를 구현하세요.ListNode remove(ListNode head, int positionToRemove)를 구현하세요.boolean contains(ListNode head, ListNode nodeTocheck)를 구현하세요. 과제 3. Stack을 구현하세요.int 배열을 사용해서 정수를 저장하는 Stack을 구현하세요.void push(int data)를 구현하세요.int pop()을 구현하세요. 과제 4. 앞서 만든 ListNode를 사용해서 Stack을 구현하세요.ListNode head를 가지고 있는 ListNodeStack 클래스를 구현하세요.void push(int data)를 구현하세요.int pop()을 구현하세요. 과제 5. Queue를 구현하세요.(optional) 배열을 사용해서 한번ListNode를 사용해서 한번.마감일시2020년 12월 12일 토요일 오후 1시까지.참고" }, { "title": "자바스터디 3주차", "url": "/posts/whiteship-study-3week/", "categories": "study", "tags": "", "date": "2020-11-23 00:00:00 +0900", "snippet": "GOAL 자바가 제공하는 다양한 연산자를 학습하세요. 학습할 것 산술 연산자 비트 연산자 관계 연산자 논리 연산자 instanceof assignment(=) operator 화살표(-&amp;gt;) 연산자 3항 연산자 연산자 우선 순위 (optional) Java 13. switch 연산자산술 연산자 산술 연산자 설명 + 연산자를 기준으로 우항과 좌항의 합연산을 수행합니다 - 연산자를 기준으로 우항과 좌항의 차연산을 수행합니다 * 연산자를 기준으로 우항과 좌항의 곱연산을 수행합니다 / 연산자를 기준으로 좌항을 우항으로 나누기 연산을 수행합니다. 우항이 0일 경우, 예외를 발생 합니다. % 연산자를 기준으로 좌항을 우항으로 나눈 나머지 연산을 수행합니다. 우항이 0일 경우, 예외를 발생 합니다. 나눗셈 연산단순하게 나머지 연산만 수행 했을 경우, 소수점표기가 되지 않으며, 소수점 연산이 필요한경우, 좌,우항중 하나를 실수로 표기한후, double로 받아 표기. java.math의 BigDecimal 이용 (추천)관련 링크 숫자 승격자바의 레퍼선스 객체의 오토박싱과 유사한 처리 상세내용은 링크를 확인해 보자숫자승격비트연산자 비트 연산자 설명 &amp;amp; 연산자를 기준으로 우항과 좌항의 대응되는 비트가 모두 1이면 1을 반환. (AND 연산) | 연산자를 기준으로 우항과 좌항의 대응되는 비트 중에서 하나라도 1이면 1을 반환. (OR 연산) ^ 연산자를 기준으로 우항과 좌항의 대응되는 비트가 서로 다르면 1을 반환. (XOR 연산) ~ 피연산자의 비트를 1이면 0, 0이면 1로 반전. (NOT 연산, 1의 보수) « 연산자를 기준으로 우항의 수만큼 좌항의 비트를 모두 왼쪽으로 이동. (Left shift 연산) » 연산자를 기준으로 우항의 수만큼 좌항의 비트를 모두 오른쪽으로 이동. (Right shift 연산) 사용이유비트연산의 경우 , 연산 속도가 빠름관계 연산자 (Relational operator, (비교 연산자, Comparison operator))반환 값은 항상, boolean 타입이다동일성을 보장하며, 동등성을 보장하지 않는다.(String,배열, 레퍼런스 객체등) 동일성 vs 동등성동일성 : 메모리 주소값의 정보가 같음동등성 : 객체의 정보가 같음 관계 연산자 설명 == 연산자를 기준으로 우항과 좌항이 같으면 true != 연산자를 기준으로 우항과 좌항이 다르면 true &amp;gt; 연산자를 기준으로 좌항이 우항보다 크면 true &amp;gt;= 연산자를 기준으로 좌항이 우항보다 더 크거나 같으면 true &amp;lt; 연산자를 기준으로 우항이 좌항보다 크면 true. &amp;lt;= 연산자를 기준으로 우항이 좌항보다 왼쪽보다 더 크거나 같으면 true. 논리 연산자 (Logical operator) 논리 연산자 설명 &amp;amp;&amp;amp; 모두 참이면 true (AND 연산) || 하나라도 참이면 true (OR 연산) ! 논리 반전 (true &amp;gt; false , false &amp;gt; true) (NOT 연산) instanceof 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 반환. 실재 JVM에서는 null이 아닌 class , array, interface 의 경우 아래와 같이 처리 후, 참인경우 1 , 거짓인 경우 0을 operand 스택에 쌓는다(원문 push라고 써있음). 아래는 1을 반환하는 경우 좌항이 array가 아닌 클래스인 경우 우항이 클래스라면, instanceof 연산자를 기준으로 좌항은 같은 클래스 이거나, 서브클래스인 경우 우항이 인터페이스라면, instanceof 연산자를 기준으로 좌항이 인터페이스를 구현(implement) 한 경우 좌항이 interface인 경우 instanceof 연산자를 기준으로 우항은 반드시 Object 클래스인 경우 instanceof 연산자를 기준으로 우항과 같은 인터페이스 혹은 우항의 서브인터페이스 경우 좌항이 array인 경우 우항이 클래스라면, instanceof 연산자를 기준으로 우항은 반드시 Object 클래스인 경우 우항이 인터페이스라면, instanceof 연산자를 기준으로 우항은 array를 구현하는 구현체 중 하나인 경우 우항이 array라면, 아래의 경우에 만족할 경우 좌항과 우항이 같은 원시타입일 경우 좌항과 우항이 같은 레퍼런트 타입인 경우 assignment(=) operator 연산자 기준으로, 좌항에 우항을 할당 (이때, 값을 복사하는것이 아닌, 메모리값을할당하는것)화살표(-&amp;gt;) 연산자자바 8버전 부터 지원하는 익명함수 생성 방법, 단일 함수 인터페이스를 구현하는데 사용 가능 (@FunctionalInterface를 통해 단일함수 인터페이스를 강제 가능)3항 연산자표현식 : [condition] ? [true_value] : [false_value] 간략한 문장으로 줄일때 사용하면 유용한 방법, 지나치게 사용할 경우 코드 복잡도는 높힐수 있음연산자 우선 순위싫어하는 동료가 있다면, 괄호를 안쓰면 스트레스를 줄수 있다. 우선 순위 연산자 설명 1 expr++ expr– 후위 증가/감소 연산자 2 ++expr –expr +expr -expr ~ ! 전위 증가/감소 연산자, 양/음 부호, 논리/비트 NOT 연산자 3 * / % 곱셈/나눗셈/나머지 연산자 4 + - 덧셈/뺄셈 연산자 5 «  »  »&amp;gt; 비트 왼쪽/오른쪽 Shift 연산자, Unsigned Shift 연산자 6 &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= instanceof 보다 작은/보다 큰/보다 작거나 같은/보다 크거나 같은 관계 연산자, instanceof 7 == != 와 같은/와 다른 관계 연산자 8 &amp;amp; 비트 AND 연산자 9 ^ 비트 XOR 연산자 10 | 비트 OR 연산자 11 &amp;amp;&amp;amp; 논리 AND 연산자 12 || 논리 OR 연산자 13 ? : 삼항 조건 연산자 14 = += -= *= /= %= &amp;amp;= ^= |= «=  »=  »&amp;gt;= 대입 연산자 및 복합 대입 연산자 참고자료3주차 과체 : nimkoes3주차 과체 : gtpe오라클 레퍼런스" }, { "title": "자바스터디 2주차", "url": "/posts/whiteship-study-2week/", "categories": "study", "tags": "", "date": "2020-11-23 00:00:00 +0900", "snippet": "아래 내용은 https://github.com/kksb0831/Practice_project/blob/master/Java_Study_02.md 내용을 차용했음을 알려드립니다.학습할것 프리미티브 타입 종류와 값의 범위 그리고 기본 값 프리미티브 타입과 레퍼런스 타입 리터럴 변수 선언 및 초기화하는 방법 변수의 스코프와 라이프타임 타입 변환, 캐스팅 그리고 타입 프로모션 1차 및 2차 배열 선언하기 타입 추론, var프리미티브(기본형) 타입 종류와 값의 범위 그리고 기본 값총 8가지의 기본형 타입이 미리 정의되어 있습니다. 기본형에는 기본값이 존재하기 때문에 Null값이 존재하지 않고 실제 값은 스택 메모리에 저장되며 만약 담을 수 있는 크기보다 큰 값을 넣으려고 하면 컴파일 에러가 발생합니다.표현범위를 계산하는 방법은 메모리 크기에 연관되어 있습니다.부호를 표현한다면 첫번째 비트는 부호를 나타나게 되어 나머지 n-1의 비트를 이용하여 수를 표현하게 됩니다. 또한 양수에 0을 포함하여 계산하기 때문에 부호있는 정수형의 표현 범위는 -2 n ~ 2 n -1 가 됩니다.   타입 메모리크기 기본값 표현 벙위 정수형 byte 1 byte 0 -2 7 ~ 2 7 -1 정수형 short 1 byte 0 -2 15 ~ 2 15 -1 정수형 int (기본) 4 byte 0 -2 31 ~ 2 31 -1 정수형 long 8 byte 0L -2 63 ~ 2 63 -1 실수형에서는 값을 부호, 지수, 가수로 나누어 저장됩니다. 따라서 같은 크기임에도 훨씬 큰범위를 표현 가능하지만 실수형은 원래 저장하려던 값과 실제 저장된 값이 오차가 날 수 있습니다. 그래서 오차없는 자리 수인 정밀도가 굉장히 중요한데 정밀도를 계산하는 방법은 가수 부분의 데이터크기에 관련되어 있습니다.위의 이미지에서 처럼 실수형 float의 가수부분은 23비트인데 여기서 정규화를 통해 24까지 표현이 가능합니다. 2 24은 10 7 보다는 크고 10 8 보다는 작기에 float의 정밀도는 7이 됩니다. double의 경우에는 가수부분이 52비트이고 위와 같은 계산을 통하여 정밀도를 계산하면 정밀도는 15자리가 됩니다.따라서 변수를 선언할때 실수의 정밀도를 반드시 고려하여 선정해야할 필요가 있습니다.   타입 메모리크기 기본값 표현 벙위 정밀도 실수형 float 4 byte 0.0F -3.4E38 ~ -1.4E-45, 1.4E-45 ~ 3.4E38 7자리 실수형 double (기본) 8 byte 0.0 (1.7 * 10 -308 ) ~ (1.7 * 10 308 )의 근사값 15자리 나머지 타입으로는 논리형 boolean과 문자형 char가 있습니다.논리형 boolean은 참,거짓을 판단하기 때문에 1bit이면 충분하지만 Java가 데이터를 다루는 최소 범위가 1 byte이기 때문에 1 byte를 할당합니다.문자형 char는 유니코드를 사용하기 때문에 유니코드의 요구 범위인 2 byte가 필요로 하여 2byte를 할당합니다.   타입 메모리크기 기본값 표현 벙위 논리형 boolean 1 byte false true, false 문자형 char 2 byte ‘\\u0000’ 0 ~ 65,535 프리미티브(기본형) 타입과 레퍼런스(참조형) 타입앞서 살펴본 기본형 타입은 이미 Java에서 정의되어있는 데이터 타입으로 변수를 선언 할때 메모리에 고정된 크기로 저장되고 변수에 데이터의 값을 저장하게 됩니다. 하지만 참조형 타입은 변수를 선언할때 크기가 정해져있지 않고 값이 변수가 할당될때 저장할 메모리에 대한 주소가 저장되어 있습니다.위의 그림같은 형태로 구성되어 저장된 변수의 주소값을 참조하여 활용하게 됩니다. 또한 기본형 데이터타입과 참조형 데이터타입은 JVM Runtime Data Area에서 데이터를 저장하고 생성하는 위치가 다른데 기본형 데이터타입의 경우 Thread Area 안에 스택 영역에 생성이 되고 참조형 데이터타입은 힙영역에서 생성되게됩니다.리터럴리터럴은 데이터 그 자체를 의미합니다. 상수와 많은 착각을 일으키고는 하는데 상수의 경우 한 번만 값을 저장 가능한 변수를 의미하고 리터럴의 경우 데이터 그자체를 의미하기 때문에 차이가 있습니다.예를 들어 아래의 코드에서 int에 대입하는 1이 리터럴이 되는 것이며 앞에 final을 붙이면 상수가 되는 것입니다. 따라서 각각의 변수 타입에 따라 표현범위에 있는 값이 리터럴로 입력 가능합니다.int a = 1; //리터럴은 1final int a = 1; //상수로 선언변수 선언 및 초기화하는 방법변수를 선언한다는 것은 메모리에 데이터를 저장할 공간을 지정해 주는 것입니다.변수를 선언하는 방식은 아래 코드와 같습니다.변수타입 변수명;ex) int a;이렇게 변수가 선언되면 변수타입에 해당하는 크기만큼 메모리에 용량이 할당됩니다.변수의 종류는 클래스 변수, 인스턴스 변수, 지역 변수로 나누어 볼수 있습니다.먼저 클래스 변수는 클래스가 참조될때 활용되어 전체 클래스에 적용되고 인스턴스 변수는 객체가 생성될때 같이 생성됩니다.지역변수의 경우에서는 메소드안에서 선언되고 메소드안에서만 사용가능합니다.선언된 변수는 클래스 아래에 선언된 인스턴스 변수의 경우는 1-1의 표에서 확인한 기본값이 저장되어 있는 상태이지만 지역변수의 경우는 반드시 초기화가 필요합니다.초기화하는 방식은 명시적 초기화, 생성자, 초기화 블럭을 활용하는 방법이 있습니다.명시적 초기화변수타입 변수명 = 초기화할 값;ex) int a = 0;생성자 활용 초기화ClassA ca = new ClassA();ca.a = 1;ca.b = &#39;A&#39;;ca.c = &quot;KSB&quot;;//만약 기본 생성자가 아닌 매개변수가 정해진 생성자가 정의되어 있다면 이렇게 초기화 할 수 도 있다.ClassA ca = new ClassA(1,&#39;A&#39;,&quot;KSB&quot;);초기화블록을 활용한 클래스, 인스턴스 변수 초기화class ClassA{ static { } //클래스 초기화 블럭 { } //인스턴스 초기화 블럭}변수의 스코프와 라이프타임변수의 스코프란 변수에 대하여 접근과 변수가 존재할 수 있는 영역을 의미합니다. 이런 변수의 스코프로 구분해보면 클래스 변수, 인스턴스 변수, 지역 변수로 나누어 볼 수 있습니다. 이런 변수의 종류를 결정하는 것은 ‘변수가 선언된 위치’가 결정하게 됩니다.먼저 클래스 변수와 인스턴스 변수는 클래스의 내부에 선언하여야 하는데 그중 클래스 변수는 static을 앞에 붙여서 선언해주어야 합니다. 지역변수는 메소드 안에서 선언을 하면 지역변수로 선언되게 됩니다. 변수의 종류 선언 위치 생성시기(메모리 할당 시기) 변수의 스코프 클래스 변수 클래스 영역 클래스가 메모리에 올라갈 때 클래스 전역(클래스 기반으로 생성된 각각의 인스턴스에 공유됨) 인스턴스 변수 클래스 영역 인스턴스가 생성될 때 각각의 인스턴스 지역 변수 메소드 영역 변수 선언문이 수행되었을 때 메소드 안 각각의 변수의 라이프타임은 클래스 변수의 경우 프로그램이 종료할때까지 적용되고 인스턴스 변수의 경우는 인스턴스가 참조 되고 있을때에는 유지되다가 객체를 참조하는 변수가 없을 경우 JVM의 Garbage Collector가 제거하게 됩니다. 지역변수의 경우 메소드가 끝나면 소멸되어 사용할 수 없게 됩니다.타입 변환, 캐스팅 그리고 타입 프로모션타입 변환은 자바의 연산에 도움을 주기 위한 방법입니다. 자바에서 연산은 동일한 데이터 타입에서만 가능합니다. 하지만 프로그램을 구성하다보면 서로 다른 데이터 타입끼리의 연산이 필요로 한 경우가 있습니다. 이럴때 필요한 것이 타입 변환으로 종류로는 캐스팅(강제 형변환)과 타입 프로모션이 있습니다(자동 형변환).먼저 타입 프로모션은 프로그램을 실행하면 자동적으로 형변환이 일어나는 것입니다. 타입 프로모션은 작은 메모리 크기의 데이터 타입을 큰 메모리 타입으로 변환시키게 됩니다. 먼저 예를 한번 들어보겠습니다.byte a = 10;int b = a; 이런 경우에는 1byte의 byte타임을 4byte인 int에 넣기 때문에 별다른 오류나 문법의 필요없이 형변환이 자동으로 이뤄지게됩니다.이처럼 자동 형변환이 이루어지는 순서는 다음과 같습니다.byte(1) &amp;lt; short(2) &amp;lt; int(4) &amp;lt; long(8) &amp;lt; float(4) &amp;lt; double(8)float와 double의 경우는 용량은 작지만 표현할 수 있는 값이 더 크기 때문에 자동형변환이 가능합니다. 또한 문자형을 정수로 변환하게되면 유니코드 값이 저장되게 됩니다.다음으로 캐스팅은 타입 프로모팅이 이뤄지는 경우를 제외한 상황에 연산을 하기위해 강제로 형변환을 시켜주는 것입니다.캐스팅의 문법은 변환시킬 변수 앞에 괄호하고 변환하고자 하는 데이터 타입을 적으면 변환시키게됩니다. 여기서 주의해야 할것은 표현할 범위가 더 작은 데이터타입으로 변환하여 넣을때 작은 데이터타입의 표현 범위를 벗어나게되면 입력한 데이터와는 전혀 다른 값이 나올수도 있어 주의해야합니다.위 그림을 보면 넣은 값은 7410이지만 강제 형변환으로 앞의 1byte가 사라져 11110010(2) 가 남게되며 첫자가 1이기 때문에 음수로 판단되어 실제값은 2의 보수인 -14라는 값이 출력됩니다.1차 및 2차 배열 선언하기자바에서 배열의 선언은 두 가지 방법으로 가능합니다.변수 선언에서 데이터타입 뒤에 []를 입력하는 방법과 변수 명뒤에 []를 입력하는 방법입니다.int[] array; //가능int array[]; //가능이처럼 선언하면 배열은 null값을 가지고 있습니다. 이후 초기화를 하면 배열의 주소가 할당되어 사용을 할 수 있게됩니다. 초기화의 방식은 여러가지가 있습니다.int[] array = new int[3];// ORint[] array = {0, 1, 2};// ORint[] array;Arrays.fill(array,1);// ORfor(int i=0;i&amp;lt;i_array.length;i++) { array[i]=i;}2차원 배열도 크게 다르지 않습니다. []를 추가해주는 것으로 2차원,3차원 배열을 구성할 수 있습니다.int[][] array; //가능int array[][]; //가능2차원 배열의 초기화 방법입니다.int[][] array = new int[4][3];// ORint[][] array = [{0, 1, 2},{3,4,5},{6,7,8},{9,10,11}];// ORfor(int i=0;i&amp;lt;array.length;i++) { for(int j=0;j&amp;lt;array[i].length(); j++) array[j]=j; }}타입 추론, var타입 추론이란 코드 작성당시에는 타입이 정해지지 않았지만, 컴파일러가 그 타입을 유추하는 것을 의미합니다.자바 9까지는 generics나 lamda식에 대해서만 타입추론을 지원했지만 자바 10부터 타입추론을 지원하는 var이라는 키워드가 추가되어 자바에서도 타입추론을 사용가능하게 되었습니다.var은 지역변수로 사용해야하고 선언과 동시에 초기화가 필요합니다" }, { "title": "자바스터디 1주차", "url": "/posts/whiteship-study-1week/", "categories": "study", "tags": "", "date": "2020-11-23 00:00:00 +0900", "snippet": "아래 내용은 https://github.com/league3236/startJava/blob/master/live_study/week1.md 내용을 차용했음을 알려드립니다.GOAL자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해 하기.학습할 것 JVM이란 무엇인가 컴파일 하는 방법 실행하는 방법 바이트코드란 무엇인가 JIT 컴파일러란 무엇이며 어떻게 동작하는지 JVM 구성 요소 JDK와 JRE의 차이JVM이란 무엇인가자바 가상 머신(Java Virtual Machine, JVM)은 시스템 메모리를 관리하면서 자바 기반 애플리케이션을 위해 이식 가능한 실행 환경을 제공한다.java virtual machine의 줄임말이며 Java Byte Code를 OS에 맞게 해석 해주는 역할을 합니다. Java Compiler는 .java 파일을 .class 라는 java byte code로 변환 시켜 준다. byte code는 기계어가 아니기 때문에 바로 os에서 바로 실행되지 않는다. 이때 jvm은 os가 bytecode를 이해할 수 있도록 해석 해준다. 하지만 jvm의 해석을 거치기 때문에 c언어와 같은 네이티브 언어에 비해 속도가 느렸지만 JIT(Just In Time) 컴파일러를 구현해 이점을 극복했다. Byte Code 는 JVM 위에서 os상관없이 실행된다. 이런점이 java의 가장 크나 장점이라고 할 수 있다. os에 종속적이지 않고 Java 파일 하나만 만들면 어느 디바이스든 JVM 위에서 실행 할 수 있다. JVM은 크게 Class Loader, Runtime Data Areas, Excution Engine, Garbage Collector 4가지로 구성되어 있다.컴파일 하는 방법cmd에서 자바 컴파일 하기class 파일 만들기$ javac main.java파일 실행$ java main자바 컴파일 과정개발자들이 ide나 terminal 환경에서 .java 파일을 생성한다. 그리고 build라는 작업을통해 .class 파일을 생성하게 된다.이것은 아직 컴퓨터가 읽을 수 없는 자바 바이트코드(반기계어) 이다.출처 : https://t1.daumcdn.net/cfile/tistory/995DA63D5AE9701B34이렇게 생성된 자바 바이트 코드 (.class)는 클래스 로더에 의해서 JVM 내로 로드 되고, 실행 엔진에 의해 기계어로 해석되어 메모리 상(Runtime Data Area)에 배치되게 된다.실행엔진에는 Interpreter와 JIT(Just-In-Time) Compiler가 있다.Interpreter는 바이트 코드를 한줄씩 읽기 때문에 실행이 느린 단점이 있다.이러한 단점을 보완하기 위해 나온것이 JIT Compiler이다. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일 하고 더이상 인터프리팅 하지 않고 해당 코드를 직접 실행하는 것이다. JIT Compiler에 의해 해석된 코드는 캐시에 보관하기 때문에 한 번 컴파일 된 후에는 빠르게 수행하는 장점이 있다.하지만 인터프리팅 방식보다는 훨씬 오래 걸리므로 한번만 실행하면 되는 코드는 인터프리팅하는것이 유리하다. interpreter자바 바이트 코드를 한줄 씩 실행, 여러번 실행하는 환경에서는 다소 느림 JIT CompilerInterpreter의 단점을 보완, 전체 바이트 코드를 컴파일, 캐시 사용으로 한번 컴파일하면 다음에는 빠르게 수행실행하는 방법eclipseintellij바이트코드란 무엇인가바이트코드(Bytecode, portable code, p-code)는 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법이다. 하드웨어가 아닌 소프트웨어에 의해 처리되기 때문에 보통 기계어 보다 더 추상적이다.JVM이 사용자가 작성한 .java 소스 코드 파일을 운영체제에 실행 가능한 명령어 집합 파일로 컴파일 하는 과정 중에서 필요한 코드 JVM이 이해할 수 있는 언어로 변환된 자바 소스코드를 의미 자바 컴파일러에 의해 변환되는 코드의 명령어의 크기가 1byte라서 자바 바이트 코드라고 불림 자바 바이트 코드는 자바 가상 머신만 설치되어 있다면 어느 운영체제에서도 실행 가능JIT 컴파일러란 무엇이며 어떻게 동작하는 지JIT 컴파일 (just-in-time-compilation) 또는 동적 번역(dynamic translation)은 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다.전통적인 입장에서 컴퓨터 프로그램을 만드는 방법은 두가지가 있는데, 인터프리트 방식과 정적 컴파일 방식으로 나눌 수 있다. 이 중 인터프리트 방식은 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행하며, 반면 정적 컴파일을 실행하기 전에 프로그램 코드를 기계어로 번역한다.JIT 컴파일러는 두가지의 방식을 혼합한 방식으로 생각할 수 있는데, 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 분 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.최근에 자바 가상 머신과 .NET, V8(node)에서는 JIT 컴파일을 지원한다. 즉, 자바 컴파일러가 자바 프로그램 코드를 바이트 코드로 변환한 다음, 실제 바이트 코드를 실행하는 시점에서 자바 가상 머신이 바이트 코드를 JIT 컴파일을 통해 기계어로 번역한다.다른 컴파일 유형과는 달리, JIT 컴파일러의 주요 정의 특성은 프로그램이 시작되고 코드를 컴파일한 후에 JIT 컴파일러를 실행한다는 것이다.HelloLeaguecat.java 소스 코드를 생성했다고 가정하자 HelloLeaguecat.java 소스 코드를 작성 javac.exe(Java 컴파일러)가 바이트 코드 (HelloLeaguecat.class)로 변환해준다. 그리고 JVM에서 각 운영체제에 맞는 기계어로 번역해 전달한다. 출처 : https://miro.medium.com/max/1400/1*VFo0CC-chzvqJk6sls6ukQ.png그림을 보면 JIT 컴파일러는 JRE 안에 존재한다. (JRE는 JDK에 포함되고 JVM안에도 JIT이 존재한다.)즉, JIT 컴파일러는 같은 코드를 매번 해석하지 않고 실행할 때 컴파일을 하면서 해당 코드를 캐싱해버린다. 이후엔, 바뀐 부분만 컴파일 하고 나머지는 캐싱된 코드를 사용한다. 인터프리터의 속도를 개선 가능하다.위에서 이미 작성했던 비교 내용이다. interpreter자바 바이트 코드를 한줄 씩 실행, 여러번 실행하는 환경에서는 다소 느림 JIT CompilerInterpreter의 단점을 보완, 전체 바이트 코드를 컴파일, 캐시 사용으로 한번 컴파일하면 다음에는 빠르게 수행JIT 동작 방식출처 : https://www.geeksforgeeks.org/just-in-time-compiler/java는 객체 지향 지향 접근 방식을 따른다, 결과적으로 클래스로, JVM에 의해 실행되는 byte code로 구성되게 된다. 런타임에서 JVM은 클래스 파일을 로드하고 각각 적절한 계산이 수행된다. 인터프리터시 java 응용 프로그램이 느린 경향이 있다. JIT 컴파일은 런타임에 바이트 코드를 원시 기계 코드로 컴파일 시켜 Java 프로그램의 성능을 향상 시킨다. JIT 컴파일러는 메서드 호출 내내 활성화 된다. 이때, 컴파일된 메서드의 경우 다이랙트로 호출하게되는데, 이론적으로 컴파일에 프로세서 시간이나 메모리 사용이 필요하지 않다면 native compiler와 java 컴파일러의 속도는 동일하다 JVM 구성 요소출처 : https://media.vlpt.us/images/hono2030/post/21adf2f3-f155-4e50-bdb6-5e8b1675129c/image.png class loaderruntime 시점에 클래스를 로딩하게 해주며 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 된다. runtime data areasJvm이 프로그램을 수행하기 위해 os로 부터 별도로 할당 받은 메모리 공간을 말하며, runtime data areas는 크게 5가지 영역으로 나눌 수 있다. execution engineload된 class의 bytecode를 실행하는 runtime module이 바로 execution engine이다. class loader를 통해 jvm 내의 runtime data areas에 배치된 바이트 코드는 execution engine에 의해 실행된다. Garbage CollectorGarbage Collector(GC)는 Heap 메모리 영역에 생성된 객체들 중에 참조되지 않은 객체들을 제거하는 역할을 한다. GC의 동작시간은 일정하게 정해져 있지 않기 때문에 언제 객체를 정리할지는 알 수 없다. 즉 바로 참조가 없어지자마자 작동하는 것이 아니라는 것이다. 또한 GC를 수행하는 동안 GC Thread를 제외한 다른 모든 Thread는 일시정지상태가 된다.특히, Full GC가 일어나는 수초간 모든 Thread가 정지한다면 심각한 장애로 이어질 수 있다.최초 JVM이 나왔을때 Interpreter(한 줄씩 해석하고 실행) 이였기 때문에 속도가 느리다는 단점이 있었지만 JIT compiler (just in time) 방식을 통해 이 점을 보완해왔다. JIT는 bytecode를 어셈블러 같은 nativecode로 바꿔서 실행이 빠르지만 역시 변환하는데 비용이 발생한다. 이 같은 이유 때문에 jvm은 모든 코드를 jit compiler 방식으로 실행하지 않고 interpreter 방식을 사용하다 일정 기준이 넘어가면 jit compiler 방식으로 실행한다.JDK와 JRE 차이ref 자바 마스터북자바의 세가지 에디션 Java SE(Standard Edition)Java vm과 표준 api 등을 정리한 가장 표준적인 버전이다. PC나 서버 등에서 동작하는 애플리케이션을 개발 및 실행하는 경우에 사용한다. Java EE(Enterprise Edition)웹 서비스나 서버 간 통신, 메일 송신 등 서버 애플리케이션에 필요한 기능이 많이 포함되어 있다. Java ME(Micro Edition)가전제품과 휴대전화 등의 임베디드 시스템용의 애플리케이션을 개발하기 위한 에디션이다. Java SE에 비해 사용할 수 있는 기능이 한정되어 있지만 필요한 리소스(CPU나 메모리 등)가 적게 들어 임베디드 시스템 등에서도 잘 동작한다. 또한 자바는 실행 환경 (JRE) 및 개발 환경 (JDK)의 두가지로 나누어져 있다.JDK와 JREA. Jre(Java Runtime Environment)자바 애플리케이션의 실행 환경이다. 이미 컴파일된 자바 애플리케이션의 모듈(JAR 파일과 클래스 파일 등)을 이용하여 실행할 수 있다.B. JDK(Java Development Kit)자바 애플리케이션의 개발 환경이다. 실행 환경뿐만 아니라 소스 파일의 컴파일러 및 디버거 등 자바 애플리케이션을 개발하기 위한 도구가 포함되어 있다.애플리케이션을 JRE가 있으면 작동시킬 수 있다. 단, 운영할때 디버깅 및 분석 등을 하고자 하는 경우에는 jdk에 들어있는 도구가 필요하다. 따라서 서버 등의 운영 환경에 설치하는 경우에도 JRE보다는 JDK를 선택하는 것이 좋은 경우도 있다.참조 http://www.itworld.co.kr/news/110837 자바 마스터 북 (http://www.yes24.com/Product/Goods/58960335) https://asfirstalways.tistory.com/158 https://superblo.tistory.com/entry/%EC%BB%A4%EB%A7%A8%EB%93%9Ccmd%EC%97%90%EC%84%9C-%EC%9E%90%EB%B0%94-%EC%BB%B4%ED%8C%8C%EC%9D%BC%ED%95%98%EA%B8%B0-%EB%B0%8F-%EC%8B%A4%ED%96%89-%EB%B0%A9%EB%B2%95 https://aljjabaegi.tistory.com/387 https://medium.com/@kimddub/java-jvm%EA%B3%BC-%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C-bytecode-da9f269c8ce9 https://ko.wikipedia.org/wiki/%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C https://medium.com/@js230023/%EC%9E%90%EB%B0%94-jvm%EA%B3%BC-%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%BD%94%EB%93%9C-4e754ee02490 https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC https://m.blog.naver.com/ki630808/221844888233 https://medium.com/@ahn428/java-jit-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-c7d068e29f45" }, { "title": "JUNIT in egov", "url": "/posts/junit/", "categories": "TDD", "tags": "", "date": "2020-11-11 00:00:00 +0900", "snippet": "JUNIT 테스트 코드 작업을 지원하는 라이브러리로 java 진영 뿐 아니라, xUnit 형태로 다른 언어도 지원 러너 - 테스트를 실행 스위트 - 여러 테스트 클래스를 묶는 그룹 테스트 클래스 - 여러 테스트를 포함한 클래스 Mock not real but appearing or pretending to be exactly like something 진짜처럼 모습을 가장하는 것 테스트에서는 구현하기 힘들거나, 어려운 객체를 가장하는 객체를 의미 이러한 기능은 지원하는 라이브러리는 여러가지가 있으나, 아래에서는 eazymock이라는 라이브러리를 이용 pom.xml &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.4&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.easymock&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;easymock&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.easymock&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;easymockclassextension&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.dbunit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dbunit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.4.3&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.unitils&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;unitils&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 테스트에서만 사용하기 위해, 속성을 test로 설정서비스 레이어 테스트package egovframework.com.org.onnara.service.impl;import static org.easymock.EasyMock.expect;import static org.easymock.EasyMock.verify;import static org.junit.Assert.assertEquals;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.unitils.UnitilsJUnit4TestClassRunner;import org.unitils.easymock.EasyMockUnitils;import org.unitils.easymock.annotation.Mock;import org.unitils.inject.annotation.InjectIntoByType;import org.unitils.inject.annotation.TestedObject;import egovframework.com.cmm.EgovMessageSource;import egovframework.com.org.syn.service.EgovOrgnztSync;import egovframework.com.org.syn.service.impl.EgovOrgnztSyncServiceImpl;import egovframework.rte.fdl.property.EgovPropertyService;@RunWith(UnitilsJUnit4TestClassRunner.class)public class OnnaraUserMngServiceImplTestByBase { @Mock @InjectIntoByType protected EgovPropertyService propertyService; @Mock @TestedObject private EgovOrgnztSyncServiceImpl syncService; @Before public void setup(){ syncService = new EgovOrgnztSyncServiceImpl(); } @Test /** * baseUserInfoSetting * @throws Exception */ public void 기본정보_미존재시_기본값_설정처리_확인() throws Exception { //녹화 expect(propertyService.getString(&quot;Globals.orgSyncUserDefaultEamilAdres&quot;)).andReturn(&quot;test&quot;); expect(propertyService.getString(&quot;Globals.orgSyncUserDefaultOffmTelno&quot;)).andReturn(&quot;test&quot;); expect(propertyService.getString(&quot;Globals.orgSyncUserDefaultFxnum&quot;)).andReturn(&quot;test&quot;); expect(propertyService.getString(&quot;Globals.orgSyncUserDefaultOrgnztZip&quot;)).andReturn(&quot;test&quot;); expect(propertyService.getString(&quot;Globals.orgSyncUserDefaultOrgnztAdres&quot;)).andReturn(&quot;test&quot;); expect(propertyService.getString(&quot;Globals.orgSyncUserDefaultOrgnztAdres2&quot;)).andReturn(&quot;test&quot;); //재생 EasyMockUnitils.replay(); EgovOrgnztSync testegovOrgnztSync = new EgovOrgnztSync(); syncService.baseUserInfoSetting(testegovOrgnztSync); //검증 verify(propertyService); assertEquals(&quot;이메일정보&quot;, &quot;test&quot;, testegovOrgnztSync.getEmailAdres()); assertEquals(&quot;부서연락처&quot;, &quot;test&quot;, testegovOrgnztSync.getOrgnztTelno()); assertEquals(&quot;부서팩스&quot;, &quot;test&quot;, testegovOrgnztSync.getOrgnztFaxno()); assertEquals(&quot;우편번호&quot;, &quot;test&quot;, testegovOrgnztSync.getOrgnztZip()); assertEquals(&quot;주소&quot;, &quot;test&quot;, testegovOrgnztSync.getOrgnztAdres()); assertEquals(&quot;주소2&quot;, &quot;test&quot;, testegovOrgnztSync.getOrgnztAdres2()); } } 대상 설명 @RunWith(UnitilsJUnit4TestClassRunner.class) 사용 러너를 설정한다 @Mock Mock객체임을 선언 @InjectIntoByType 테스트될 서비스에 주입되는 의존성을 설정해준다. unitils에서 지원하는 기능 @TestedObject 테스트 대상 서비스를 선언 @Before 매 테스트가 실행시, 초기화 시켜줄 method에 붙인다. @Test 테스트 메소드에 붙인다. assert* 단언문으로 해당 테스트를 검증 가능하다. 위에서는 assertEquals를 사용하여 검증을 진행 easyMock easyMock의 프로세스 흐흠은 [녹화 &amp;gt; 재생 &amp;gt; 검증 ]으로, 진행된다. 녹화 테스트하기위한 프로세스를 설정하는 단계로, 기대되는 프로세스를 미리 지정하여 검증이 가능하도록 할 수 있다. expect([method]).andReturn([value]) // 구현중이거나, 외부 API를 테스트하기위해, 특정 method를 호출시 반환값을 설정한다. 재생 녹화된 프로세스를 재생하는 기능 반드시 재생 후, 테스트 대상 메소드를 실행 검증 verify([target]) 으로 녹화된 프로세스 테스트 Unitls eazymock의 부족한 기능을 보완하는 라이브러리 실 서비스에서 의존성을 주입받는 구현체를 적절하게 주입해준다 DTO 레이어 테스트 DB 테스트를 위해서는 DB 접속 정보, 타입등의 정보를 미리 설정해 주어야 한다.unitils에서 제공하는 기능을 통해 간단하게 설정 가능. [projectName]/src/test/resources/unitils.properties# Properties for the PropertiesDataSourceFactory# PropertiesDataSourceFactory 설정database.driverClassName=oracle.jdbc.driver.OracleDriverdatabase.url=jdbc:oracle:thin:@192.168.200.225:1521:sfepdatabase.userName=seogudatabase.password=sfseogu# 테스트시 적용한 트렌젝션 처리를 설정, 지원하는 설정값은 &#39;disabled&#39;, &#39;commit&#39;, &#39;rollback&#39;.# disabled 사용시, 트렌젝션 처리를 하지 않는다.# commit 사용시, commit 처리를 진행 한다.# rollback 사용시, 매 테스트 마다 rollback 처리를 진행한다DatabaseModule.Transactional.value.default=rollback# DataSet, ExpectedDataSet 사용을 위한 dms 정보 설정 ( &#39;oracle&#39;, &#39;db2&#39;, &#39;mysql&#39;, &#39;hsqldb&#39;, &#39;postgresql&#39; )database.dialect=oracle# 스키마 이름 설정database.schemaNames=SEOGU# 트랜잭션 매니저 설정 ( &#39;auto&#39;, &#39;spring&#39;, &#39;simple&#39; )transactionManager.type=auto# 테이블 자동 생성 등의 스키마 관리 기능 사용 여부 및 DML 위치 설정#updateDataBaseSchema.enabled=true#dbMaintainer.script.locations=src/test/resources/META-INF/persistence/maintenance/oracle#dbMaintainer.disableConstraints.enabled=truepackage egovframework.com.org.syn.service.impl;import static org.junit.Assert.*;import javax.sql.DataSource;import org.junit.Test;import org.junit.runner.RunWith;import org.unitils.UnitilsJUnit4TestClassRunner;import org.unitils.database.annotations.TestDataSource;import org.unitils.database.annotations.Transactional;import org.unitils.database.util.TransactionMode;import org.unitils.spring.annotation.SpringApplicationContext;import org.unitils.spring.annotation.SpringBean;import egovframework.com.cmm.ComDefaultVO;import egovframework.com.org.syn.service.EgovOrgnztSync;@RunWith(UnitilsJUnit4TestClassRunner.class)@Transactional(TransactionMode.ROLLBACK)@SpringApplicationContext({ &quot;/spring/*.xml&quot;, &quot;/egovframework/sqlmap/*.xml&quot;,})public class EgovOrgnztSyncDaoTest{ /** * unitils.properties 에 설정 된 database 접근 정보를 기반으로 * 테스트 용 DataSource 를 만든 후 자동으로 injection 해 준다. * (unitils.properties 파일의 위치와 이름은 변경할 수 없다.) * * updateDataBaseSchema.enabled=true 로 설정되어 있으면 * dbMaintainer.script.locations 에서 지정한 위치의 sql 문을 실행시켜준다. * 주의) 생성 시점은 test 메소드가 실행되기 전이다. * 따라서, 단순히 TestDataSource 만 선언하는 것이 아니라, * 하나 이상의 test 메소드라도 있어야 결과 확인이 가능하다. * * @see unitils.properties * @see dbMaintainer.script.locations 에서 지정한 위치의 sql 문 */ @TestDataSource private DataSource dataSource; /** 테스트를 위해 만든 타겟 클래스로서 공지사항 비즈니스 구현을 위한 Dao */ @SpringBean(&quot;egovOrgnztSyncDao&quot;) //위의 설정에서 의존성을 전부 주입해주지 않으면, spring bean 생성 오류가 발생 EgovOrgnztSyncDao dao = new EgovOrgnztSyncDao(); @Test public void DB_연결확인(){ assertNotNull(&quot;DB 연결 확인&quot;,dataSource); } @Test public void testSelectDeptSyncCnt() throws Exception { ComDefaultVO vo = new ComDefaultVO(); int result = dao.selectDeptSyncCnt(vo); assertEquals(&quot;조회 건수&quot;, 0 , result); } /** * 사용자싱크 한건(USER_WORKER테이블 --&amp;gt; COMTNEMPLYRINFO테이블로 적용) * @throws Exception */ @Test public void 사용자_신규_등록() throws Exception { String userId = &quot;test&quot;; String syncNo = &quot;1&quot;; EgovOrgnztSync syncResult = dao.userSyncProc(userId, syncNo); assertEquals(&quot;신규등록성공&quot;, &quot;Y&quot;,syncResult.getInResult()); } // 동기화 이력 저장 @Test public void testUserSyncResultUpdate() throws Exception { EgovOrgnztSync selectUserSync = new EgovOrgnztSync(); selectUserSync.setSyncNo(&quot;1&quot;); selectUserSync.setUserId(&quot;test&quot;); selectUserSync.setInResult(&quot;Y&quot;); dao.userSyncResultUpdate(selectUserSync); } } 대상 설명 @RunWith(UnitilsJUnit4TestClassRunner.class) 사용 러너를 설정한다 @TestDataSource DB 커넥션을 생성 @Transactional 트랜젝션 오류 발생시, 정책설정 (위에서는 ROLLBACK) @SpringApplicationContext 설정 정보를 위치 @SpringBean([name]) 스프링의 빈 팩토리에서 대상 빈을 주입해준다. 일반 dto를 사용하듯이 사용후, 검증하면 된다. 롤백 부분은 아직 추가 검증이 필요하다." }, { "title": "Review", "url": "/posts/review/", "categories": "", "tags": "", "date": "2020-11-01 00:00:00 +0900", "snippet": "소프트웨어 장인 특정 기술에 대한 서적 자바, 하이버네이트, 노드js… 특정 개념에 대한 서적 TDD, DDD, OOP, 함수형 프로그래밍, Nosql데이터베이스 행동앵식에 대힌 서적 애자일, 린, 심리학, 철학… 고전 실용주의 프로그래머, 디자인패턴, 테스트주도개발, 익스트림 프로그래밍, 클린코더, 소프트웨어 장인장신, 리팩토링" }, { "title": "리눅스 단축키", "url": "/posts/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8B%A8%EC%B6%95%ED%82%A4/", "categories": "linux", "tags": "", "date": "2020-10-30 00:00:00 +0900", "snippet": "상태정보 확인 drwxr-xr-x 3 root root 4096 2018-04-09 16:14 work d : 디렉토리 여부 ( 디렉토리의 경우 : d , 아니면 -) 커맨드 목록 파일 목록 확인 li -l (list : 파일 표시) -a (모든파일표시 (숨김파일표시 .(dot)으로 시작)) -S (크기별로 오름차순) 현재 위치 확인 pwd 디렉토리 생성 mkdir (make directory 의 축약형) -p (경로 전체 디렉토리 생성) 파일 생성 touch [파일명] &amp;gt; [파일명] 이동 cd (change directory) 화면정리 clear 삭제 rm (remove) -r (디렉토리 삭제) 상세 도움말 man [커맨드] 간단 도움말 –help (옵션 값으로 사용) " }, { "title": "강연", "url": "/posts/%EA%B0%95%EC%97%B0201030/", "categories": "media", "tags": "", "date": "2020-10-30 00:00:00 +0900", "snippet": "프로그래밍 학습의 어려움과 극복하는 방법목차 프로그래밍 학습이 어려운 이유 극복하는 방법 프로그래밍 학습에서 취업까지 조언프로그래밍 학습이 어려운 이유(Why Learning to Code is So Damn Hard) 숙련도는 증가에 따라 반드시 자신감이 증가하지 않는다. 초기에는 자신감이 높음 중반 이후, 감소 극단으로 갈수록 다시 증가 극복하는 방법 Surviving the Hnad-Holding Honeymoon 강의 내용이 풍부 다양한 초보 강의를 검토한 후 하나를 선택해 학습 이 단계에서 대부분의 강의 내용은 비슷하기 때문에 하나를 선택해 반복 학습 Surviving the Cliff of Confusion 초보라 할지라도 학습을 같이할 동료를 구한다. 다른 사람의 코드 읽기 지속적으로 작은 코드를 시작하고 빌드하면서 디버깅에 대한 두려움을 제거 Surviving the Desert of Despair 하나의 목표를 설정한 후 목표에 집중 수박 겉핥기 식의 다양한 지식 습득이 아니라 한 분야에 대한 깊이 있는 지식 습득 구체적인 목표 의식을 가지고 의식적인 연습을 함으로써 시간 낭비를 최소화 Surviving the Upswing of Awesome Best practices를 찾아 연습하고, 지식의 빈틈을 보완 설계, 아키텍, 배포와 같이 좋은 개발자가 되기 위한 연습 이 단계를 극복하가 위한 핵심은 피드백을 받는 것 코칭을 해줄 멘토나 동료를 찾는 것이 중요함 주변 정리 프로그래머로 취업하고 싶다면 일단 주변 정리부터 시작 친구관계 끊기 모든 우선순위에서 프로그래밍 학습을 1순위 프로그래밍 관련 책 여가생활 금지 프로그래머 취업 과정 최소 1년 5,6개월 정보 학습하고 취업가능 직장 생활하면서 학습을 병행하는 것은 정말 힘듦학습 하는 방법 온라인 상에 정말 좋은 컨텐츠 많음. 하지만 의지력을 가지고 지속하기 힘듦 의지력이 약하다면, 시작은 단기 속성학원 활용 속성 학원에서 취업 가능한 상태 만들기 힘듦 학원에서 반드시 배워야할 것은 프로그래밍 기초, 개발환경, 어떻게 학습할 것인가가 중요 감 잡으면 독학독학하는 방법 같이 학습할 사람을 만드는 것이 가장 중요함. 혼자하면 지치고 포기할 가능성이 높음 스터디 그룹을 만드는 것도 좋은 방법. 누가 만들어 주기를 기다리지 말고 직접 만든다. 매일 일정시간, 장소로 출퇴근하면서 학습, 무료로 학습할 공간 찾기멘탈관리 다음 단계로 무엇을 학습할 것인지 모르겠거나, 포기하고 싶은면 기존 학원 강사나 온라인 취업후기 남기는 개발자에게 메일 보내 조언을 구함 개발자 컨퍼런스에 참여 인턴, 정직원에 지원해 자신의 부족한점 파악영상 출처" }, { "title": "TMUX 2", "url": "/posts/TMUX2/", "categories": "tools", "tags": "", "date": "2020-10-29 00:00:00 +0900", "snippet": "원본주소tmux 단축키 &amp;amp; 치트시트실행하기:tmux세션명을 주면서 시작하기:tmux new -s myname붙이기:tmux a # (또는 at이나 attach)특정 세션에 붙이기:tmux a -t myname세션 일람:tmux ls세션 강제종료:tmux kill-session -t mynametmux 내에서 머릿문자’ctrl+b’를 누르고(전 ctrl+a로 변경해서 사용중)세션:new&amp;lt;CR&amp;gt; 새로운 세션s 세션 리스트$ 세션에 이름 정하기윈도우 (탭)c 새 윈도우w 윈도우 리스f 윈도우 찾기, 윈도우에 이름 붙이기&amp;amp; 윈도우 강제 닫기패널 (화면 구분)% 세로로 나누기&quot; 가로로 나누기o 패널 바꾸기q 패널 번호 보여주기x 패널 강제종료+ 패널을 새 윈도우로 이동 (마우스로 드래그해서 선택하기 위해서 라든지)- 윈도우에서 패널로 복귀⍽ 스페이스 - 레이아웃을 토글{ 패널을 욎쪽으로 이동} 패널을 오른쪽으로 이동패널 크기 조절하기레이아웃이 자동으로 정해주는 크기가 마음에 안들 때 패널크기를 조절하기위해서 사용합니다. 제 개인적으로는 거의 안씁니다만 알아두면 편리합니다. 여기 패널크기를 조절하는 기본적인 키들입니다.: resize-pane --- 아래쪽로 조절 (저는 -D가 아래로. 원문에는 아무것도 적지 않으면 아래로 라고 하네요): resize-pane -U --- 위쪽로 조절: resize-pane -L --- 왼쪽으로 조절: resize-pane -R --- 오른쪽으로 조절: resize-pane 20 --- 아래로 20칸 조절 (저는 -D가 아래로. 원문에는 아무것도 적지 않으면 아래로 라고 하네요. ): resize-pane -U 20 --- 위로 20칸 조절: resize-pane -L 20 --- 왼쪽으로 20칸 조절: resize-pane -R 20 --- 오른쪽으로 20칸 조절: resize-pane -t 2 20 --- 2번 패널 아래로 20칸 조절 (저는 -D가 아래로. ): resize-pane -t 2 -L 20 --- 2번 패널 왼쪽으로 20칸 조절카피 모드:접두문자(ctrl+b)를 누르고 [ 를 누르면 카피모드가 됩니다. 그러면 커서키를 이용해서 화면을 이리저리 다니는 것이 가능합니다. 기본적으로 방향키로 지정되어 있습니다만 설정 파일을 이용해서 vim키로 변경을하면 윈도우나 패널 사이를 이동하기 위해서 손의 위치를 움직일 필요가 없어집니다.tmux 버퍼를 조작하기 위한 vi모드가 있습니다. 활성화 시키려면 아래의 라인을 .tmux.conf에 기술합니다.setw -g mode-keys vi이렇게 하면 h, j, k, l을 이용해서 버퍼에서 이동을 할 수 있게 됩니다.카피모드에서 나오려면 엔터를 누르면 됩니다. 한 글자 단위로 이동하는 것은 별로 효율적이지 않습니다.vi 모드를 활성화했기 때문에 여러가지 편리한 키들도 활성화 되어 있습니다.예를 들면 “w” 키를 이용해서 다음 단어로 이동한다거나 “b”를 누르면 앞의 단어로 이동합니다. “f”키를 사용해서 그 줄의 어떤 문자의 의치로 점프할 수도 있고 “F”를 이용해서 그 줄의 앞 방향으로 어떤 문자의 위치로 점프할 수 있습니다. 기능 vi emacs Back to indentation ^ M-m Clear selection Escape C-g Copy selection Enter M-w Cursor down j Down Cursor left h Left Cursor right l Right Cursor to bottom line L Cursor to middle line M M-r Cursor to top line H M-R Cursor up k Up Delete entire line d C-u Delete to end of line D C-k End of line $ C-e Goto line : g Half page down C-d M-Down Half page up C-u M-Up Next page C-f Page down Next word w M-f Paste buffer p C-y Previous page C-b Page up Previous word b M-b Quit mode q Escape Scroll down C-Down or J C-Down Scroll up C-Up or K C-Up Search again n n Search backward ? C-r Search forward / C-s Start of line 0 C-a Start selection Space C-Space Transpose chars C-t기타d 세션과 터미널 분리 detacht 전체화면 시계? 단축키 일람: 프롬프트설정 옵션# 마우스 support - 마우스를 사용하려면 on으로 해주시면 됩니다.* setw -g mode-mouse off 마우스 사용* set -g mouse-select-pane off 마우스로 패널 선택* set -g mouse-resize-pane off 마우스로 패널 리사이즈* set -g mouse-select-window off 마우스로 윈도우 선택# 터미널 모드를 256컬러set -g default-terminal &quot;screen-256color&quot;# 활동 알림 활성화setw -g monitor-activity onset -g visual-activity on# 위도우 리스트를 중앙정렬set -g status-justify centre# 패널을 최대화했다가 다시 되돌리기unbind Up bind Up new-window -d -n tmp \\; swap-pane -s tmp.1 \\; select-window -t tmpunbind Downbind Down last-window \\; swap-pane -s tmp.1 \\; kill-window -t tmp참고자료: tmux: Productive Mouse-Free Development How to reorder windows cheat sheet" }, { "title": "TMUX", "url": "/posts/TMUX/", "categories": "tools", "tags": "", "date": "2020-10-29 00:00:00 +0900", "snippet": "TMUX 리눅스 시스템에서 사용하는 서포팅 솔루션 설치 sudo yum install epel-releasesudo yum install -y tmux 버전확인 tmux -V 상세 사용법" }, { "title": "동일성 VS 동등성", "url": "/posts/%EB%8F%99%EC%9D%BC%EC%84%B1VS%EB%8F%99%EB%93%B1%EC%84%B1/", "categories": "Study", "tags": "", "date": "2020-10-23 00:00:00 +0900", "snippet": "동일성 객체의 메모리 주소값이 같음을 표시 == 를 통해 비교 동등성 객체가 가지고 있는 정보가 같은 경우 Object method 인 equals를 이용 예시 String str = new String(&quot;a&quot;);String str1 = new String(&quot;a&quot;);System.out.println(str == str1 ); //false (값이 동일하지 않다)System.out.println(str.eqauls(str1) ); //true (값이 동등하다)추가 String의 경우, 자바에서는 원시타입처럼 처리String str = &quot;a&quot;;String str1 =&quot;a&quot;;System.out.println(str == str1 ); //falseSystem.out.println(str.eqauls(str1) ); //true" }, { "title": "JVM 구조", "url": "/posts/jvm/", "categories": "Study", "tags": "", "date": "2020-10-13 00:00:00 +0900", "snippet": "JVM 구조 클래스 로더 시스템 바이트 코드를 읽고 메모리에 저장 로딩 &amp;gt; 링크 &amp;gt; 초기화(변수에 할당) 메모리 공통 메서드 ( 클래스 수준의 정보 ) 힙영역 = 객체 저장 쓰래드 스택 ( 콜 스택) PC ( Program Counter) 네이티브 스택 ( 네이티브 메소드 호출 시 ) 네이티브 메서드란 ? native 이름이 붙고, 구현체가 java가 아닌 메소드 실행 엔진 바이트코드를 네이티브코드로 컴파일 처리 JIT 컴파일러 GC (Garbage Collctor) stop-the-world" }, { "title": "js tip", "url": "/posts/jstip/", "categories": "tips", "tags": "", "date": "2020-10-07 00:00:00 +0900", "snippet": " 비구조화 할당(Destructuring) const testObject = {name : &#39;테스트&#39;,price : 1000,enname : &#39;test&#39;} badlet print( testObject ) { return testObject.name + &#39;이름 &#39; + testObject.price + &#39;가격&#39; + testObject.enname + &#39;영문&#39;;} not badlet print( testObject ) { return `${testObject.name}이름 ${testObject.price}가격${testObject.enname}영문`;} goodlet print = function( ${name,price,enname} ) { return `${name}이름 ${price}가격 ${enname}영문`;}let print= function( testObject ) { const ${name,price,enname} = testObject; return `${name}이름 ${price}가격 ${enname}영문`;} 템플릿 리터럴(Template literal) const testObject = {name : &#39;테스트&#39;,price : 1000,enname : &#39;test&#39;} badlet print = testObject.name + &#39;이름 &#39; + testObject.price + &#39;가격&#39; + testObject.enname + &#39;영문&#39;; goodlet ${name,price,enname} = testObject; let print = `${name}이름 ${price}가격 ${enname}영문`; good(응용)let print = function( name,price,enname ) { let str0 = string[0]; let str1 = string[1]; let str2 = string[2]; return name + str0 + price + str1 + enname + str2 ; }let print2 = print`${name}이름 ${price}가격 ${enname}영문`;템플릿 리터럴 관련 블로그 spread 연산자 (Spread syntax) const testObject = {name : &#39;테스트&#39;,price : 1000,enname : &#39;test&#39;} 중국어 이름을 추가해본다 badtestObject[&#39;chname&#39;] = Shíyàn; not badObject.assign(testObject , {chname : Shíyàn}); goodtestObject = {...testObject , chname : Shíyàn}; 배열을 이용해 본다 good(array)let testarray = [&#39;test1&#39;,&#39;test2&#39;]; badtestarray.push(&#39;test3&#39;); goodtestarray = [...testarray, &#39;test3&#39;]; 반복문(Loops) const testObject = [{name : &#39;테스트1&#39;, price : 1000, enname : &#39;test1&#39; },{name : &#39;테스트2&#39;, price : 2000, enname : &#39;test2&#39; },{name : &#39;테스트3&#39;, price : 3000, enname : &#39;test3&#39; },{name : &#39;테스트4&#39;, price : 4000, enname : &#39;test4&#39; }] badlet totalprice = 0;for(let i = 0 ; i &amp;lt; testObject.length ; i++ ) { totalprice += testObject[i].price;} goodlet totalprice = testObject.reduce((acc , cur) =&amp;gt; acc + cur.price, 0);reduce 사용법 async/await let ran = () =&amp;gt; { return Promise.resolve(Math.random())}; 랜덤한 3개의 수의 합을 구해본다 Promise란 badlet sum = () =&amp;gt; { let first;let second;let third;return ran().then((num1) =&amp;gt; {first = num1; return ran();}) .then((num2) =&amp;gt; {second = num2; return ran();}) .then((num3) =&amp;gt; {third = num3; return first + second + third;}); goodlet sum = () =&amp;gt; { let first = await ran();let second = await ran();let third = await ran();return first + second + third;});async-await참고JS스럽게-좋은-코드-쓰기-꿀팁" }, { "title": "git log option", "url": "/posts/gitlogoption/", "categories": "tip", "tags": "", "date": "2020-09-16 00:00:00 +0900", "snippet": " git log option 정리 주요 옵션 예)$ git log --name-only -2commit c555ea057d291bcca9e4c880505bde5159fa1a5e (HEAD -&amp;gt; dev, origin/master, origin/dev, master)Author: ayj1002Date: Wed Sep 16 09:24:52 2020 +0900 포틀릿 사진 url 변경src/main/java/egovframework/com/cop/bbs/web/EgovBBSManageController.javacommit 3411d65791260e9d33e38c61cdd2cfeded475283Author: dackpro00Date: Mon Sep 14 15:58:05 2020 +0900 포틀릿 jsop clean 적용 , 사용자 정보 확인 API 추가 및 예외 처리.classpath.gitignore.settings/org.eclipse.wst.common.componentpom.xmlsrc/main/java/egovframework/com/cop/bbs/web/EgovBBSManageController.javasrc/main/java/egovframework/com/uat/uia/web/EgovSessionInterceptor.javasrc/main/java/egovframework/com/uat/uia/web/LoginCheckController.javasrc/main/resources/egovframework/egovProps/globals.properties 옵션 설명 -p 각 커밋에 적용된 패치를 보여준다. –stat 각 커밋에서 수정된 파일의 통계정보를 보여준다. –shortstat –stat 명령의 결과 중에서 수정한 파일, 추가된 라인, 삭제된 라인만 보여준다. –name-only 커밋 정보중에서 수정된 파일의 목록만 보여준다. –name-status 수정된 파일의 목록을 보여줄 뿐만 아니라 파일을 추가한 것인지, 수정한 것인지, 삭제한 것인지도 보여준다. –abbrev-commit 40자 짜리 SHA-1 체크섬을 전부 보여주는 것이 아니라 처음 몇 자만 보여준다. –relative-date 정확한 시간을 보여주는 것이 아니라 “2 weeks ago” 처럼 상대적인 형식으로 보여준다. –graph 브랜치와 머지 히스토리 정보까지 아스키 그래프로 보여준다. –pretty 지정한 형식으로 보여준다. 이 옵션에는 oneline, short, full, fuller, format이 있다. format은 원하는 형식으로 출력하고자 할 때 사용한다. –oneline –pretty=oneline –abbrev-commit 두 옵션을 함께 사용한 것과 같다. 출력 포멧 형식 옵션+예)$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit 옵션 설명 %H 커밋 해시 %h 짧은 길이 커밋 해시 %T 트리 해시 %t 짧은 길이 트리 해시 %P 부모 해시 %p 짧은 길이 부모 해시 %an 저자 이름 %ae 저자 메일 %ad 저자 시각 (형식은 –-date=옵션 참고) %ar 저자 상대적 시각 %cn 커미터 이름 %ce 커미터 메일 %cd 커미터 시각 %cr 커미터 상대적 시각 %s 요약 필터 기능 예)$ git log -3commit c555ea057d291bcca9e4c880505bde5159fa1a5e (HEAD -&amp;gt; dev, origin/master, origin/dev, master)Author: ayj1002Date: Wed Sep 16 09:24:52 2020 +0900 포틀릿 사진 url 변경commit 3411d65791260e9d33e38c61cdd2cfeded475283Author: dackpro00Date: Mon Sep 14 15:58:05 2020 +0900 포틀릿 jsop clean 적용 , 사용자 정보 확인 API 추가 및 예외 처리commit 626b2e24824c50629a8dcfcb8aa16a64685b8d42Author: SVN관리Date: Thu Sep 3 16:08:22 2020 +0900 업데이트 &#39;README.md&#39; 옵션 설명 -(n) 최근 n 개의 커밋만 조회한다. –since, –after 명시한 날짜 이후의 커밋만 검색한다. –until, –before 명시한 날짜 이전의 커밋만 조회한다. –author 입력한 저자의 커밋만 보여준다. –committer 입력한 커미터의 커밋만 보여준다. –grep 커밋 메시지 안의 텍스트를 검색한다. -S 커밋 변경(추가/삭제) 내용 안의 텍스트를 검색한다. 참조문서" }, { "title": "alias setting", "url": "/posts/%EB%A6%AC%EB%88%85%EC%8A%A4aliassetting/", "categories": "linux", "tags": "", "date": "2020-09-11 00:00:00 +0900", "snippet": " checking a bashrc file vi ~/.bashrc result[EX] # .bashrc# User specific aliases and functionsalias rm=&#39;rm -i&#39;alias cp=&#39;cp -i&#39;alias mv=&#39;mv -i&#39;# Source global definitionsif [ -f /etc/bashrc ]; then . /etc/bashrc . ~/.bash_aliasesfi add bash_aliases vi ~/.bash_aliases add alias alias pet=&quot;ps -ef|grep tomcat&quot;alias tst=&quot;./bin/catalina.sh start &amp;amp;&amp;amp; tail -f logs/catalina.out&quot; reloading a resource file source ~/.bashrc " }, { "title": "깃 간단 사용법", "url": "/posts/%EA%B9%83%EA%B0%84%EB%8B%A8%EC%82%AC%EC%9A%A9%EB%B2%95/", "categories": "tip", "tags": "", "date": "2020-09-03 00:00:00 +0900", "snippet": " 간단 구조 깃은 3가지 저장소를 가지고 있습니다. 로컬 저장소 스테이지 [ 임시 저장소 ] 리모트 저장소 시작하기 완전 신규 $ git init $ touch readme.md $ git add . $ git commit -m &quot;first commit&quot; 원격 저장소에서 복사해올 경우 $ git clone [원격지주소] 브랜치 생성 $ git branch 브랜치 이동 $ git checkout [브랜치 명] master의 변경사항 가져와 병합 하기 $ git checkout master $ git pull $ git checkout [브랜치 명] $ git merge master " }, { "title": "@Autowired vs @Required on setter", "url": "/posts/AutowiredvsRequired/", "categories": "why", "tags": "", "date": "2020-09-02 00:00:00 +0900", "snippet": " @Autowired vs @Required on setter 두코드 사이의 차이점이 뭔가요? class MyClass { @Autowired MyService myService; } class MyClass { MyService myService; @Required public void setMyService(MyService val) { this.myService = val; } } 선택된 답변 @Autowired 는 지정된 dataType에 맞는 데이터를 자동으로 주입해 줍니다. 사용에는 제한이 없습니다. 생성자나 필드에도 사용가능하죠. @Required 는 부분적인 속성의 존재여부를 확인합니다. 때문에, 해당 @Required 을사용한 속성의 경우, 해당 값이 없을 경우, 예외를 발생합니다. @Autowired(required=false) 형태를 통해 @Autowired 에서도 값을 체크 가능합니다. stackOverflow " }, { "title": "Iframe메세지전달", "url": "/posts/iframe%EB%A9%94%EC%84%B8%EC%A7%80%EC%A0%84%EB%8B%AC/", "categories": "tip", "tags": "", "date": "2020-08-20 00:00:00 +0900", "snippet": " 기본 송신 window.parent.postMessage( data, [ports], targetOrigin ); //자식 - 부모 child.contentWindow.postMessage( data, [posts] , targetOrigin ); // 부모 - 자식 수신 window.addEventListener( &#39;message&#39;, function( e ) { // e.data가 전달받은 메시지 console.log( e.data ); } ); 출처 : http://blog.302chanwoo.com/2016/08/postmessage/ " }, { "title": "트러블슈팅", "url": "/posts/AOP%EB%AF%B8%EC%9D%B8%EC%8B%9D%EC%8B%9C%ED%99%95%EC%9D%B8/", "categories": "troubleshoting", "tags": "", "date": "2020-08-14 00:00:00 +0900", "snippet": " AOP 미인식시 확인 파일 context-common.xml component-scan 여부 context-aspect.xml aop:aspectj-autoproxy 여부 context-servlet.xml aop:aspectj-autoproxy 여부 componet-scan&amp;lt;context:component-scan base-package=&quot;first&quot;&amp;gt; &amp;lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt; &amp;lt;/context:component-scan&amp;gt; aop:aspectj-autoproxy &amp;lt;aop:aspectj-autoproxy/&amp;gt; 참고" }, { "title": "디비 링크 테이블 조회 쿼리", "url": "/posts/%EB%94%94%EB%B9%84%EB%A7%81%ED%81%AC%ED%85%8C%EC%9D%B4%EB%B8%94%EC%A1%B0%ED%9A%8C%EC%BF%BC%EB%A6%AC/", "categories": "tip", "tags": "", "date": "2020-08-07 00:00:00 +0900", "snippet": " 디비 링크 테이블 조회 쿼리 SELECT * FROM USER_TABLES@DB_LINK_NAME " }, { "title": "oauth", "url": "/posts/TIL-oauth/", "categories": "oauth", "tags": "", "date": "2020-03-09 00:00:00 +0900", "snippet": "Oauth 회사 방문 과정 Oauth 인증과정 나방문씨가 안내 데스트에서 업무적인 목적으로 김목적씨를 만나러 왔다고 요청 Request Token의 요청과 발급 안내 데스크에서는 김목적씨에게 나방문씨가 방문했다고 연락 사용자 인증페이지 호출 김목적씨가 안내 데스크로 찾아와 나방문씨의 신원을 확인 사용자 로그인 완료 김목적씨는 업무 목적과 인적 사항을 안내데스크에서 기록 사용자의 권한 요청 및 수락 안내 데스크에서 나방문씨에게 방문증을 발급해 준다. Access Token 발급 김목석씨와 나방문씨는 정해진 장소로 이동해 업무를 진행 Access Token을 이용해 서비스 정보 요청 step01 회사 방문 과정 Oauth 인증과정 나방문씨가 안내 데스트에서 업무적인 목적으로 김목적씨를 만나러 왔다고 요청 Request Token의 요청과 발급 타입 내용 상세 Request oauth_callback, oauth_consumer_key, oauth_nonce, oauth_signature, oauth_signature_method, oauth_timestamp, oauth_version Request Token 요청 Response oauth_token , oauth_token_secret Request Token 요청에 대한 서비스 제공자의 반환 값 Access_Token 요청시 oauth_token_secret을 암호화키로 사용하기 때문에, 해당 값을 보관해야 한다.create oauth_signature1. 요청매개변수 취합 (oauth_signature 제외)2. 매개변수 정규화3. Signature Base String 생성 - [GET|POST]+ &amp;amp; + [URL] + &amp;amp; + [정규화된 매개변수]4. 키생성 - 서비스 제공자에게 발급받은 Consumer secret key 사용 step02 회사 방문 과정 Oauth 인증과정 안내 데스크에서는 김목적씨에게 나방문씨가 방문했다고 연락 사용자 인증페이지 호출 김목적씨가 안내 데스크로 찾아와 나방문씨의 신원을 확인 사용자 로그인 완료 김목적씨는 업무 목적과 인적 사항을 안내데스크에서 기록 사용자의 권한 요청 및 수락 서비스제공자가 정해놓은 사용자 인증페이지 주소에 oauth_token을 매개변수로 전달한다.ex ) https:\\//사용자인증페이지주소?oauth_token=Request Token요청으로 받은 반환값 중 oauth_token인증 완료 후, oauth_callback 주소로 새로운 oauth_token과 oauth_verifier를 전달 타입 내용 상세 Response oauth_token(신규), oauth_verifier 인증 후,서비스제공자가 oauth_callback 주소로 반환하는 값 step03Access_Token 요청Access_Token은 방문증과 같다 회사 방문 과정 Oauth 인증과정 안내 데스크에서 나방문씨에게 방문증을 발급해 준다. Access Token 발급 타입 내용 상세 Request oauth_consumer_key, oauth_nonce, oauth_signature, oauth_signature_method, oauth_timestamp, oauth_version, oauth_verifier, oauth_token Access_Token 요청 Response oauth_token , oauth_token_secret Access_Token 요청에 대한 서비스 제공자의 반환 값 create oauth_signature1. 요청매개변수 취합 (oauth_signature 제외)2. 매개변수 정규화3. Signature Base String 생성 - [GET|POST]+ &amp;amp; + [URL] + &amp;amp; + [정규화된 매개변수]4. 키생성 - 서비스 제공자에게 발급받은 Consumer secret key + &amp;amp; + oauth_token_secret 사용 step04인증값은 HEAD 부분에 Authorization 필드 값 부분에 사용 타입 내용 상세 Request oauth_consumer_key, oauth_nonce, oauth_signature, oauth_signature_method, oauth_timestamp, oauth_version, oauth_token Access_Token을 사용하여 서비스제공자가 제공하는 API 서비스 획득, 값 값은 HTTP 헤더 부분의 Ahthorization 필드를 의 값부분에 해당 매대변수를 작성 요청시, 서비스제공자가 realm이라는 매개변수 사용을 요청하는 경우, WWW-Authenticate HTTP 헤더 필드에서 사용하면 된다.Oauth 2.0 웹 애플리케이션이 아닌 애플리케이션 지원 강화 암호화가 필요 없음 (HTTPS사용) HMAC을 사용하지 않음 Signature 단순화 정렬과 URL 인코딩이 필요없음 보안을 위해 Access_Token의 Life-tiem을 두어 사용 기간을 설정(1.0에서는 해당 기능 부재)" }, { "title": "signing", "url": "/posts/TIL-signing/", "categories": "signing", "tags": "", "date": "2020-03-09 00:00:00 +0900", "snippet": "전자서명 프로그램 악성 여부 확인 원산지 표시(조작을 검증하는 기술적 장치가 있다)기본기술 해시함수 해시값 = 지문 바이너리값의 중복 = 충돌 해시값은 원래 바이너리 값으로 복원이 불가 MD5(128) , sha2(512) 암호화와는 다르다(복호화 불가) 같은 값은 항상 같은 해시값을 갖는다 공개키 암호화(비대칭키 암호화) 암호화 키가 공개되어도 상관없다 = 공개키 공개되지 않는 키 = 개인키 대칭키 암호화 유명한 방식 : AES 무결성 확인 해시값을 이용하여 확인 배포하고자 하는 해시값을 변조 당하면 무의미 진보된 무결성 확인 원본 바이너리로 생성된 해시값을 개인키로 암호화하여, 복호화 키와 함께 배포 생성된 해시값을 암호화하여 나온값 = 서명 원본 바이너리 + 서명 + 복호화 키(공개키)를 만드는 과정 = 코드사인 코드사인된 바이너리를 사용자에게 배포 사용자 입장 코드사인된 바이너리 코드를 획득 원본 바이너리 , 서명, 복호화 키 분리 원본 바이너리로 해시값을 생성 복호화키를 이용하여 서명에서 원본 해시값을 획득 생성된 두 해시값을 비교하여 무결정 판정취약점 코드사인 이전에 파일 변조시, 신뢰할수 없다.공인인증서 복호화 키가 포함된 파일 추가적인 정보도 포함 ( 주체(제작자), 주체(제작자)의 공개키, 발급자(공인인증기관), 발급자의 서명, 발급자의 공개키 등등 ) 신뢰할 수 있는 공인 인증 기관에 공개키와 사명을 등록(인감도장을 새로 만들어 동사우소에서 등록하는 것과 유사하다) 발급자의 서명 = 인증서에 기록된 정보(발급자의 서명 제외)를 하나로 모은후 해시 함수에 입력하여 해시값을 얻어, 발급자의 암호화키로 해당 해시값을 암호화 결과진보된 무결성 확인 2 원본 바이너리 + 서명 + 인증서 = 코드사인사용자 입장 코드사인된 바이너리 코드를 획득 원본 바이너리 , 서명, 인증서 분리 원본 바이너리로 해시값을 생성 복호화키를 이용하여 서명에서 원본 해시값을 획득 생성된 두 해시값을 비교하여 무결정 판정 인증서의 주체확인 발급자 서명을 발급자의 공개키로 복호화하여 해시값을 얻고, 인증서에 기록된 정보들을 해시함수에 입력하여 해시값을 획득하여 비교(인증서 유효성 검사)ROOT 인증서는 항상 신뢰한다. verisign, kisa 등 root 인증서는 윈도우에 내장되어 있다. 보통 인증서 체인은 3단계에서 해결된다." }, { "title": "git tool", "url": "/posts/pretty/", "categories": "pretty", "tags": "", "date": "2019-10-15 00:00:00 +0900", "snippet": " git 변경사항을 엑티브하게 보는방법 githistory 로컬버전의 경우 아래의 주소로 githistory " }, { "title": "[IntelliJ] intellij 유용한 단축키 정리", "url": "/posts/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4%EB%8B%A8%EC%B6%95%ED%82%A4/", "categories": "", "tags": "", "date": "2019-05-21 00:00:00 +0900", "snippet": "인프런 강의 참고기본 단축키디렉터리, 패키지, 클래스 등 생성 목록 보기 MacOS: Cmd + n Win/Linux: Alt + Insert코드 EditMain method 생성 및 실행 메인 메서드 선언 live template 이용: psvm (live template은 아래 참고) 메인 메서드 실행 좌측 실행 버튼 단축키 현재 Focus 가 해당 메서드에 있어야 함 MacOS: Ctrl + Shift + r Win/Linux: Ctrl + Shift + F10 - 이전 실행문 재실행 (우측 상단에 실행문 목록 확인 가능) MacOS: Ctrl + r Win/Linux: Shift + F10 라인 수정하기 라인 복제하기 MacOS: Cmd + d Win/Linux: Ctrl + d 라인 삭제하기 MacOS: Cmd + 백스페이스 Win/Linux: Ctrl + y 문자열 라인 합치기 MacOS: Ctrl + Shift + j Win/Linux: Ctrl + Shift + j 라인 단위로 옮기기 1) 문법에 관계 없이 라인 이동 MacOS: Opt + Shift + ↑↓ Win/Linux: Alt + Shift + ↑↓ 2) 구문 안에서만 라인 이동 (메서드를 벗어날 수 없음) MacOS: Cmd + Shift + ↑↓ Win/Linux: Ctrl + Shift + ↑↓ Element 단위로 옮기기 Ex. html, xml 등의 규격이 정해진 마크업 언어에서 활용 MacOS: Cmd + Opt + Shift + ←→ Win/Linux: Ctrl + Alt + Shift + ←→ 코드 즉시 보기 인자값 즉시 보기 (Parameter Info) MacOS: Cmd + p Win/Linux: Ctrl + p 코드 구현부 즉시 보기 (Quick Definition) 클래스- 클래스 전체 코드 인스턴스- 인스턴스 생성 코드 메서드- 메서드 정의 코드 MacOS: Opt + Space Win/Linux: Ctrl + Shift + i Doc 즉시 보기 (Quick Documentation) MacOS: F1 Win/Linux: Ctrl + q 포커스포커스 에디터 단어별 이동 MacOS: Opt + ←→ Win/Linux: Ctrl + ←→ 단어별 선택 (Move Caret to Next Word with Selection) MacOS: Opt + Shift + ←→ Win/Linux: Ctrl + Shift + ←→ 라인 첫/끝 이동 MacOS: fn + ←→ Win/Linux: Home, End 라인 전체 선택 MacOS: fn + Shift + ←→ Win/Linux: Shift + Home, End Page Up/Down MacOS: fn + ↑↓ Win/Linux: Page Up, Page Down 포커스 특수키 포커스 범위 한 단계씩 늘리기 (Extend Selection) 해당 커서의 단어 포커스하기 MacOS: Opt + ↑↓ Win/Linux 위: Ctrl + w 아래: Ctrl + Shift + w 포커스 뒤로/앞으로 가기 (Navigate -&amp;gt; Back/Forward) 이전 커서가 있던 화면으로 돌아갈 때 유용 클래스 이동도 가능 MacOS: Cmd + [ 또는 ] Win/Linux: Ctrl + Alt + ←→ 멀티 포커스 (Clone Caret Below) MacOS: Opt + Opt + ↓ (Opt 누른 상태) Win/Linux: Ctrl + Ctrl + ↓ (Ctrl 누른 상태) 오류 라인으로 자동 포커스 (Navigate -&amp;gt; Next Highlighted Error) MacOS: F2 Win/Linux: F2 검색검색 텍스트 현재 파일에서 검색 (Find) MacOS: Cmd + f Win/Linux: Ctrl + f 현재 파일에서 교체 (Replace) MacOS: Cmd + r Win/Linux: Ctrl + r 전체에서 검색 (Find in Path) MacOS: Cmd + Shift + f Win/Linux: Ctrl + Shift + f 전체에서 교체 (Replace in Path) MacOS: Cmd + Shift + r Win/Linux: Ctrl + Shift + r 정규표현식으로 검색, 교체 [Find/Replace] -&amp;gt; Regex 체크 검색 기타 파일 검색 (Navigate -&amp;gt; File) MacOS: Cmd + Shift + o Win/Linux: Ctrl + Shift + n 메서드 검색 (Navigate -&amp;gt; Symbol) MacOS: Cmd + Opt + o Win/Linux: Ctrl + Shift + Alt + n Action 검색 (Find Action: Enter action or option name) MacOS: Cmd + Shift + a Win/Linux: Ctrl + Shift + a 최근 열었던 파일 목록 보기 (Recent Files) MacOS: Cmd + e Win/Linux: Ctrl + e 최근 수정한 파일 목록 보기 (Recently Changed Files) MacOS: Cmd + Shift + e Win/Linux: Ctrl + Shift + e 자동완성자동완성 기본 자동완성 (Completion -&amp;gt; Basic) MacOS: Ctrl + Space Win/Linux: Ctrl + Space 스마트 자동완성 (Completion -&amp;gt; SmartType) MacOS: Ctrl + Shift + Space Win/Linux: Ctrl + Shift + Space static method 자동완성 MacOS: Ctrl + Space + Space Win/Linux: Ctrl + Space + Space getter/setter/생성자 자동완성 (Generate) MacOS: Cmd + n Win/Linux: Alt + Insert Override 메서드 자동완성 (Implement Methods) MacOS: Ctrl + i Win/Linux: Ctrl + i Live Template (Code Template) live template 목록 확인하기 (Insert Live Template) [Find Action] -&amp;gt; Live Templates 입력 MacOS: Cmd + j Win/Linux: Ctrl + j 자주 사용하는 live template 예시 psvm: 메인메서드 선언 sout: System.out.println(); 자동 생성 나만의 live template 추가하기 [Find Action] -&amp;gt; Live Templates 입력 other 선택 -&amp;gt; “+” 버튼 -&amp;gt; Live Template Abbreviation(축약어) Ex. ent Description(설명) Ex. Entity Class Header Template text(텍스트) 아래 예시 Error(No applicable contexts yet.)에서 Define 클릭 Ex. Java 선택 Apply &amp;amp; OK // ORM에서의 반복적인 코드 (live template로 설정)@Getter@NoArgsConstructor(access = AccessLevel.PROOTECTED)@Entity/** Entity Class */public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id;}리팩토링리팩토링 Extract 변수 추출하기 (Extract -&amp;gt; Variable) MacOS: Cmd + Opt + v Win/Linux: Ctrl + Alt + v 파라미터 추출하기 (Extract -&amp;gt; Parameter) MacOS: Cmd + Opt + p Win/Linux: Ctrl + Alt + p 메서드 추출하기 (Extract -&amp;gt; Method) MacOS: Cmd + Opt + m Win/Linux: Ctrl + Alt + m 이너클래스 추출하기 MacOS: F6 Win/Linux: F6 리팩토링 기타 이름 일괄 변경하기 (Rename) MacOS: Shift + F6 Win/Linux: Shift + F6 타입 일괄 변경하기 (Type Migration) MacOS: Cmd + Shift + F6 Win/Linux: Ctrl + Shift + F6 Import 정리하기 (Optimize Imports) MacOS: Ctrl + Opt + o Win/Linux: Ctrl + Alt + o 자동 설정: [Find Action] -&amp;gt; Optimize imports on 입력 -&amp;gt; “Auto import: …” 코드 자동 정렬하기 (Reformat Code) MacOS: Cmd + Opt + l Win/Linux: Ctrl + Alt + l 디버깅디버깅 Break Point 걸기 (Toggle Line Breakpoint) 해당 라인 number 옆 클릭 MacOS: Cmd + F8 Win/Linux: Ctrl + F8 Break Point의 라인은 아직 실행하기 전 상태이다. Conditional Break Point 반복문에서 특정값을 가지고 있는 객체가 나왔을 때만 멈추고자 할 때 유용 Break Point (빨간원) 우클릭 -&amp;gt; 조건 입력 Ex. “HEEE”.equals(user.name) Debug 모드로 실행하기 - 즉시 실행 (Debug) 현재 Focus 가 해당 메서드에 있어야 함 좌측 디버그 실행 버튼 MacOS: Ctrl + Shift + d Win/Linux: 없음 (커스텀해서 사용하거나 마우스 이용) Debug 모드로 실행하기 - 이전 실행 이전 실행문 재실행 (우측 상단에 실행문 목록 확인 가능) MacOS: Ctrl + d Win/Linux: Shift + F9 Breaking 상태에서의 기능 Resume (다음 Break Point로 넘어가기) MacOS: Opt + Cmd + r Win/Linux: F9 참고 Debugger 탭 설명 Debugger 탭 좌측 창 - Call Stack 현재 Break Point로 넘어오기까지 실행한 메서드 목록 오픈 소스 코드를 분석할 때 유용 Debugger 탭 우측 창 - Variables 현재 Break Point에서 볼 수 있는 변수값 목록 Step Over (다음 라인으로 넘어가기) MacOS: F8 Win/Linux: F8 Step Into (해당 라인 안(다음 메서드)으로 들어가기) MacOS: F7 Win/Linux: F7 Step Out (현재 포커스를 밖으로 빼기) MacOS: Shift + F8 Win/Linux: Shift + F8 Evaluate Expression (현재 Breaking 상태에서 즉시 코드 실행하기) MacOS: Opt + F8 Win/Linux: Alt + F8 데이터가 잘 들어갔는지 확인할 때 유용 켤 때마다 초기화 - 단발성 코드를 실행할 때 유용 Watch (Breaking 이후의 코드 변경 확인하기) MacOS: 없음 Win/Linux: 없음 다음 Break Point 전까지 확인하고 싶은 값을 계속 주시하고자할 때 유용 Git &amp;amp; GithubGit 기본 기본 기능 사용하기 Git View On View 탭 -&amp;gt; Tool Windows -&amp;gt; Version Control MacOS: Cmd + 9 Win/Linux: Alt + 9 Git Option Popup (VCS Operations Popup) MacOS: Ctrl + v Win/Linux: Alt + `(Back Quote) Git History MacOS: Ctrl + v =&amp;gt; 4 Win/Linux: Alt + ` =&amp;gt; 4 Branch MacOS: Ctrl + v =&amp;gt; 7 Win/Linux: Alt + ` =&amp;gt; 7 Commit MacOS: Cmd + k Win/Linux: Ctrl + k Push MacOS: Cmd + Shift + k Win/Linux: Ctrl + Shift + k Pull MacOS: [Find Action] =&amp;gt; git pull 검색 Win/Linux: [Find Action] =&amp;gt; git pull 검색 플러그인플러그인 설치 방법 [Find Action] -&amp;gt; plugins 입력 -&amp;gt; Preferences/Settings의 Plugins 선택 Browse repositories… 클릭 Sort by: Downloads 로 설정추천 플러그인 presentation assistant 다른 OS에서 해당 단축키가 어떤 것인지 알려준다. 발표/시연용으로 사용할 때 유용하다. .gitignore 자동완성 기능을 제공한다. BashSupport 실행 파일에 대한 여러 기능을 제공한다. Cf. 실행 권한 변경 후 실행 가능 chmod +x app.sh Material Theme UI 추천 테마 jojoldu Translation 영문 코드를 한글로, 한글을 영문으로 번역해주는 기능을 제공한다. Reference https://www.inflearn.com/course/intellij-guide/lecture/13200 이미지 참고 코그 참고 " }, { "title": "이력서체크리스트", "url": "/posts/%EC%9D%B4%EB%A0%A5%EC%84%9C%EC%B2%B4%ED%81%AC%EB%A6%AC%EC%8A%A4%ED%8A%B8/", "categories": "resume", "tags": "", "date": "2012-12-17 00:00:00 +0900", "snippet": "이력서 관련 체크리스트 정리 링크" } ]
